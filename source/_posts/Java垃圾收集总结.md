---
title: Java垃圾收集总结
date: 2020-09-04 08:51:50
tags: java
categories: Java
toc: true
---

## 一，垃圾收集的相关原理
- 垃圾回收的前提是清楚哪些内存可以被释放
- 跟进Java里JVM内存结构可以知道，对象的实例都存放在堆上，还有就是方法区的元数据，这2部分内存的分配和回收都是动态的，垃圾收集器所关注的正是这部分内存。

### 1. 判断对象是否存活可回收
- 对对象实例的收集主要是两种基本算法

```
引用计数法
可达性分析法
```

- **引用计数法**：在对象头维护着一个 counter 计数器，对象被引用一次则计数器 +1；若引用失效则计数器 -1。当计数器为 0 时，就认为该对象无效了。
```
引用计数算法的实现简单，判定效率也很高，在大部分情况下它都是一个不错的算法。但是主流的 Java 虚拟机里没有选用引用计数算法来管理内存，主要是因为它很难解决对象之间循环引用的问题。
例如：对象 objA 和 objB 都有字段 instance，令 objA.instance = objB 并且 objB.instance = objA，由于它们互相引用着对方，导致它们的引用计数都不为 0，于是引用计数算法无法通知 GC 收集器回收它们
```

- **可达性分析法**： 所有和 GC Roots 直接或间接关联的对象都是有效对象，和 GC Roots 没有关联的对象就是无效对象。
- GC Roots 指虚拟机栈和本地方法栈中正在引用的对象、静态属性引用的对象和常量。即方法运行时，方法中引用的对象；类的静态变量引用的对象；类中常量引用的对象，Native方法中引用的对象

### 2.回收方法区内存
- 方法区中存放生命周期较长的类信息、常量、静态变量，每次垃圾收集只有少量的垃圾被清除。方法区中主要清除两种垃圾：

```
废弃常量
无用的类
```
- **判定废弃常量:**
- 只要常量池中的常量不被任何变量或对象引用，那么这些常量就会被清除掉。比如，一个字符串 "bingo" 进入了常量池，但是当前系统没有任何一个 String 对象引用常量池中的 "bingo" 常量，也没有其它地方引用这个字面量，必要的话，"bingo"常量会被清理出常量池。
- **判定无用的类** , 判定一个类是否是“无用的类”，条件较为苛刻。
```
该类的所有对象都已经被清除
加载该类的 ClassLoader 已经被回收
该类的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
一个类被虚拟机加载进方法区，那么在堆中就会有一个代表该类的对象：java.lang.Class。这个对象在类被加载进方法区时创建，在方法区该类被删除时清除
```

## 垃圾收集算法
- 知道如何判定无效对象、无用类、废弃常量之后，剩余工作就是回收这些垃圾。常见的垃圾收集算法有以下几个：



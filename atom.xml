<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zhulg笔记</title>
  
  <subtitle>兴趣是最好的老师，其次是耻辱</subtitle>
  <link href="https://zhulg.github.io/atom.xml" rel="self"/>
  
  <link href="https://zhulg.github.io/"/>
  <updated>2024-07-14T11:01:51.201Z</updated>
  <id>https://zhulg.github.io/</id>
  
  <author>
    <name>zhulg</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>技术重构何时做，为什么做要想清楚</title>
    <link href="https://zhulg.github.io/posts/39b94e3a.html"/>
    <id>https://zhulg.github.io/posts/39b94e3a.html</id>
    <published>2024-07-14T10:58:39.000Z</published>
    <updated>2024-07-14T11:01:51.201Z</updated>
    
    <content type="html"><![CDATA[<h1 id="技术重构何时做，为什么做要想清楚"><a href="#技术重构何时做，为什么做要想清楚" class="headerlink" title="技术重构何时做，为什么做要想清楚"></a>技术重构何时做，为什么做要想清楚</h1><p><em>代码重构（Refactoring）是指在不改变代码外部行为的前提下，对代码内部结构进行调整，以提高代码的可读性、可维护性和可扩展性。</em></p><ul><li><p>重构的目标是让代码变得更简洁、更优雅、更容易理解和修改</p></li><li><p>重构不难，何时做，以及为什么要做要想清楚，不要为了重构而重构、不为了KPI 夸大事实来重构。</p></li></ul><h1 id="何时进行代码重构"><a href="#何时进行代码重构" class="headerlink" title="何时进行代码重构"></a>何时进行代码重构</h1><h2 id="1-交付快慢"><a href="#1-交付快慢" class="headerlink" title="1.交付快慢"></a>1.交付快慢</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当写一个需求发现代码新增量比较大，代码编写比较多</span><br><span class="line"></span><br><span class="line">扩展一个功能发现要改动范围比较多，涉及多个文件或者类</span><br></pre></td></tr></table></figure><ul><li><p>可能要考虑是否原来的代码没有基建，造成重复增加代码。</p></li><li><p>扩展的功能没有模块化、没有分层、要反复改动多处。</p></li></ul><p><strong>交付缓慢，当代码变得难以理解和维护且错误频出时，可能就是重构的最佳时机</strong></p><h2 id="2-使用体验"><a href="#2-使用体验" class="headerlink" title="2.使用体验"></a>2.使用体验</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当使用产品时卡顿、不流畅，页面加载时间比较长</span><br><span class="line">使用中应用频繁出错、页面出错，内存读写等问题</span><br></pre></td></tr></table></figure><ul><li>可能需要看下卡顿的原因，性能问题、渲染问题、数据量过大造成请求缓慢等问题，可能来源于代码的效率低下、资源的过度消耗等。</li></ul><p><strong>当系统体验已经严重影响用户了，就需要重构提高系统的响应速度和稳定性</strong></p><h2 id="3-需求变化"><a href="#3-需求变化" class="headerlink" title="3.需求变化"></a>3.需求变化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当需求或者业务发生变化时，代码无法通过相关配置进行快速开发</span><br><span class="line">为满足需求变化，需要改动大的模块进行调整，牵一发而动全身的代码调整代价</span><br></pre></td></tr></table></figure><ul><li>需要从架构设计、模块耦合、数据隔离等方面来判断造成代码耦合度高，不能快速响应业务和需求变化的原因。</li></ul><p><strong>更好地适应新的需求变化，此时进行重构，确保系统的灵活性和可扩展性</strong></p><h2 id="4-技术问题"><a href="#4-技术问题" class="headerlink" title="4.技术问题"></a>4.技术问题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当原有的系统使用框架、组件在开发需求中不能满足新的呈现形式</span><br><span class="line"></span><br><span class="line">当老的控件开发速度缓慢、还有相关老技术所暴露的安全隐患类问题</span><br></pre></td></tr></table></figure><ul><li>需要评估老技术的局限性，并判断新技术的稳定性、快捷性，能从效率和稳定性上改善老系统</li></ul><p><strong>如果系统依赖于过时的技术，此时需要重构来升级技术、确保系统安全和可维护性。</strong></p><h2 id="5-团队人员变化"><a href="#5-团队人员变化" class="headerlink" title="5.团队人员变化"></a>5.团队人员变化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当团队人员发生变化，老的系统、代码无人知晓和熟悉</span><br><span class="line">新人不知道原来逻辑，要看懂别人代码、维护代码成本都会比较高</span><br></pre></td></tr></table></figure><ul><li>当对系统的代码不熟悉，新的扩展和改动逻辑都会是比较危险的事情，可能里面一些坑因为不知道逻辑，导致系统频繁出错。</li></ul><p><strong>此时进行重构可以帮助新成员更快地上手业务、梳理代码逻辑，同时熟悉到系统间关联代码。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;技术重构何时做，为什么做要想清楚&quot;&gt;&lt;a href=&quot;#技术重构何时做，为什么做要想清楚&quot; class=&quot;headerlink&quot; title=&quot;技术重构何时做，为什么做要想清楚&quot;&gt;&lt;/a&gt;技术重构何时做，为什么做要想清楚&lt;/h1&gt;&lt;p&gt;&lt;em&gt;代码重构（Refac</summary>
      
    
    
    
    <category term="技术成长" scheme="https://zhulg.github.io/categories/技术成长/"/>
    
    
    <category term="技术成长" scheme="https://zhulg.github.io/tags/技术成长/"/>
    
  </entry>
  
  <entry>
    <title>35岁+技术人成长和思考</title>
    <link href="https://zhulg.github.io/posts/a07268b7.html"/>
    <id>https://zhulg.github.io/posts/a07268b7.html</id>
    <published>2024-07-13T04:46:46.000Z</published>
    <updated>2024-07-13T04:59:25.369Z</updated>
    
    <content type="html"><![CDATA[<h1 id="35岁-技术人成长和思考"><a href="#35岁-技术人成长和思考" class="headerlink" title="35岁+技术人成长和思考"></a>35岁+技术人成长和思考</h1><p>当前经济下新业务增长放缓，企业降本增效、裁员风波频发，技术人年龄增长、生活和家庭责任亦愈加繁重，房子、车子等等这些方面的压力迎面而来。</p><p>在这种不确定性中，技术人如何找到自己的定位、如何稳定情绪并做到坚定信念、如何持续迭代自己的技能与知识，直面所谓的35岁+危机，破解焦虑，实现个人与职业的持续成长，以下几个方面可以与大家一起思考和共勉。</p><h2 id="1-认知和调整"><a href="#1-认知和调整" class="headerlink" title="1.认知和调整"></a>1.认知和调整</h2><p>最近技术圈整体现状来看，如果目前的工作让你疲惫不堪的在苟且偷生、或者已经经历了大礼包的洗礼、亦或正在不被重用、边缘化，或者PUA等等。</p><p>首先，需要意识到这些变化并不是个人失败的象征（如果你浑水摸鱼，这个无解), 而是行业整体环境的反映，欣然接受这一现实也没有什么不好意思，更不要怀疑自己的能力。</p><p>其次，静下心享受这个过程，调整我们的职业期望和目标，仔细审视自己的职业发展路径是否与当前市场的需求和技术发展的趋势相匹配，所面对的人和事，自己是否有迭代优化的地方</p><p>调整心态练就在逆境中前进的能力，对正确的事继续坚持，对不足进行挖掘和复盘，把不足写下来，疯狂练起来。</p><p>最后，无论遇到什么样的问题和挑战，都不能忘记技术人的价值不仅仅在于掌握的技术和解决的问题，更在于我们的思考方式对问题认知和理解。</p><p>调整心态，忘记不公、做到及时止损，顺应趋势的努力，思考如何将过去的经验学习和新业务结合起来。你可以用技术降维打击创新业务，同时也要接触多思维方式，避免一条道轴到底。</p><h2 id="2-技能与学习"><a href="#2-技能与学习" class="headerlink" title="2.技能与学习"></a>2.技能与学习</h2><p>技术的进步日新月异，在技术行业专业技能的迭代和更新至关重要的，持续学习新东西的前提是有足够的兴趣，并了解新技术带来哪些生成力的提升，以及对目前的业务和项目有哪些提升，学习成本如何、能否与业务进行结合，在持续提升技术的同时，需要认清自身的局限性，以及错误的观念，先来审视一下。</p><h4 id="补足基础："><a href="#补足基础：" class="headerlink" title="补足基础："></a>补足基础：</h4><p>在技术领域，所有的创新和开发语言的迭代，都离不开行业基础，因此你的基础需要扎实，在学习任何新技术时，先把已有的基础掌握了，不要盲目认为新技术、换技术栈就可以能学的很好。</p><p>当你计算机基础功底不够时，任何新的技术都不是能快速学习和掌握的，即便掌握也是在皮毛层进行应用，因此当原理不清，学习原理，基础不会，学习基础，补足基础能力。</p><h4 id="保持技术热爱："><a href="#保持技术热爱：" class="headerlink" title="保持技术热爱："></a>保持技术热爱：</h4><p>35岁+技术人大概率经历过早期互联网1.0红利，到移动互联网黄金时代2.0，再到目前眼下互联网3.0 、AI、区块链、 web3.0 、以OpenAI为代表的大模型技术、智能驾驶等等。</p><p>所有新的技术都不会以断层的形式横空出世，都会在原有基础上更新和迭代，包括各种开发语言 Java go kotlin swift flutter rust Typescript 以及仓颉语言等等，他用似曾相识的语法和各有千秋的创新来解决面临的问题，从并发，从速度，从内存等等。</p><p>怎么做是不是全学一遍？不是。</p><p>需要对一种语言进行深入学习，同时对新语言和框架能从原理认识和学习，在足够深度下涉猎广度的学习，语言只是工具，数据结构和问题解决思路才是核心。</p><p>不要断层式学习要持续学习，当你见过足够多各有千秋语言，对各种框架设计足够理解，保持新技术学习和理解，学习新东西的速度也会更快和轻松，万变不离其宗。</p><h2 id="3-软硬实力"><a href="#3-软硬实力" class="headerlink" title="3.软硬实力"></a>3.软硬实力</h2><p>这个年龄的技术人大多已经具备了不错的硬实力，也就是专业技术领域，架构设计等，技术人需要具备的能力，但软实力在这个年龄段又也是必须的， 技术人更应该注重自己软技能的历练。</p><h4 id="沟通能力"><a href="#沟通能力" class="headerlink" title="沟通能力"></a>沟通能力</h4><p>能够清晰、准确地表达自己的想法，同时也要善于倾听他人的观点。核心要能能清晰表达与非技术人员进行沟通和交流，能让他们听懂你语言和表达，注意用非技术语言陈述。</p><h4 id="团队协作"><a href="#团队协作" class="headerlink" title="团队协作"></a>团队协作</h4><p>在项目开发过程中，团队协作尤为重要，技术人员需要具备良好的团队精神，能够和团队成员有效合作，共同完成任务，多学他人的优点，多看别人优势。</p><h4 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h4><p>这个年龄的技术人，在看到问题时，更多需要关注问题产生的原因，通过问题现象挖掘本质，总结产生问题的周边防范措施，不仅仅是在解决在某一个问题上。</p><h4 id="业务和产品思维"><a href="#业务和产品思维" class="headerlink" title="业务和产品思维"></a>业务和产品思维</h4><p>无论在不在技术管理岗或者产品岗，这个阶段都需要具备产品思维，理解产品的需求，知道如何利用技术来实现产品的价值，理解业务的运作模式，知道如何利用技术来推动业务的发展。</p><h4 id="汇报和向上管理"><a href="#汇报和向上管理" class="headerlink" title="汇报和向上管理"></a>汇报和向上管理</h4><p>向上汇报要提炼出核心的东东，具备总结能力、抽象能力，有一定的思考和吹泡泡(ppt)能力，满足向上管理需要，上级没时间从长篇大论里提炼信息，需要浓缩在PPT里进行呈现汇报。</p><p>尽管多数技术人鄙视这种文化，但现实中你还是要具备ppt的汇报总结能力。</p><p>向上管理更多是主动反馈和汇报，事事有回应 ，件件有着落 ，定期向上级报告工作进度和结果，理解和支持上级的决策。</p><p>哪怕是你遇到上级很傻的决定，或许有你看不到的背景和信息，就坚定的支持（威胁你的合法利益的除外），给上级提供正确解决方案建立信任（如果上级已经看你不顺眼，开始穿小鞋，那也就没必要自作多情，及时止损）</p><p>无论何时得罪你上级可能不是明智的，但也不是陪着老板一起瞎搞，至少要做一个正直的技术人，不作恶，在明显的错误决策下，也要给出一些合理建议出来。</p><h2 id="4-职业发展"><a href="#4-职业发展" class="headerlink" title="4.职业发展"></a>4.职业发展</h2><p>这个年龄的技术人可能也会从3个方面发展，一个是技术专家路线，一个是技术管理路线，一个是其他路线。其他路线可能是换赛道、创业、新的铁人三项等等。(如果不知道什么新铁人三项，就忽略说明不适合)</p><h4 id="专家路线"><a href="#专家路线" class="headerlink" title="专家路线"></a>专家路线</h4><p>深耕技术领域。虽然国内最早有35+一道坎，技术人也是青春饭说法，但身边一些技术大牛也有不少40+，这个说明国内行业也在慢慢变化，愿意走专家路线的就不要担心年龄，十年如一日的技能、经验，也一定可以在这个行业行的通。</p><p>但也要警惕自己理论专家，脱离实际业务和场景，只忽悠老板的专家，这样就只剩下现在我们认为的”专家”了。</p><h4 id="管理路线"><a href="#管理路线" class="headerlink" title="管理路线"></a>管理路线</h4><p>管理路线并不是要放弃技术，更多要具备自己技术判断力，问题定位能力，人员协调组织效率最大好，以团队的力量完成整体项目。</p><p>初期需要从0-1的技术攻坚能力，后期需要足够的团队人员管理能力，需要技术突破时也依旧能顶得上。</p><h4 id="其他路线"><a href="#其他路线" class="headerlink" title="其他路线"></a>其他路线</h4><p>对技术人来说也是不错的选择，工作只是生活的一小部分，技术人不要固执的死磕一个领域，或缺先尝试也是不错的选择，相信你身边也会有工作赛道切换后生活更多彩的人，跟随内心勇于尝试。</p><p>无论专家路线、管理路线，其他路线，核心都要把事情做好，知道自己的目标和方向，想想1年后，2年后你要做成什么样子，为你希望的样子现在需要做些什么。</p><p>把你想成为的样子写下来，把要分解的事情写下来，把要做的事情执行起来，如果预期结果不是你要的，定期纠偏复盘重新来过。</p><h2 id="5-健康生活"><a href="#5-健康生活" class="headerlink" title="5.健康生活"></a>5.健康生活</h2><p>如果现在还能保持上学期间的体重，大概率是比较自律、生活规律的技术人，毕竟在技术圈子里大家早出晚归，缺乏锻炼的大有人在，职业属性颈椎病，鼠标手、三高、前列腺等等，大部分还是长期电脑前久坐导致</p><h4 id="体重和运动"><a href="#体重和运动" class="headerlink" title="体重和运动"></a>体重和运动</h4><p>到了这个年龄了身体管理需要提上日程，技术圈高工作强度也是很容易肥胖产生，并为健康埋下隐患。控制体重进行减肥，这个过程一定会很痛苦，可以尝试一下：</p><ul><li>找一个健身博主跟随练习，坚持下去</li><li>黄瓜、西红柿、生菜可以大量吃，控制油糖摄入</li><li>每天坚持饭后半小时运动，公司爬楼梯，跑步，跳绳等有氧运动</li></ul><p>按照这个操作，先坚持1月看看，以个人经验，3个月拿掉30斤以上体重已完全可能，需要注意是坚持运动，控制碳水摄入，但不是不吃碳水，当碳水摄入太少，期间掉头发这种情况也是真实存在。</p><h4 id="充足休息"><a href="#充足休息" class="headerlink" title="充足休息"></a>充足休息</h4><p>保证充足的休息时间，遇到事不要影响到睡眠，这个很难，可以通过分散精力方式，实在不行把自己累起来，跑跑步，运动起来，累了相对好入睡一些，如果睡眠不足，可能你效率和反应都会随之降低。</p><h2 id="6-坚持执行"><a href="#6-坚持执行" class="headerlink" title="6.坚持执行"></a>6.坚持执行</h2><p>所以这些说起来简单，道理也显而易见，但执行起来也并非容易。</p><p>特别年龄的增长心态的变化、情绪的稳定都需要极强的定力，除此之外家庭生活的压力也要关注和调节，保持内心平静。</p><p>到了这个年龄，意志力与世俗对抗显得格外珍贵，如果要健康，就练起来，能力不足就补起来，抵制不住娱乐陋习就卸掉你那无聊某音某手APP。</p><p>很多人和多事会给你挫败，如果实在难以控制，就不如躺平歇一会，给自己个期限，歇完马上重新雄起。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;35岁-技术人成长和思考&quot;&gt;&lt;a href=&quot;#35岁-技术人成长和思考&quot; class=&quot;headerlink&quot; title=&quot;35岁+技术人成长和思考&quot;&gt;&lt;/a&gt;35岁+技术人成长和思考&lt;/h1&gt;&lt;p&gt;当前经济下新业务增长放缓，企业降本增效、裁员风波频发，技术人</summary>
      
    
    
    
    <category term="技术成长" scheme="https://zhulg.github.io/categories/技术成长/"/>
    
    
    <category term="技术成长" scheme="https://zhulg.github.io/tags/技术成长/"/>
    
  </entry>
  
  <entry>
    <title>A Rust CLI-Based Chat Tool Utilizing the ChatGPT API</title>
    <link href="https://zhulg.github.io/posts/dca54e0f.html"/>
    <id>https://zhulg.github.io/posts/dca54e0f.html</id>
    <published>2023-03-15T00:08:07.000Z</published>
    <updated>2024-07-07T04:21:27.922Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ChatGPT-CLI"><a href="#ChatGPT-CLI" class="headerlink" title="ChatGPT CLI"></a>ChatGPT CLI</h1><ul><li>A tool for chatting using the ChatGPT API, written in Rust CLI.You can use this tool to chat, just by setting your API Key.</li><li>You can modify the API domain and other API parameters when you start the chat.</li><li>The source code will be shared in the article for reference.</li></ul><h2 id="Why-create-ChatGPT-CLI"><a href="#Why-create-ChatGPT-CLI" class="headerlink" title="Why create ChatGPT CLI"></a>Why create ChatGPT CLI</h2><ul><li><p><strong>If you can access the network through VPN, you can watch this video to learn more.</strong></p> <iframe width="560" height="315" src="https://www.youtube.com/embed/UXSgo9Ounuk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></li></ul><p> <strong>（若文中视频&amp;图片无法显示，请科学上网查看：<a href="https://order.yizhihongxing.network/aff.php?aff=12299" target="_blank" rel="noopener">推荐工具</a>）</strong></p><h2 id="Introduction-to-the-core-code"><a href="#Introduction-to-the-core-code" class="headerlink" title="Introduction to the core code"></a>Introduction to the core code</h2><ul><li><strong>首先构建命令行工具和信息：</strong>let matches = Command::new(“ChatGPT CLI”).使用 clap 库创建一个命令行工具，其中包含多个命令行参数（如 DomainName，APIKey 等）和一个命令行帮助信息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">let matches = Command::new(&quot;ChatGPT CLI&quot;)</span><br><span class="line">    .author(&quot;lg.json@gmail.com&quot;)</span><br><span class="line">    .version(&quot;1.0.0&quot;)</span><br><span class="line">    .about(</span><br><span class="line">        &quot;x\n</span><br><span class="line">                ChatGPT CLI Create by zhulg (lg.json@gmail.com)</span><br><span class="line">        | 1.You just need to input your api key, the cli version V0.1.1     |</span><br><span class="line">        | 2.No need access internet with VPN, and just enjoy it.            |</span><br><span class="line">        | 3.If you want to use it in China, you can use my api key.         |                                                   |</span><br><span class="line">        |-------------------------------------------------------------------|&quot;,</span><br><span class="line">    )</span><br><span class="line">    .arg(</span><br><span class="line">        Arg::new(&quot;DomainName&quot;)</span><br><span class="line">            .action(ArgAction::Set)</span><br><span class="line">            .short(&apos;d&apos;)</span><br><span class="line">            .long(&quot;Domain&quot;)</span><br><span class="line">            .default_value(&quot;api.openai.com&quot;)</span><br><span class="line">            .help(&quot;Sets the API Domain name.&quot;),</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><ul><li>支持自定义API域名和API密钥，支持从命令行参数或环境变量中设置密钥</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fn read_api_key() -&gt; String &#123;</span><br><span class="line">    // If the OPENAI_API_KEY environment variable is not set,</span><br><span class="line">    // ask the user to input the API key and save it to the</span><br><span class="line">    // environment variables for future use.</span><br><span class="line">    let api_key = env::var(&quot;OPENAI_API_KEY&quot;).unwrap_or_else(|_| &#123;</span><br><span class="line">        console::set_colors_enabled(true);</span><br><span class="line">        let prompt_style = Style::new().yellow();</span><br><span class="line">        let api_key: String = Input::new()</span><br><span class="line">            .with_prompt(prompt_style.apply_to(&quot;Input your API key&quot;).to_string())</span><br><span class="line">            .interact_text()</span><br><span class="line">            .unwrap();</span><br><span class="line">        env::set_var(&quot;OPENAI_API_KEY&quot;, &amp;api_key);</span><br><span class="line">        api_key</span><br><span class="line">    &#125;);</span><br><span class="line">    api_key</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过控制台输入一个消息并回车，该CLI会将该消息发送给OpenAI GPT-3.5-turbo模型，并显示该模型返回的响应消息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let response = client</span><br><span class="line">    .post(url)</span><br><span class="line">    .header(&quot;Content-Type&quot;, &quot;application/json&quot;)</span><br><span class="line">    .header(&quot;Authorization&quot;, format!(&quot;Bearer &#123;&#125;&quot;, api_key))</span><br><span class="line">    .json(&amp;json!(&#123;</span><br><span class="line">        &quot;model&quot;: &quot;gpt-3.5-turbo&quot;,</span><br><span class="line">        &quot;max_tokens&quot;: max_tokens.parse::&lt;i32&gt;().unwrap(),</span><br><span class="line">        &quot;temperature&quot;: 0.5 ,</span><br><span class="line">        &quot;messages&quot;: [&#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: line&#125;]</span><br><span class="line">    &#125;))</span><br><span class="line">    .send()</span><br><span class="line">    .await?</span><br><span class="line">    .json::&lt;Value&gt;()</span><br><span class="line">    .await?;</span><br></pre></td></tr></table></figure><h2 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h2><h3 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h3><ol><li><p>build code </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo build</span><br></pre></td></tr></table></figure></li><li><p>cd target/debug </p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./chatgpt_rust</span><br></pre></td></tr></table></figure><h3 id="Other-Install"><a href="#Other-Install" class="headerlink" title="Other Install"></a>Other Install</h3><ul><li><strong>If you have Rust installed, you can install the CLI using cargo:</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo install chatgpt_rust</span><br></pre></td></tr></table></figure><h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><ul><li><p>Linux/MacOS Run the following command in your terminal:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chatgpt_rust</span><br></pre></td></tr></table></figure></li><li><p><strong>（若文中图片无法显示，请科学上网查看：<a href="https://order.yizhihongxing.network/aff.php?aff=12299" target="_blank" rel="noopener">推荐工具</a>）</strong></p></li></ul><div align="center" width="100%">  <img width="80%" src="https://raw.githubusercontent.com/zhulg/allpic/master/chatgpt_cli.png"></div><ul><li>chatgpt_rust –help </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">                    ChatGPT CLI Create by zhulg (lg.json@gmail.com)</span><br><span class="line">            | 1.You just need to input your api key, the cli version    |</span><br><span class="line">            | 2.No need access internet with VPN, and just enjoy it.    |</span><br><span class="line">            | 3.If you want to use it in China, you can use my api key. |</span><br><span class="line">            | --------------------------------------------------------- |</span><br><span class="line"></span><br><span class="line">Usage: chatgpt_rust [OPTIONS]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -d, --Domain &lt;DomainName&gt;  Sets the API Domain name. [default: api.openai.com]</span><br><span class="line">  -k, --key &lt;APIKey&gt;         Sets the API key. If not provided, the cli will ask for it,</span><br><span class="line">                             You can also set the OPENAI_API_KEY environment variable. [default: ]</span><br><span class="line">  -t, --tokens &lt;max_tokens&gt;  sets the max_tokens, default is 1000 [default: 1000]</span><br><span class="line">  -h, --help                 Print help</span><br><span class="line">  -V, --version              Print version</span><br></pre></td></tr></table></figure><h2 id="Option"><a href="#Option" class="headerlink" title="Option:"></a>Option:</h2><p> Set your ‘OPENAI_API_KEY’ Environment Variable using zsh,  No set will ask the user to input the API key in the terminal.</p><ol><li>Run the following command in your terminal, replacing yourkey with your API key. </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;export OPENAI_API_KEY=&apos;yourkey&apos;&quot; &gt;&gt; ~/.zshrc</span><br></pre></td></tr></table></figure><ol start="2"><li>Update the shell with the new variable:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure><ol start="3"><li>Confirm that you have set your environment variable using the following command. </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $OPENAI_API_KEY</span><br></pre></td></tr></table></figure><p>The value of your API key will be the resulting output.</p><h2 id="Source-code"><a href="#Source-code" class="headerlink" title="Source code"></a>Source code</h2><p><a href="https://github.com/zhulg/ChatGPT_CLI_Rust" target="_blank" rel="noopener">SourceCode</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ChatGPT-CLI&quot;&gt;&lt;a href=&quot;#ChatGPT-CLI&quot; class=&quot;headerlink&quot; title=&quot;ChatGPT CLI&quot;&gt;&lt;/a&gt;ChatGPT CLI&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;A tool for chatting using th</summary>
      
    
    
    
    <category term="ChatGPT" scheme="https://zhulg.github.io/categories/ChatGPT/"/>
    
    
    <category term="ChatGPT" scheme="https://zhulg.github.io/tags/ChatGPT/"/>
    
  </entry>
  
  <entry>
    <title>ChatGPT API介绍及使用</title>
    <link href="https://zhulg.github.io/posts/c22af37b.html"/>
    <id>https://zhulg.github.io/posts/c22af37b.html</id>
    <published>2023-03-09T23:44:59.000Z</published>
    <updated>2024-07-07T04:21:27.923Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ChatGPT-API介绍和使用"><a href="#ChatGPT-API介绍和使用" class="headerlink" title="ChatGPT API介绍和使用"></a>ChatGPT API介绍和使用</h2><ul><li>ChatGPT API的发布，可以让大家快速使用，不仅可以搭建类似ChatGPT应用，还可以通过API制作自己的应用、接入自己的产品、快速拥有强大的AI能力。</li><li>本文介绍ChatGPT API如何使用、API key的创建，请求花费、定价规则、运行官方起名应用快速入门ChatGPT API 的使用。</li></ul><h3 id="ChatGPT-API-介绍"><a href="#ChatGPT-API-介绍" class="headerlink" title="ChatGPT API 介绍"></a>ChatGPT API 介绍</h3><ul><li><strong>先看下张图：</strong>从这图上官方正式介绍，可以使用API方式接入ChatGPT到自己的应用里了，这不仅仅对开发者，更多对不懂开发的人也可以通过自然语言及指令接入自己应用中。<br><strong>（若文中图片无法显示，请科学上网查看：<a href="https://order.yizhihongxing.network/aff.php?aff=12299" target="_blank" rel="noopener">推荐工具</a>）</strong></li></ul><div align="center" width="100%">  <img width="80%" src="https://raw.githubusercontent.com/zhulg/allpic/master/chatgptapi_1.png"></div><ul><li><strong>API更新介绍：</strong><br>这里说到gpt-3.5-turbo是ChatGPT产品中使用的相同模型，但其价格为每1k tokens为0.002美元，相当于每100万token只需要2美元。 比我们现有的GPT-3.5模型便宜10倍，这是3月1号最新官网介绍。</li></ul><div align="center" width="100%">  <img width="80%" src="https://raw.githubusercontent.com/zhulg/allpic/master/chatgptapi_2.png"></div><h3 id="Tokens是什么"><a href="#Tokens是什么" class="headerlink" title="Tokens是什么"></a>Tokens是什么</h3><ul><li><p><strong>API计费单位</strong>。</p></li><li><p><strong>一次提问怎么计费 : 问题tokens + 答案tokens</strong></p></li><li><p>具体来讲，在模型里它指系统将句子和单词分解成的文本块，以便预测接下来应该输出什么文本。根据 OpenAI 官方文档显示，“ChatGPT is great!”这组单词需要六个 token，它的 API 将其分解为“Chat”、“G”、“PT”、“is”、“great”和“!”。与此同时，OpenAI 还专门提供了一个用于检查解释一串文本需要多少 token 的工具，并表示，按照一般的经验来看，在英语中“一个 token 通常对应大约 4 个字符”</p><div align="center" width="100%"><img width="80%" src="https://raw.githubusercontent.com/zhulg/allpic/master/tokeninfo.png"></div></li><li><p><strong>1000个tokens大概750个单词</strong></p></li></ul><div align="center" width="100%">  <img width="80%" src="https://raw.githubusercontent.com/zhulg/allpic/master/models.png"></div><h3 id="如何预估tokens"><a href="#如何预估tokens" class="headerlink" title="如何预估tokens:"></a>如何预估tokens:</h3><ul><li>提供了技术tokens的方法，可以参考理解tokens的计算：</li></ul><div align="center" width="100%">  <img width="80%" src="https://raw.githubusercontent.com/zhulg/allpic/master/tokens.png"></div><h2 id="创建账号和API-Key"><a href="#创建账号和API-Key" class="headerlink" title="创建账号和API Key"></a>创建账号和API Key</h2><ul><li>第一步我们需要登录openAI并注册账号，没有的需要先进行注册 (如果国内无法注册，可以看下方邮件地址邮件我）注册的账号里会先送有18美元，可以对基本的API测试和使用足够了。</li><li>第二步，通过账号登录后进行API key的创建，可以通过个人中心 View API keys来创建，点击创建即可。也可以通过QuickStart里的demo一步步创建。都是可以的，创建好要记得保存下来，后边将不会全部显示了，如果忘记需要移除再次创建。<div align="center" width="100%"><img width="80%" src="https://raw.githubusercontent.com/zhulg/allpic/master/keycreate.png"></div></li></ul><h2 id="使用API"><a href="#使用API" class="headerlink" title="使用API"></a>使用API</h2><ul><li>为了快速演示，使用curl来进行访问接口。 国内的朋友一定要记得科学上网，这个接口否则无法访问（代理一定要设置好，否则接口是无法访问的），我这里验证了后对API返回的数据也进行各说明，如图，返回的接口里有API给的信息和这次请求的花费。</li></ul><div align="center" width="100%">  <img width="80%" src="https://raw.githubusercontent.com/zhulg/allpic/master/api.png"></div><ul><li>返回的数据包括了此次请求花费显示：</li></ul><div align="center" width="100%">  <img width="80%" src="https://raw.githubusercontent.com/zhulg/allpic/master/apidata.png"></div><ul><li>官方也提供了其他语言的SDK，你都可以快速接入。<div align="center" width="100%"><img width="80%" src="https://raw.githubusercontent.com/zhulg/allpic/master/othersdk.png"></div></li></ul><h2 id="应用演示"><a href="#应用演示" class="headerlink" title="应用演示"></a>应用演示</h2><ul><li>运行官方的例子，可以通过代码和页面来查看具体API的使用方法。可以使用node来进行运行起来，并查看具体的代码, 运行后如图：<div align="center" width="100%"><img width="80%" src="https://raw.githubusercontent.com/zhulg/allpic/master/pet.png"></div></li><li>这个demo 通过npm install 之后可以快速启动起来。官方也提供了其他产品接入的演示。希望给大家带来更多整合应用的灵感。</li><li>这个demo的运行需要注意，一个是node的版本不要太低18之后最好，其次访问时还是要科学上网。（有任何代理和账号注册问题都可以邮件我）</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ChatGPT-API介绍和使用&quot;&gt;&lt;a href=&quot;#ChatGPT-API介绍和使用&quot; class=&quot;headerlink&quot; title=&quot;ChatGPT API介绍和使用&quot;&gt;&lt;/a&gt;ChatGPT API介绍和使用&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;ChatGPT </summary>
      
    
    
    
    <category term="ChatGPT" scheme="https://zhulg.github.io/categories/ChatGPT/"/>
    
    
    <category term="ChatGPT" scheme="https://zhulg.github.io/tags/ChatGPT/"/>
    
  </entry>
  
  <entry>
    <title>Damus Android版APK下载包Amethyst</title>
    <link href="https://zhulg.github.io/posts/f235cc57.html"/>
    <id>https://zhulg.github.io/posts/f235cc57.html</id>
    <published>2023-02-03T03:32:01.000Z</published>
    <updated>2024-07-07T04:21:27.923Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Damus是一个建立在去中心化网络上的社交软件，目前iOS可以通过appstore直接下载使用。</li><li><strong>Android版是需要通过googleplay下载Amethyst，国内Android手机由于周知原因，无法直接安装，特提供安装包供大家下载安装</strong>。</li></ul><h3 id="Amethyst安装包下载："><a href="#Amethyst安装包下载：" class="headerlink" title="Amethyst安装包下载："></a>Amethyst安装包下载：</h3><ul><li>点击下载获取该Android版本安装包：<a href="https://raw.githubusercontent.com/zhulg/allpic/master/Amethyst_0.11.5.apk" target="_blank" rel="noopener">Amethyst 安装包点击下载</a>  pc上直接点击下载，手机上通过浏览器打开再点击。</li><li>下载安装到Androids手机即可，如有问题可邮件(<a href="mailto:lg.json@gmail.com" target="_blank" rel="noopener">lg.json@gmail.com</a>) 单独再提供安装包</li></ul><div align="center" width="100%">  <img width="80%" src="https://raw.githubusercontent.com/zhulg/allpic/master/googleplay.png"></div><ul><li><strong>（若文中图片无法显示，请科学上网查看：<a href="https://order.yizhihongxing.network/aff.php?aff=12299" target="_blank" rel="noopener">推荐工具</a>）</strong></li></ul><h3 id="安装后登陆："><a href="#安装后登陆：" class="headerlink" title="安装后登陆："></a>安装后登陆：</h3><ul><li>进入后，先创建公钥，如图所示进入后在登录页面，选择创建进入即可，会自动生成对应的私钥。</li></ul><div align="center" width="100%">  <img width="70%" src="https://raw.githubusercontent.com/zhulg/allpic/master/d_user_create.png"></div><h3 id="私钥获取："><a href="#私钥获取：" class="headerlink" title="私钥获取："></a>私钥获取：</h3><ul><li>第一次创建后，点击左上角头像»Profile »长按***复制私钥。</li><li>自动复制到剪贴板（目前没任何提示）粘贴后可查看，请安全保存后边用于登录账号。<div align="center" width="100%"><img width="70%" src="https://raw.githubusercontent.com/zhulg/allpic/master/d_user_getkey.png"></div></li></ul><h3 id="私钥登录："><a href="#私钥登录：" class="headerlink" title="私钥登录："></a>私钥登录：</h3><ul><li>保存好的私钥后，<strong>选择登出APP后，通过私钥再次登陆</strong>，这样就可以使用了。</li><li>个人中心有公钥显示，可以选择分享，分享给他人进行关注（朋友圈那一串串的符合）</li><li><strong>私钥用来登录自己的账号，保存好！！</strong></li></ul><h3 id="其他："><a href="#其他：" class="headerlink" title="其他："></a>其他：</h3><ul><li>到这一步可以查看了正常使用了，可以搜索关注我 <strong>npub1z40ckftt5tq70uqvtng4jz6lv34am6k85vkzlrgfzqs22rkrqjyqkga4cj</strong></li><li>后边头像更换、发贴添加节点闪电网络等，<strong>进去后自己玩即可有问题可以邮件私信</strong>。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;Damus是一个建立在去中心化网络上的社交软件，目前iOS可以通过appstore直接下载使用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Android版是需要通过googleplay下载Amethyst，国内Android手机由于周知原因，无法直接安装，特提供安装包</summary>
      
    
    
    
    <category term="区块链" scheme="https://zhulg.github.io/categories/区块链/"/>
    
    
    <category term="Android" scheme="https://zhulg.github.io/tags/Android/"/>
    
    <category term="区块链" scheme="https://zhulg.github.io/tags/区块链/"/>
    
  </entry>
  
  <entry>
    <title>Rust CLI反编译Android APK</title>
    <link href="https://zhulg.github.io/posts/b176cd6e.html"/>
    <id>https://zhulg.github.io/posts/b176cd6e.html</id>
    <published>2022-11-06T03:26:52.000Z</published>
    <updated>2024-07-07T04:21:27.925Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Rust-CLI使用"><a href="#Rust-CLI使用" class="headerlink" title="Rust-CLI使用"></a>Rust-CLI使用</h2><ul><li>Rust提供了比较好的CLI接口,可以快速的编写CLI应用, 用于日常的工具类使用</li><li>Android 反编译APK的过程，可以通过Rust来整合成命令行一步完成, 整合其中出来过程, 来应用Rust CLI的实践</li><li><strong>目的熟悉Rust CLI来编写应用，并通过命令行自动化反编译APK几个过程，作为日常工具提效</strong></li></ul><h2 id="编写准备："><a href="#编写准备：" class="headerlink" title="编写准备："></a>编写准备：</h2><ul><li><strong>反编译APK依赖的必要库：</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d2j-dex2jar</span><br><span class="line">jd-cli</span><br><span class="line">Apktool</span><br></pre></td></tr></table></figure><p>应用该库使用为最新版本，如果有不支持兼容的需要确认Java使用的相关版本即可。</p><ul><li><strong>Rust CLI 编写依赖的库：</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">clap </span><br><span class="line">console</span><br><span class="line">execute </span><br><span class="line">indicatif</span><br><span class="line">text2art</span><br></pre></td></tr></table></figure><p>这些库的使用方式和说明可在<a href="https://crates.io/" target="_blank" rel="noopener">crates.io</a>查到说明</p><h2 id="代码解析："><a href="#代码解析：" class="headerlink" title="代码解析："></a>代码解析：</h2><ul><li><strong>编写CLI处理接口：</strong></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> matches = Command::new(<span class="string">"Decompile APK"</span>)</span><br><span class="line">    .author(<span class="string">"lg.json@gmail.com"</span>)</span><br><span class="line">    .version(<span class="string">"1.0.0"</span>)</span><br><span class="line">    .about(<span class="string">"ApkDecompiler for Android, create by Spark Coding BU"</span>)</span><br><span class="line">    .arg(</span><br><span class="line">        Arg::new(<span class="string">"file"</span>)</span><br><span class="line">            .action(ArgAction::Set)</span><br><span class="line">            .short(<span class="string">'f'</span>)</span><br><span class="line">            .long(<span class="string">"file"</span>)</span><br><span class="line">            .default_value(<span class="string">"-"</span>)</span><br><span class="line">            .help(<span class="string">"The path to your apk."</span>),</span><br><span class="line">    )</span><br><span class="line">    .after_help(</span><br><span class="line">        <span class="string">"Longer explanation to appear after the options when \</span></span><br><span class="line"><span class="string">              displaying the help information from --help or -h"</span>,</span><br><span class="line">    )</span><br><span class="line">    .get_matches();</span><br></pre></td></tr></table></figure><ul><li><p>Command使用的是clap来创建， 通过Arg创建对应的参数和应用，可以创建读个arg进行添加。</p></li><li><p><strong>读取CLI的输入参数：</strong></p></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> file_path = <span class="keyword">match</span> matches.get_one::&lt;<span class="built_in">String</span>&gt;(<span class="string">"file"</span>) &#123;</span><br><span class="line">      <span class="literal">Some</span>(it) =&gt; it,</span><br><span class="line">      _ =&gt; <span class="keyword">return</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">let</span> apk_path = PathBuf::from(file_path);</span><br></pre></td></tr></table></figure><ul><li><strong>开始执行:</strong></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">start_decompile</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">self</span>.show_tools_info()?;</span><br><span class="line">    <span class="keyword">self</span>.create_output_dir()?;</span><br><span class="line">    <span class="keyword">self</span>.start_dex2jar()?;</span><br><span class="line">    <span class="keyword">self</span>.start_decompile_class()?;</span><br><span class="line">    <span class="keyword">self</span>.start_decompile_res()?;</span><br><span class="line">    <span class="keyword">self</span>.open_output()?;\</span><br><span class="line">    <span class="literal">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开始执行会显示工具对应的信息，创建文件输出的地址，开始解析对应的包</p><ul><li><strong>举例命令行的创建：</strong></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///use dex2jar get APK's jar in output_path</span></span><br><span class="line"> <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">start_dex2jar</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">Result</span>&lt;()&gt; &#123;</span><br><span class="line">     <span class="keyword">let</span> <span class="keyword">mut</span> command = Command::new(<span class="string">"sh"</span>);</span><br><span class="line"></span><br><span class="line">     command</span><br><span class="line">         .arg(<span class="keyword">self</span>.exe_dir.join(<span class="string">"lib/dex2jar/d2j-dex2jar.sh"</span>))</span><br><span class="line">         .arg(<span class="string">"-f"</span>)</span><br><span class="line">         .arg(&amp;<span class="keyword">self</span>.apk_path)</span><br><span class="line">         .arg(<span class="string">"-o"</span>)</span><br><span class="line">         .arg(<span class="keyword">self</span>.output_path.join(<span class="string">"app.jar"</span>));</span><br><span class="line"></span><br><span class="line">     execute_state(command, <span class="string">"dex2jar"</span>);</span><br><span class="line">     <span class="literal">Ok</span>(())</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li><strong>工程注意点：</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.使用build.rs在构建前需要把代码依赖的lib库拷到对应的target下，这里使用了构建脚本, 具体参见代码工程</span><br><span class="line">2.如何使用cli的执行状态，来显示处理过程, 是CLI下常用的工具</span><br></pre></td></tr></table></figure><ul><li>最终工具处理效果： <strong>（文中图片无法显示，请科学上网查看：<a href="https://order.yizhihongxing.network/aff.php?aff=12299" target="_blank" rel="noopener">推荐工具</a>）</strong><div align="center" width="100%"><img width="950%" src="https://raw.githubusercontent.com/zhulg/allpic/master/decompilerapk.gif"></div></li></ul><h2 id="源码地址："><a href="#源码地址：" class="headerlink" title="源码地址："></a>源码地址：</h2><ul><li>源码 <a href="https://github.com/zhulg/RustDecompileApk" target="_blank" rel="noopener">Github地址</a></li><li>使用方式：./apkdecompiler -f ./test.apk</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  _____                      _        _____                                        _  _</span><br><span class="line"> / ____|                    | |      |  __ \                                      (_)| |</span><br><span class="line">| (___   _ __    __ _  _ __ | | __   | |  | |  ___   ___   ___   _ __ ___   _ __   _ | |  ___  _ __</span><br><span class="line"> \___ \ | &apos;_ \  / _` || &apos;__|| |/ /   | |  | | / _ \ / __| / _ \ | &apos;_ ` _ \ | &apos;_ \ | || | / _ \| &apos;__|</span><br><span class="line"> ____) || |_) || (_| || |   |   &lt;    | |__| ||  __/| (__ | (_) || | | | | || |_) || || ||  __/| |</span><br><span class="line">|_____/ | .__/  \__,_||_|   |_|\_\   |_____/  \___| \___| \___/ |_| |_| |_|| .__/ |_||_| \___||_|</span><br><span class="line">        | |                                                                | |</span><br><span class="line">        |_|                                                                |_|</span><br><span class="line">begin del old file...in /Users/developer/apkdecompiler/output</span><br><span class="line">✅ create ouput:/Users/developer/apkdecompiler/output</span><br><span class="line">✅ dex2jar...done</span><br><span class="line">✅ decompile class...done</span><br><span class="line">✅ decompile Resource...done</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Rust-CLI使用&quot;&gt;&lt;a href=&quot;#Rust-CLI使用&quot; class=&quot;headerlink&quot; title=&quot;Rust-CLI使用&quot;&gt;&lt;/a&gt;Rust-CLI使用&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Rust提供了比较好的CLI接口,可以快速的编写CLI应用, 用</summary>
      
    
    
    
    <category term="Rust" scheme="https://zhulg.github.io/categories/Rust/"/>
    
    
    <category term="Rust" scheme="https://zhulg.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>iOS集成Rust使用</title>
    <link href="https://zhulg.github.io/posts/e04cad1e.html"/>
    <id>https://zhulg.github.io/posts/e04cad1e.html</id>
    <published>2022-10-23T01:37:06.000Z</published>
    <updated>2024-07-07T04:21:27.929Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iOS调用Rust"><a href="#iOS调用Rust" class="headerlink" title="iOS调用Rust"></a>iOS调用Rust</h1><h2 id="一，开发环境："><a href="#一，开发环境：" class="headerlink" title="一，开发环境："></a>一，开发环境：</h2><ul><li>确保xcode开发环境，推荐官方文档, 安装即可</li><li>rust开发环境</li><li>xcode及iOS调试设备</li><li>末尾附带demo工程源码，供初学者集成原理学习使用（简单步骤有省略，有疑问可邮件我）</li></ul><h2 id="二，添加rust交叉编译"><a href="#二，添加rust交叉编译" class="headerlink" title="二，添加rust交叉编译"></a>二，添加rust交叉编译</h2><ul><li>同android一样，可以添加支持ios的编译</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rustup target add aarch64-apple-ios x86_64-apple-ios</span><br></pre></td></tr></table></figure><ul><li>初始化 cargo-lipo : 这个create可以编译rs为iOS需要的库</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo install cargo-lipo</span><br></pre></td></tr></table></figure><h2 id="三，创建工程"><a href="#三，创建工程" class="headerlink" title="三，创建工程"></a>三，创建工程</h2><ul><li>这里的rs代码直接 <strong>(参考了mozilla的例子，只为测试验证集成过程）</strong></li><li>创建iOS基本工程，并创建rust的库工程，可以创建lib，也可以直接rs工程。 <strong>（一套rust代码，提供多个平台，那一般可以创建lib库，这样rust工程来调试后，统一对外提供lib库代码，由lib库代码编译对应的so,或者.a文件)</strong></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo new Rust_iOS --lib</span><br></pre></td></tr></table></figure><ul><li>这里使用 Rust_iOS 作为为iOS工程提供的rust 库代码，通过 cargo-lipo 编译出.a的库文件，为ios工程进行调用。</li></ul><h3 id="rust代码添加"><a href="#rust代码添加" class="headerlink" title="rust代码添加"></a>rust代码添加</h3><ul><li><ol><li><strong>在lib.rs里添加下边代码</strong></li></ol></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ffi::&#123;CStr, CString&#125;;</span><br><span class="line"><span class="keyword">use</span> std::os::raw::c_char;</span><br><span class="line"></span><br><span class="line"><span class="comment">//#[no_mangle] 告诉编译器不要破坏函数名，确保函数名称被导入到 C 文件</span></span><br><span class="line"><span class="comment">//extern 告诉 Rust 编译器方法将要在 Rust 以外的地方调用，要确保其按照 C 的调用规则编译。</span></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">fn</span> <span class="title">rust_greeting</span></span>(to: *<span class="keyword">const</span> c_char) -&gt; *<span class="keyword">mut</span> c_char &#123;</span><br><span class="line">    <span class="keyword">let</span> c_str = <span class="keyword">unsafe</span> &#123; CStr::from_ptr(to) &#125;;</span><br><span class="line">    <span class="keyword">let</span> recipient = <span class="keyword">match</span> c_str.to_str() &#123;</span><br><span class="line">        <span class="literal">Err</span>(_) =&gt; <span class="string">"there"</span>,</span><br><span class="line">        <span class="literal">Ok</span>(string) =&gt; string,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    CString::new(<span class="string">"Hello "</span>.to_owned() + recipient)</span><br><span class="line">        .unwrap()</span><br><span class="line">        .into_raw()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">fn</span> <span class="title">rust_greeting_free</span></span>(s: *<span class="keyword">mut</span> c_char) &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> s.is_null() &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        CString::from_raw(s)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><ol start="2"><li><strong>greetings.h ：</strong>src下添加一个名为 greetings.h 的新文件，来定义一下 C 接口，iOS调用的Rust函数在这里定义</li></ol></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">char</span>* rust_greeting(<span class="keyword">const</span> <span class="built_in">char</span>* to);</span><br><span class="line">void rust_greeting_free(<span class="built_in">char</span> *);</span><br></pre></td></tr></table></figure><ul><li><ol start="3"><li><strong>Cargo.toml定义编译类型：</strong><br>staticlib 编译会生成 .a 文件（在 Linux 和 MacOS 上），或 .lib 文件（在 Windows 上）。</li></ol></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[lib]</span><br><span class="line">name = &quot;greetings&quot;</span><br><span class="line">crate-type = [&quot;staticlib&quot;, &quot;cdylib&quot;]</span><br></pre></td></tr></table></figure><ul><li><ol start="4"><li><strong>编译成静态库:</strong></li></ol></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo lipo --release</span><br></pre></td></tr></table></figure><p>构建产物位置在 target/下，通用 iOS 库的位置在  /target/universal/release/libRust_iOS.a</p><h2 id="四，iOS工程引入Rust库："><a href="#四，iOS工程引入Rust库：" class="headerlink" title="四，iOS工程引入Rust库："></a>四，iOS工程引入Rust库：</h2><h3 id="导入-libRust-iOS-a-库"><a href="#导入-libRust-iOS-a-库" class="headerlink" title="导入 libRust_iOS.a 库:"></a>导入 libRust_iOS.a 库:</h3><ul><li>创建demo ios 工程, <strong>导入 libRust_iOS.a 库</strong>（从rust工程找到，直接拖进入工程target下general）</li><li>链接 libresolv.tbd。 点击 Linked Frameworks 列表底部的 + 并在搜索框中键入 libresolv。 选择 libresolv.tbd</li></ul><h3 id="bridging-header创建："><a href="#bridging-header创建：" class="headerlink" title="bridging header创建："></a>bridging header创建：</h3><ul><li><p>创建之前先把之前定义在rust工程里的.h文件引入过来，这个.h文件是rust代码调用的声明入口(File\Add files to“iOSIntegratingRust” )</p></li><li><p><strong>创建bridging header：</strong> File\New\File..。 从提供的选项中选择 iOS Source Header File 并选择 Next。 将文件命名为 Greetings-Bridging-Header.h 并选择 Create</p></li><li><p>引入greetings.h</p></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#ifndef Greetings_Bridging_Header_h</span><br><span class="line">#define Greetings_Bridging_Header_h</span><br><span class="line">#import <span class="string">"greetings.h"</span></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h3 id="iOS-Build-Settings"><a href="#iOS-Build-Settings" class="headerlink" title="iOS Build Settings:"></a>iOS Build Settings:</h3><ul><li><strong>设置Objective-C Bridging Header链接要的.h文件</strong>， 工程 target 里打开 Build Settings 选项卡。 将 Objective-C Bridging Header设置为$(PROJECT_DIR)/Greetings-Bridging-Header.h （要看自己.h所在的位置）</li><li><strong>设置 Xcode 要链接 Rust 库的路径</strong>，  Build Settings 中 Library Search Paths中设置 $(PROJECT_DIR)/../Rust_iOS/target/universal/release (要看自己库实际位置)</li></ul><h2 id="五，iOS代码调用："><a href="#五，iOS代码调用：" class="headerlink" title="五，iOS代码调用："></a>五，iOS代码调用：</h2><ul><li>从刚demo工程里新建一个 swift 文件，命名为 RustGreetings</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RustGreetings</span> &#123;</span></span><br><span class="line">    func sayHello(to: String) -&gt; String &#123;</span><br><span class="line">        let result = rust_greeting(to)</span><br><span class="line">        let swift_result = String(cString: result!)</span><br><span class="line">        rust_greeting_free(UnsafeMutablePointer(mutating: result))</span><br><span class="line">        <span class="keyword">return</span> swift_result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ViewController.swift里 添加代码验证调用</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">override</span> func <span class="title">viewDidLoad</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    super.viewDidLoad()</span><br><span class="line">    <span class="comment">// Do any additional setup after loading the view.</span></span><br><span class="line">    let rustGreetings = RustGreetings()</span><br><span class="line">    print(<span class="string">"\(rustGreetings.sayHello(to: "</span>world<span class="string">"))"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>例子只验证rust调用使用的过程 <a href="https://github.com/zhulg/iOSUseRust" target="_blank" rel="noopener">源码下载</a> ，有问题邮件我<a href="mailto:lg.json@gmail.com" target="_blank" rel="noopener">lg.json@gmail.com</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;iOS调用Rust&quot;&gt;&lt;a href=&quot;#iOS调用Rust&quot; class=&quot;headerlink&quot; title=&quot;iOS调用Rust&quot;&gt;&lt;/a&gt;iOS调用Rust&lt;/h1&gt;&lt;h2 id=&quot;一，开发环境：&quot;&gt;&lt;a href=&quot;#一，开发环境：&quot; class=&quot;he</summary>
      
    
    
    
    <category term="Rust" scheme="https://zhulg.github.io/categories/Rust/"/>
    
    
    <category term="Rust" scheme="https://zhulg.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Android集成Rust使用</title>
    <link href="https://zhulg.github.io/posts/fc64e719.html"/>
    <id>https://zhulg.github.io/posts/fc64e719.html</id>
    <published>2022-10-19T14:47:19.000Z</published>
    <updated>2024-07-07T04:21:27.923Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Andorid调用Rust"><a href="#Andorid调用Rust" class="headerlink" title="Andorid调用Rust"></a>Andorid调用Rust</h1><ul><li>目前rust在移动端上的应用，一般作为应用sdk的提供，供各端使用，目前飞书底层使用Rust编写通用组件。</li><li>末尾附带该使用Rust工程源码，供初学者集成原理学习使用（简单步骤有省略，有疑问可邮件我）</li></ul><h2 id="一，开发环境："><a href="#一，开发环境：" class="headerlink" title="一，开发环境："></a>一，开发环境：</h2><ul><li>确保rust开发环境，推荐官方文档, 安装即可</li><li>Android相关开发环境，需要NDK的下载安装</li><li>环境变量的配置，为命令行使用提供全局环境</li></ul><h3 id="开发工具："><a href="#开发工具：" class="headerlink" title="开发工具："></a>开发工具：</h3><ul><li><ol><li>如果对android studio比较熟悉，可安装rust插件 <strong>（若文中图片无法显示，请科学上网查看：<a href="https://order.yizhihongxing.network/aff.php?aff=12299" target="_blank" rel="noopener">推荐工具</a>）</strong></li></ol></li></ul><div align="center" width="100%">  <img width="80%" src="https://github.com/zhulg/allpic/blob/master/vs_rust.png?raw=true"></div>安装完毕，对Rust Toolchain 位置进行配置确认，否则可能对rs文件无法识别，就无法愉快使用studio编写rust<ul><li><ol start="2"><li><strong>VScode: 推荐使用编写rust代码。</strong></li></ol></li></ul><h2 id="二，创建Android工程"><a href="#二，创建Android工程" class="headerlink" title="二，创建Android工程:"></a>二，创建Android工程:</h2><ul><li>与普通Android工程创建一样，创建Empty Activity</li><li>先编译通过该空工程</li></ul><h2 id="三，添加rust-lib库："><a href="#三，添加rust-lib库：" class="headerlink" title="三，添加rust lib库："></a>三，添加rust lib库：</h2><ul><li>进入到刚创建的AndroidIntegratingRust工程下</li></ul><h3 id="使用rust-Cargo创建-lib库："><a href="#使用rust-Cargo创建-lib库：" class="headerlink" title="使用rust Cargo创建 lib库："></a>使用rust Cargo创建 lib库：</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cargo new rust_lib --lib</span><br></pre></td></tr></table></figure><ul><li>创建成功后会有rust_lib库，结构如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">├── app</span><br><span class="line">│   ├── build</span><br><span class="line">│   ├── build.gradle</span><br><span class="line">│   ├── libs</span><br><span class="line">│   ├── proguard-rules.pro</span><br><span class="line">│   └── src</span><br><span class="line">├── build</span><br><span class="line">│   └── kotlin</span><br><span class="line">├── build.gradle</span><br><span class="line">├── gradle</span><br><span class="line">│   └── wrapper</span><br><span class="line">├── gradle.properties</span><br><span class="line">├── gradlew</span><br><span class="line">├── gradlew.bat</span><br><span class="line">├── local.properties</span><br><span class="line">├── rust_lib //位置在这</span><br><span class="line">│   ├── Cargo.lock</span><br><span class="line">│   ├── Cargo.toml</span><br><span class="line">│   ├── src</span><br><span class="line">│   └── target</span><br><span class="line">└── settings.gradle</span><br></pre></td></tr></table></figure><h3 id="编辑Cargo-toml"><a href="#编辑Cargo-toml" class="headerlink" title="编辑Cargo.toml"></a>编辑Cargo.toml</h3><ul><li>输入目前需要的jni库依赖, <a href="https://crates.io/" target="_blank" rel="noopener">https://crates.io/</a>地址下确认版本, create-type 填写cdylib 动态链接库</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[lib]</span><br><span class="line">name = <span class="string">"rust_lib"</span></span><br><span class="line">crate-type = ["cdylib"]</span><br><span class="line"></span><br><span class="line">[dependencies]</span><br><span class="line">jni = <span class="string">"0.20.0"</span></span><br></pre></td></tr></table></figure><h3 id="配置要编译so的linker及target"><a href="#配置要编译so的linker及target" class="headerlink" title="配置要编译so的linker及target"></a>配置要编译so的linker及target</h3><ul><li><strong>这个在rust_lib下创建.cargo目录，添加config.toml配置文件</strong></li><li>填入linker对应的ndk地址：</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[target.aarch64-linux-android]</span><br><span class="line">linker = <span class="string">"/Users/android-sdk-macosx/ndk-bundle/toolchains/llvm/prebuilt/darwin-x86_64/bin/aarch64-linux-android21-clang++"</span></span><br><span class="line"></span><br><span class="line">[target.armv7-linux-androideabi]</span><br><span class="line">linker = <span class="string">"/Users/android-sdk-macosx/ndk-bundle/toolchains/llvm/prebuilt/darwin-x86_64/bin/armv7a-linux-androideabi21-clang++"</span></span><br></pre></td></tr></table></figure><p> ps: 这是我的mac上ndk所在位置，参考Android官方ndk文档。</p><ul><li>准备编译rust代码为so的环境已经准备完</li></ul><h2 id="四，开始编写Android和Rust代码："><a href="#四，开始编写Android和Rust代码：" class="headerlink" title="四，开始编写Android和Rust代码："></a>四，开始编写Android和Rust代码：</h2><ul><li><p>创建Android代码, RustGreetings类， 使用kotlin所以用external声明JNI函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class RustGreetings &#123;</span><br><span class="line">    fun sayHello(to: String): String &#123;</span><br><span class="line">        return greeting(to)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    companion object &#123;</span><br><span class="line">        @JvmStatic external fun greeting(pattern: String): String</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在Rust lib库下，编写对应的JNI函数映射，从create.io下可以看到有关JNI的使用，代码如下</p></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> jni::JNIEnv;</span><br><span class="line"></span><br><span class="line"><span class="comment">// These objects are what you should use as arguments to your native</span></span><br><span class="line"><span class="comment">// function. They carry extra lifetime information to prevent them escaping</span></span><br><span class="line"><span class="comment">// this context and getting used after being GC'd.</span></span><br><span class="line"><span class="keyword">use</span> jni::objects::&#123;JClass, JString&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This is just a pointer. We'll be returning it from our function. We</span></span><br><span class="line"><span class="comment">// can't return one of the objects with lifetime information because the</span></span><br><span class="line"><span class="comment">// lifetime checker won't let us.</span></span><br><span class="line"><span class="keyword">use</span> jni::sys::jstring;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This keeps Rust from "mangling" the name and making it unique for this</span></span><br><span class="line"><span class="comment">// crate.</span></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">"system"</span> <span class="function"><span class="keyword">fn</span> <span class="title">Java_com_android_integratingrust_RustGreetings_greeting</span></span>(</span><br><span class="line">    env: JNIEnv,</span><br><span class="line">    <span class="comment">// This is the class that owns our static method. It's not going to be used,</span></span><br><span class="line">    <span class="comment">// but still must be present to match the expected signature of a static</span></span><br><span class="line">    <span class="comment">// native method.</span></span><br><span class="line">    class: JClass,</span><br><span class="line">    input: JString,</span><br><span class="line">) -&gt; jstring &#123;</span><br><span class="line">    <span class="comment">// First, we have to get the string out of Java. Check out the `strings`</span></span><br><span class="line">    <span class="comment">// module for more info on how this works.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> input: <span class="built_in">String</span> = env</span><br><span class="line">        .get_string(input)</span><br><span class="line">        .expect(<span class="string">"Couldn't get java string!"</span>)</span><br><span class="line">        .into();</span><br><span class="line"></span><br><span class="line">    input = append_string(&amp;input);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Then we have to create a new Java string to return. Again, more info</span></span><br><span class="line">    <span class="comment">// in the `strings` module.</span></span><br><span class="line">    <span class="keyword">let</span> output = env</span><br><span class="line">        .new_string(<span class="built_in">format!</span>(<span class="string">"Hello, &#123;&#125;!"</span>, input))</span><br><span class="line">        .expect(<span class="string">"Couldn't create java string!"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Finally, extract the raw pointer to return.</span></span><br><span class="line">    output.into_raw()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//============== rust code ===============</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">append_string</span></span>(value: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> origin = <span class="built_in">String</span>::from(value);</span><br><span class="line">    origin.push_str(<span class="string">"this is Rust"</span>);</span><br><span class="line">    <span class="keyword">return</span> origin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五，编译Rust代码为so"><a href="#五，编译Rust代码为so" class="headerlink" title="五，编译Rust代码为so"></a>五，编译Rust代码为so</h2><ul><li><p>编译之前确认之前rust环境是可以使用的了，且要看下rustup target 下是否已经有要交叉编译的工具了。</p></li><li><p>rustc –print target-list | grep android 可以查看相关android 交叉编译工具,（我们demo之前在配置target时，使用了32和64位的ARM CPU 架构linker）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">aarch64-linux-android</span><br><span class="line">arm-linux-androideabi</span><br><span class="line">armv7-linux-androideabi</span><br><span class="line">i686-linux-android</span><br><span class="line">thumbv7neon-linux-androideabi</span><br><span class="line">x86_64-linux-android</span><br></pre></td></tr></table></figure></li><li><p>如果没有安装，需要安装下对应的</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rustup target add aarch64-linux-android armv7-linux-androideabi</span><br></pre></td></tr></table></figure><ul><li>rustup show 可以看到当前rust开发语言环境，包括 （installed targets for active toolchain）</li><li>rustup target list可以查看到那些已经安装和rust支持的。</li></ul><h3 id="执行编译"><a href="#执行编译" class="headerlink" title="执行编译"></a>执行编译</h3><ul><li>到rust_lib目录下执行编译</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo build --target aarch64-linux-android --release</span><br></pre></td></tr></table></figure><ul><li>编译成功到target目录下release下去查看对应的so文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── CACHEDIR.TAG</span><br><span class="line">├── aarch64-linux-android</span><br><span class="line">│   ├── CACHEDIR.TAG</span><br><span class="line">│   └── release</span><br><span class="line">├── armv7-linux-androideabi</span><br><span class="line">│   ├── CACHEDIR.TAG</span><br><span class="line">│   └── release</span><br><span class="line">├── debug</span><br><span class="line">│   ├── build</span><br><span class="line">│   ├── deps</span><br><span class="line">│   ├── examples</span><br><span class="line">│   └── incremental</span><br><span class="line">└── release</span><br><span class="line">    ├── build</span><br><span class="line">    ├── deps</span><br><span class="line">    ├── examples</span><br><span class="line">    └── incremental</span><br></pre></td></tr></table></figure><h2 id="使用rust代码运行工程"><a href="#使用rust代码运行工程" class="headerlink" title="使用rust代码运行工程"></a>使用rust代码运行工程</h2><ul><li>copy 对应的so文件到 Android工程下src/main/libs下</li><li>在Android工程下build.gradle下记得引用so为jniLibs</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sourceSets &#123;</span><br><span class="line">    main &#123;</span><br><span class="line">        jniLibs.srcDirs = [&apos;src/main/libs&apos;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>至此，应该可以直接运行看效果了，<strong>如果有需帮助可以邮件我，或者下载源码</strong>  <a href="https://github.com/zhulg/AndroidIntegratingRust" target="_blank" rel="noopener">地址</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Andorid调用Rust&quot;&gt;&lt;a href=&quot;#Andorid调用Rust&quot; class=&quot;headerlink&quot; title=&quot;Andorid调用Rust&quot;&gt;&lt;/a&gt;Andorid调用Rust&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;目前rust在移动端上的应用，一般作为应</summary>
      
    
    
    
    <category term="Rust" scheme="https://zhulg.github.io/categories/Rust/"/>
    
    
    <category term="Rust" scheme="https://zhulg.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust学习精简笔记总结(三)</title>
    <link href="https://zhulg.github.io/posts/15eb29eb.html"/>
    <id>https://zhulg.github.io/posts/15eb29eb.html</id>
    <published>2022-10-16T02:21:29.000Z</published>
    <updated>2024-07-07T04:21:27.925Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Rust精简笔记第3部分"><a href="#Rust精简笔记第3部分" class="headerlink" title="Rust精简笔记第3部分"></a>Rust精简笔记第3部分</h1><ul><li>继续整理rust笔记，过程会发现一些rust盲区理解，可深入源码学习, 从笔记知识点映射背后源码定义。</li><li><em>参考The Rust Programming Language &amp;  Rust in Action</em></li></ul><h2 id="十一，指针-amp-智能指针"><a href="#十一，指针-amp-智能指针" class="headerlink" title="十一，指针&amp;智能指针"></a>十一，指针&amp;智能指针</h2><ul><li>指针是一个包含内存地址的变量的通用概念， 智能指针（smart pointers）是一类数据结构，他们的表现类似指针，但是也拥有额外的元数据和功能</li><li>智能指针通常使用结构体实现，智能指针其实现了 Deref 和 Drop trait(离开作用域时运行的代码)</li></ul><h4 id="1-Box-用于在堆上分配值"><a href="#1-Box-用于在堆上分配值" class="headerlink" title="1. Box 用于在堆上分配值:"></a>1. Box<t> 用于在堆上分配值:</t></h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> b = <span class="built_in">Box</span>::new(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h4 id="2-Rc-引用计数智能指针"><a href="#2-Rc-引用计数智能指针" class="headerlink" title="2. Rc 引用计数智能指针:"></a>2. Rc<t> 引用计数智能指针:</t></h4><ul><li>Rc<t> 只能用于单线程场景</t></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Rc::clone 只会增加引用计数, 这样a,b都是指向1</span></span><br><span class="line"> <span class="keyword">let</span> a = Rc::new(<span class="number">1</span>);</span><br><span class="line"> <span class="keyword">let</span> b = Rc::clone(&amp;a);</span><br></pre></td></tr></table></figure><h4 id="3-RefCell-lt-T-gt-和内部可变性模式"><a href="#3-RefCell-lt-T-gt-和内部可变性模式" class="headerlink" title="3. RefCell&lt;T&gt; 和内部可变性模式:"></a>3. RefCell&lt;T&gt; 和内部可变性模式:</h4><ul><li><strong>RefCell&lt;T&gt; 代表其数据的唯一的所有权</strong>, 他具有如下特点:</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在任意给定时刻，只能拥有一个可变引用或任意数量的不可变引用 之一（而不是两者）。</span></span><br><span class="line"><span class="comment">//引用必须总是有效的。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> r1 = RefCell::new(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// Ref - 只有一个不可变借用</span></span><br><span class="line">    <span class="keyword">let</span> r2 = r1.borrow();</span><br><span class="line">    <span class="comment">// RefMut - mutable  可变借用</span></span><br><span class="line">    <span class="keyword">let</span> r3 = r1.borrow_mut();</span><br><span class="line">    <span class="comment">// RefMut - 可变借用</span></span><br><span class="line">    <span class="keyword">let</span> r4 = r1.borrow_mut();</span><br></pre></td></tr></table></figure><ul><li><strong>内部可变性（Interior mutability):</strong><br>  是Rust 中的一个设计模式，它允许你即使在有不可变引用时也可以改变数据。</li><li>实现是通过不可变的Rc&lt;T&gt;, 此时的T的类型为RefCell&lt;T&gt;， <strong>即结合成Rc&lt;RefCell&lt;T&gt;&gt; 来实现内部可变性</strong>，而外部是无法修改的。     </li><li>let value = Rc::new(RefCell::new(5)) 完整例子如下：</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span></span> &#123;</span><br><span class="line">    Cons(Rc&lt;RefCell&lt;<span class="built_in">i32</span>&gt;&gt;, Rc&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> value = Rc::new(RefCell::new(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> a = Rc::new(Cons(Rc::clone(&amp;value), Rc::new(Nil)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> b = Cons(Rc::new(RefCell::new(<span class="number">3</span>)), Rc::clone(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> c = Cons(Rc::new(RefCell::new(<span class="number">4</span>)), Rc::clone(&amp;a));</span><br><span class="line"></span><br><span class="line">    *value.borrow_mut() += <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"a after = &#123;:?&#125;"</span>, a);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"b after = &#123;:?&#125;"</span>, b);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"c after = &#123;:?&#125;"</span>, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="十二，使用和引用模块代码："><a href="#十二，使用和引用模块代码：" class="headerlink" title="十二，使用和引用模块代码："></a>十二，使用和引用模块代码：</h2><ul><li>模块的创建和引用</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">some_function</span></span>() &#123;&#125;</span><br><span class="line"><span class="keyword">mod</span> outer_module &#123;</span><br><span class="line">    <span class="comment">// private module</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> inner_module &#123;</span><br><span class="line">        <span class="comment">// public module</span></span><br><span class="line">        <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">inner_public_function</span></span>() &#123;</span><br><span class="line">            super::super::some_function();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">inner_private_function</span></span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 绝对路径 从 crate 根开始，以 crate 名或者字面值 crate 开头。</span></span><br><span class="line">    crate::outer_module::inner_module::inner_public_function();</span><br><span class="line">    <span class="comment">//  相对路径（relative path）从当前模块开始，以 self、super 或当前模块的标识符开头。</span></span><br><span class="line">    outer_module::inner_module::inner_public_function();</span><br><span class="line">    <span class="comment">// 使用 use 关键字将路径引入作用域</span></span><br><span class="line">    <span class="keyword">use</span> outer_module::inner_module;</span><br><span class="line">    inner_module::inner_public_function();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Rust精简笔记第3部分&quot;&gt;&lt;a href=&quot;#Rust精简笔记第3部分&quot; class=&quot;headerlink&quot; title=&quot;Rust精简笔记第3部分&quot;&gt;&lt;/a&gt;Rust精简笔记第3部分&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;继续整理rust笔记，过程会发现一些rust盲区</summary>
      
    
    
    
    <category term="Rust" scheme="https://zhulg.github.io/categories/Rust/"/>
    
    
    <category term="Rust" scheme="https://zhulg.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust学习精简笔记总结(二)</title>
    <link href="https://zhulg.github.io/posts/6b1809c0.html"/>
    <id>https://zhulg.github.io/posts/6b1809c0.html</id>
    <published>2022-10-03T14:06:44.000Z</published>
    <updated>2024-07-07T04:21:27.925Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Rust精简笔记第2部分"><a href="#Rust精简笔记第2部分" class="headerlink" title="Rust精简笔记第2部分"></a>Rust精简笔记第2部分</h1><ul><li>继续Rust基础知识点总结，趁假期回顾学习</li><li><em>参考The Rust Programming Language &amp;  Rust in Action</em></li></ul><h2 id="八，泛型、Trait、生命周期"><a href="#八，泛型、Trait、生命周期" class="headerlink" title="八，泛型、Trait、生命周期"></a>八，泛型、Trait、生命周期</h2><h4 id="泛型："><a href="#泛型：" class="headerlink" title="泛型："></a>泛型：</h4><ul><li><strong>函数定义中使用泛型</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; T &#123;</span><br><span class="line">&#125;</span><br><span class="line">//函数 largest 有泛型类型 T。它有个参数 list，其类型是元素为 T 的 slice。largest 函数的返回值类型也是 T</span><br><span class="line">//类型参数声明位于函数名称与参数列表中间的尖括号 &lt;&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>结构体定义中的泛型</strong></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> integer = Point &#123; x: <span class="number">5</span>, y: <span class="number">10</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> float = Point &#123; x: <span class="number">1.0</span>, y: <span class="number">4.0</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>枚举定义中的泛型</strong></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Option</span></span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="literal">Some</span>(T),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Result</span></span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="literal">Ok</span>(T),</span><br><span class="line">    <span class="literal">Err</span>(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>方法定义中的泛型</strong></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Point&lt;T&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">x</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;T &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> p = Point &#123; x: <span class="number">5</span>, y: <span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"p.x = &#123;&#125;"</span>, p.x());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Trait："><a href="#Trait：" class="headerlink" title="Trait："></a>Trait：</h4><ul><li>通过 trait 以一种抽象的方式定义共享的行为,<em>trait</em>  类似于其他语言中的接口，但也不完全一样.</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义 trait Summary ,定义summarize调取-&gt;summarize_author默认方法，达到调用默认行为，区分开实现trait的的定义</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Summary</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">summarize_author</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span>;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">summarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">"(Read more from &#123;&#125;...)"</span>, <span class="keyword">self</span>.summarize_author())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Tweet</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> username: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> reply: <span class="built_in">bool</span>,</span><br><span class="line">    <span class="keyword">pub</span> retweet: <span class="built_in">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现 trait Summary</span></span><br><span class="line"><span class="keyword">impl</span> Summary <span class="keyword">for</span> Tweet &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">summarize_author</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">"@&#123;&#125;"</span>, <span class="keyword">self</span>.username)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> tweet = Tweet &#123;</span><br><span class="line">        username: <span class="built_in">String</span>::from(<span class="string">"horse_ebooks"</span>),</span><br><span class="line">        content: <span class="built_in">String</span>::from(<span class="string">"of course, as you probably already know, people"</span>),</span><br><span class="line">        reply: <span class="literal">false</span>,</span><br><span class="line">        retweet: <span class="literal">false</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"1 new tweet: &#123;&#125;"</span>, tweet.summarize());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>trait 作为参数：</strong></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法接收是实现了 trait Summary的类型</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>(item: &amp;<span class="keyword">impl</span> Summary) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Breaking news! &#123;&#125;"</span>, item.summarize());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>Trait Bound：</strong><br>  impl Trait 适用于短小的例子。trait bound 则适用于更复杂的场景，trait bound 与泛型参数声明在一起，位于尖括号中的冒号后面。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用相同类型的trait可以转换成下边的更简单写法</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>(item1: &amp;<span class="keyword">impl</span> Summary, item2: &amp;<span class="keyword">impl</span> Summary) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// trait Bound的写法</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>&lt;T: Summary&gt;(item1: &amp;T, item2: &amp;T) &#123;&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>通过 <code>+</code> 指定多个 trait bound:</strong></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>&lt;T: Summary + Display&gt;(item: &amp;T) &#123;&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>通过 <code>where</code> 简化 trait bound：</strong></p><p>每个泛型有其自己的 trait bound，所以有多个泛型参数的函数在名称和参数列表之间会有很长的 trait bound 信息，这使得函数签名难以阅读</p></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">some_function</span></span>&lt;T, U&gt;(t: &amp;T, u: &amp;U) -&gt; <span class="built_in">i32</span></span><br><span class="line">    <span class="keyword">where</span> T: Display + <span class="built_in">Clone</span>,</span><br><span class="line">          U: <span class="built_in">Clone</span> + <span class="built_in">Debug</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="声明周期："><a href="#声明周期：" class="headerlink" title="声明周期："></a>声明周期：</h4><ul><li><p>Rust 中的每一个引用都有其 生命周期（lifetime），也就是引用保持有效的作用域，Rust 编译器有一个借用检查器（borrow checker）它比较作用域来确保所有的借用都是有效的</p></li><li><p><strong>函数签名中的生命周期注解：</strong></p></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">longest</span></span>&lt;<span class="symbol">'a</span>&gt;(x: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>, y: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>) -&gt; &amp;<span class="symbol">'a</span> <span class="built_in">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.len() &gt; y.len() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> string1 = <span class="built_in">String</span>::from(<span class="string">"abcd"</span>);</span><br><span class="line">    <span class="keyword">let</span> string2 = <span class="string">"xyz"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> result = longest(string1.as_str(), string2);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"The longest string is &#123;&#125;"</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>参数声明周期使用方法，或者靠编译器提示添加。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;<span class="built_in">i32</span>        <span class="comment">// 引用, 没有生命周期参数的 i32 的引用</span></span><br><span class="line">&amp;<span class="symbol">'a</span> <span class="built_in">i32</span>     <span class="comment">// 带有显式生命周期的引用 ，一个有叫做 'a 的生命周期参数的 i32 的引用</span></span><br><span class="line">&amp;<span class="symbol">'a</span> <span class="keyword">mut</span> <span class="built_in">i32</span> <span class="comment">// 带有显式生命周期的可变引用 一个生命周期也是 'a 的 i32 的可变引用</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>结构体定义中的生命周期注解：</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ImportantExcerpt</span></span>&lt;<span class="symbol">'a</span>&gt; &#123;</span><br><span class="line">    part: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> novel = <span class="built_in">String</span>::from(<span class="string">"Call me Ishmael. Some years ago..."</span>);</span><br><span class="line">    <span class="keyword">let</span> first_sentence = novel.split(<span class="string">'.'</span>).next().expect(<span class="string">"Could not find a '.'"</span>);</span><br><span class="line">    <span class="keyword">let</span> i = ImportantExcerpt &#123;</span><br><span class="line">        part: first_sentence,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>静态生命周期:</strong></p></li><li><p>生命周期能够存活于整个程序期间。所有的字符串字面值都拥有 ‘static 生命周期</p></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s: &amp;<span class="symbol">'static</span> <span class="built_in">str</span> = <span class="string">"I have a static lifetime."</span>;</span><br></pre></td></tr></table></figure><h2 id="九，集合："><a href="#九，集合：" class="headerlink" title="九，集合："></a>九，集合：</h2><h4 id="vector"><a href="#vector" class="headerlink" title="vector:"></a>vector:</h4><ul><li>类型是 Vec<t> 在内存中彼此相邻地排列所有的值, vector 只能储存相同类型的值</t></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vec::new 创建</span></span><br><span class="line"><span class="keyword">let</span> v: <span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt; = <span class="built_in">Vec</span>::new();</span><br><span class="line">v.push(<span class="number">2</span>);</span><br><span class="line">v.push(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">let</span> x = v.pop();</span><br></pre></td></tr></table></figure><ul><li><strong>初始值来创建一个 Vec<t> :</t></strong></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure><ul><li><strong>读取 vector 的元素:</strong><br>   使用 &amp;[index] 返回一个引用, 或者使用 get 方法以索引作为参数来返回一个 Option&lt;&amp;T&gt;。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> third: &amp;<span class="built_in">i32</span> = &amp;v[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"The third element is &#123;&#125;"</span>, third);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> v.get(<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="literal">Some</span>(third) =&gt; <span class="built_in">println!</span>(<span class="string">"The third element is &#123;&#125;"</span>, third),</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">"There is no third element."</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>使用枚举来储存多种类型:</strong><br>  创建一个储存枚举值的 vector，这样最终就能够通过vector存储实际是不同类型的值了</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">SpreadsheetCell</span></span> &#123;</span><br><span class="line">        Int(<span class="built_in">i32</span>),</span><br><span class="line">        Float(<span class="built_in">f64</span>),</span><br><span class="line">        Text(<span class="built_in">String</span>),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> row = <span class="built_in">vec!</span>[</span><br><span class="line">        SpreadsheetCell::Int(<span class="number">3</span>),</span><br><span class="line">        SpreadsheetCell::Text(<span class="built_in">String</span>::from(<span class="string">"blue"</span>)),</span><br><span class="line">        SpreadsheetCell::Float(<span class="number">10.12</span>),</span><br><span class="line">    ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> scores = HashMap::new();</span><br><span class="line">scores.insert(<span class="built_in">String</span>::from(<span class="string">"Blue"</span>), <span class="number">10</span>); <span class="comment">//插入</span></span><br><span class="line"><span class="comment">//只在键没有对应值时插入</span></span><br><span class="line">scores.entry(<span class="built_in">String</span>::from(<span class="string">"Yellow"</span>)).or_insert(<span class="number">50</span>);</span><br><span class="line">scores.entry(<span class="built_in">String</span>::from(<span class="string">"Blue"</span>)).or_insert(<span class="number">50</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, scores);</span><br></pre></td></tr></table></figure><ul><li>more： <a href="https://doc.rust-lang.org/std/collections/index.html" target="_blank" rel="noopener">https://doc.rust-lang.org/std/collections/index.html</a></li></ul><h2 id="十，函数、闭包、迭代器"><a href="#十，函数、闭包、迭代器" class="headerlink" title="十，函数、闭包、迭代器"></a>十，函数、闭包、迭代器</h2><h4 id="函数："><a href="#函数：" class="headerlink" title="函数："></a>函数：</h4><ul><li>函数的定义方式及在结构体实现里关联函数，关联函数与方法的使用区别</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::primitive;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span> &#123;</span><br><span class="line">    x: <span class="built_in">i32</span>,</span><br><span class="line">    y: <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> Point &#123;</span><br><span class="line">    <span class="comment">// 关联函数(没有self相关参数)</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(x: <span class="built_in">i32</span>, y: <span class="built_in">i32</span>) -&gt; Point &#123;</span><br><span class="line">        Point &#123; x: x, y: y &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 方法(参数为&amp;self，是个隐示的，调用时无需传递表明是该类型而已）</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">get_x</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">//关联函数使用:: 方法使用类型.方法，如Point::new, point.get_x</span></span><br><span class="line">    <span class="keyword">let</span> point = Point::new(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"get x=&#123;&#125;"</span>, point.get_x());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="闭包："><a href="#闭包：" class="headerlink" title="闭包："></a>闭包：</h4><ul><li><strong>闭包（closures）</strong>是可以保存在一个变量中或作为参数传递给其他函数的匿名函数。 闭包的定义以一对竖线（|）开始，在竖线中指定闭包的参数</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span>  <span class="title">add_one_v1</span>   </span>(x: <span class="built_in">u32</span>) -&gt; <span class="built_in">u32</span> &#123; x + <span class="number">1</span> &#125;  <span class="comment">//函数的定义</span></span><br><span class="line"><span class="keyword">let</span> add_one_v2 = |x: <span class="built_in">u32</span>| -&gt; <span class="built_in">u32</span> &#123; x + <span class="number">1</span> &#125;; <span class="comment">// 完整标注的闭包定义</span></span><br><span class="line"><span class="keyword">let</span> add_one_v3 = |x|             &#123; x + <span class="number">1</span> &#125;;  <span class="comment">// 闭包定义中省略了类型注解</span></span><br><span class="line"><span class="keyword">let</span> add_one_v4 = |x|               x + <span class="number">1</span>  ;  <span class="comment">// 闭包体只有一行,去掉了大括号</span></span><br></pre></td></tr></table></figure><ul><li><strong>闭包会捕获其环境:</strong> </li><li>可以捕获其环境并访问其被定义的作用域的变量。如下边 x 并不是 equal_to_x 的一个参数，equal_to_x 闭包也被允许使用变量 x，因为它与 equal_to_x 定义于相同的作用域</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">let</span> equal_to_x = |z| z == x;</span><br><span class="line">    <span class="keyword">let</span> y = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert!</span>(equal_to_x(y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong><em>当闭包从环境中捕获一个值，闭包会在闭包体中储存这个值以供使用，这会使用内存并产生额外的开销。</em></strong></p></li><li><p>闭包可以通过三种方式捕获其环境，他们直接对应函数的三种获取参数的方式：获取所有权，可变借用和不可变借用。</p></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">FnOnce</span> 消费从周围作用域捕获的变量，闭包周围的作用域被称为其 环境，environment。为了消费捕获到的变量，闭包必须获取其所有权并在定义闭包时将其移动进闭包。其名称的 Once 部分代表了闭包不能多次获取相同变量的所有权的事实，所以它只能被调用一次</span><br><span class="line"><span class="built_in">FnMut</span> 获取可变的借用值所以可以改变其环境</span><br><span class="line"><span class="built_in">Fn</span> 从其环境获取不可变的借用值</span><br></pre></td></tr></table></figure><p>由于所有闭包都可以被调用至少一次，所以所有闭包都实现了 FnOnce .<strong>大部分需要指定一个 Fn 系列 trait bound 的时候，可以从 Fn 开始，而编译器会根据闭包体中的情况告诉你是否需要 FnMut 或 FnOnce。</strong></p><ul><li><strong>带有泛型和 Fn trait 的闭包:</strong><br>  可以创建一个存放闭包和调用闭包结果的结构体, 目的：结构体只会在需要结果时执行闭包，并会缓存结果值，再次调用闭包可以复用该值.</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cacher</span></span>&lt;T&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: <span class="built_in">Fn</span>(<span class="built_in">u32</span>) -&gt; <span class="built_in">u32</span>,</span><br><span class="line">&#123;</span><br><span class="line">    calculation: T,</span><br><span class="line">    value: <span class="built_in">Option</span>&lt;<span class="built_in">u32</span>&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong><em>创建Cache的结构体，泛型T类型使用where 声明类型为闭包，结构体包含一个闭包，和一个用于存放闭包返回的值的u32类型，因为有可能第一次没有缓存，所有使用Option<u32>的类型。即可能是some(u32) 或者None</u32></em></strong></p><ul><li><strong>官方完整例子：</strong></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cacher</span></span>&lt;T&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: <span class="built_in">Fn</span>(<span class="built_in">u32</span>) -&gt; <span class="built_in">u32</span>,</span><br><span class="line">&#123;</span><br><span class="line">    calculation: T,</span><br><span class="line">    value: <span class="built_in">Option</span>&lt;<span class="built_in">u32</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Cacher&lt;T&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: <span class="built_in">Fn</span>(<span class="built_in">u32</span>) -&gt; <span class="built_in">u32</span>,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(calculation: T) -&gt; Cacher&lt;T&gt; &#123;</span><br><span class="line">        Cacher &#123;</span><br><span class="line">            calculation,</span><br><span class="line">            value: <span class="literal">None</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">value</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, arg: <span class="built_in">u32</span>) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span>.value &#123;</span><br><span class="line">            <span class="literal">Some</span>(v) =&gt; v,</span><br><span class="line">            <span class="literal">None</span> =&gt; &#123;</span><br><span class="line">                <span class="keyword">let</span> v = (<span class="keyword">self</span>.calculation)(arg);</span><br><span class="line">                <span class="keyword">self</span>.value = <span class="literal">Some</span>(v);</span><br><span class="line">                v</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">generate_workout</span></span>(intensity: <span class="built_in">u32</span>, random_number: <span class="built_in">u32</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> expensive_result = Cacher::new(|num| &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"calculating slowly..."</span>);</span><br><span class="line">        thread::sleep(Duration::from_secs(<span class="number">2</span>));</span><br><span class="line">        num</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> intensity &lt; <span class="number">25</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Today, do &#123;&#125; pushups!"</span>, expensive_result.value(intensity));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Next, do &#123;&#125; situps!"</span>, expensive_result.value(intensity));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> random_number == <span class="number">3</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"Take a break today! Remember to stay hydrated!"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(</span><br><span class="line">                <span class="string">"Today, run for &#123;&#125; minutes!"</span>,</span><br><span class="line">                expensive_result.value(intensity)</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> simulated_user_specified_value = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">let</span> simulated_random_number = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    generate_workout(simulated_user_specified_value, simulated_random_number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>a.这样可以起到了使用结构体缓存了闭包执行的结果，会先从结构体里查找缓存的值，没有再计算。<br>b.同理也可以改造value的类型为HashMap, 可以通过key来找值，避免返回之前计算的始终同一个值。</strong></p><h3 id="iterator"><a href="#iterator" class="headerlink" title="iterator:"></a>iterator:</h3><ul><li><strong>迭代器（iterator):</strong>负责遍历序列中的每一项和决定序列何时结束的逻辑。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v1 = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> v1_iter = v1.iter();</span><br><span class="line"><span class="keyword">let</span> total: <span class="built_in">i32</span> = v1_iter.sum();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"value = &#123;&#125;"</span>, &#123; total &#125;)</span><br></pre></td></tr></table></figure><ul><li>next 是 Iterator 实现者被要求定义的唯一方法</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v1 = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> v1_iter = v1.iter();</span><br><span class="line"><span class="built_in">assert_eq!</span>(v1_iter.next(), <span class="literal">Some</span>(&amp;<span class="number">1</span>));</span><br></pre></td></tr></table></figure><ul><li>调用 map 方法创建一个新迭代器，接着调用 collect 方法消费新迭代器并创建一个 vector</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//next 一次返回迭代器中的一个项，封装在 Some 中，当迭代器结束时，它返回 None</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> v1: <span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt; = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> newiter = v1.iter().map(|x| x + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> newVector: <span class="built_in">Vec</span>&lt;_&gt; = newiter.collect();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(newVector, <span class="built_in">vec!</span>[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><em>迭代器 iter()、iter_mut()、into_iter()区别：</em></strong></li></ul><ol><li>iter()返回的是值的不可变引用. 即&amp;T</li><li>iter_mut() 返回的是值的可变引用. 即&amp;mut T</li><li>into_iter() 返回的是T类型的值 </li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> core::num;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// iter() 返回的是值的不可变引用，即&amp;T.(此处map里闭包x本身无法改变)</span></span><br><span class="line">    <span class="keyword">let</span> vec = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">    <span class="keyword">let</span> new_vec: <span class="built_in">Vec</span>&lt;_&gt; = vec.iter().map(|x| x + <span class="number">1</span>).collect();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, vec);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, new_vec);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//iter_mut() 返回的是值的可变引用，即&amp;mut T.(此处map里闭包x本身+1)</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> vec = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">    vec.iter_mut().for_each(|x| *x += <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, vec);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//into_iter() 返回的是T类型的值  (因为所有权 vec是不能再使用)</span></span><br><span class="line">    <span class="keyword">let</span> vec = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">    <span class="keyword">let</span> new_vec: <span class="built_in">Vec</span>&lt;_&gt; = vec.into_iter().filter(|x| *x == <span class="number">2</span>).collect();</span><br><span class="line">    <span class="comment">// println!("&#123;:?&#125;", vec); // 无法编译</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, new_vec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>实现Iterator trait 来创建自定义迭代器:</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">struct Counter &#123;</span><br><span class="line">    count: u32,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Counter &#123;</span><br><span class="line">    fn new() -&gt; Counter &#123;</span><br><span class="line">        Counter &#123; count: 0 &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Counter 类型实现 Iterator trait，通过定义 next 方法来指定使用迭代器时的行为</span><br><span class="line">impl Iterator for Counter &#123;</span><br><span class="line">    type Item = u32; </span><br><span class="line">     //将迭代器的关联类型 Item 设置为 u32，意味着迭代器会返回 u32 值集合</span><br><span class="line">    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; &#123;</span><br><span class="line">        if self.count &lt; 5 &#123;</span><br><span class="line">            self.count += 1;</span><br><span class="line">            Some(self.count)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            None</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Rust里iterator的定义：</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Iterator</span></span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Item</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">next</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;Self::Item&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Rust精简笔记第2部分&quot;&gt;&lt;a href=&quot;#Rust精简笔记第2部分&quot; class=&quot;headerlink&quot; title=&quot;Rust精简笔记第2部分&quot;&gt;&lt;/a&gt;Rust精简笔记第2部分&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;继续Rust基础知识点总结，趁假期回顾学习&lt;/l</summary>
      
    
    
    
    <category term="Rust" scheme="https://zhulg.github.io/categories/Rust/"/>
    
    
    <category term="Rust" scheme="https://zhulg.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust学习精简笔记总结(一)</title>
    <link href="https://zhulg.github.io/posts/658f0ea2.html"/>
    <id>https://zhulg.github.io/posts/658f0ea2.html</id>
    <published>2022-09-24T06:53:01.000Z</published>
    <updated>2024-07-07T04:21:27.925Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Rust精简笔记"><a href="#Rust精简笔记" class="headerlink" title="Rust精简笔记"></a>Rust精简笔记</h1><ul><li>适用对Rust感兴趣，想快速学习上手（多学几轮）、Rust知识点速查、回顾。</li><li>精简总结使用，深入扩展需继续对应官网，真知实践。</li><li><em>参考The Rust Programming Language &amp;  Rust in Action</em></li></ul><h2 id="一-变量："><a href="#一-变量：" class="headerlink" title="一.变量："></a>一.<strong>变量：</strong></h2><ul><li><p><strong>变量声明使用let, 默认为不可变（即只读），声明可变变量 mut （可读写）</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">5</span>;  <span class="comment">//类型可以由编译器自动推断出来</span></span><br><span class="line"><span class="keyword">let</span> y: <span class="built_in">i32</span> = <span class="number">6</span>;  <span class="comment">//或者是在创建变量时，声明类型</span></span><br><span class="line"><span class="keyword">let</span> z = <span class="number">7i32</span>;  <span class="comment">//数字类型，可以在数字字面量中加入类型注解</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="二-基本数据类型："><a href="#二-基本数据类型：" class="headerlink" title="二.基本数据类型："></a>二.<strong>基本数据类型：</strong></h2><h4 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型:"></a>数字类型:</h4><ul><li>分为有符号和无符号整数，浮点数类型、特定平台的整数</li><li><strong>每一个有符号的变体可以储存包含从 -2<sup>n-1</sup> 到2<sup>n-1</sup>-1 在内的数字</strong>，这里 n 是变体使用的位数。如：i8 范围（-128-127）</li><li><strong>无符号的范围为0到 2<sup>n</sup>-1</strong>，如: u8 范围（0-255）(00000000 - 11111111)</li></ul><table><thead><tr><th>类型</th><th>长度</th><th>描述</th></tr></thead><tbody><tr><td>i8, i16, i32, i64, i128</td><td>8,16,32,64,64,128 (bit)</td><td>有符号整数</td></tr><tr><td>u8, u16, u32, u64, u128</td><td>8,16,32,64,64,128 (bit)</td><td>无符号整数</td></tr><tr><td>f32, f64</td><td>32,64(位)</td><td>f32 是单精度浮点数，f64 是双精度浮点数</td></tr><tr><td>isize,  usize</td><td>32或64</td><td>32 位架构上它们是 32 位的，64 位架构上它们是 64 位的</td></tr></tbody></table><h4 id="Rust中的整型字面值"><a href="#Rust中的整型字面值" class="headerlink" title="Rust中的整型字面值:"></a>Rust中的整型字面值:</h4><table><thead><tr><th>数字字面值</th><th>描述</th></tr></thead><tbody><tr><td>Decimal (十进制)</td><td>1_100 （使用 _ 做为分隔符以方便读数）</td></tr><tr><td>Hex (十六进制)</td><td>0xff（0x开头）</td></tr><tr><td>Octal (八进制)</td><td>0o77 （0o开头）</td></tr><tr><td>Binary (二进制)</td><td>0b1111_0000（0b开头）</td></tr><tr><td>Byte (单字节字符)(仅限于u8)</td><td>b’A’（b开头）</td></tr></tbody></table><h4 id="布尔类型-bool："><a href="#布尔类型-bool：" class="headerlink" title="布尔类型 bool："></a>布尔类型 bool：</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> t = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">let</span> f: <span class="built_in">bool</span> = <span class="literal">false</span>; <span class="comment">// with explicit type annotation</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复合类型："><a href="#复合类型：" class="headerlink" title="复合类型："></a>复合类型：</h4><ul><li><p><strong>元组（tuple）和数组（array）</strong></p></li><li><p><strong>Tuple</strong>: 将多个其他类型的值组合进一个复合类型，声明后长度固定，索引下标从0开始.</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let tup: (i32, f64, u8) = (500, 8.4, 2); //声明类型</span><br><span class="line">let score = (&quot;Team A&quot;, 12); //自推断</span><br><span class="line">let five_hundred = tup.0; //取出元组里的500，下标0</span><br></pre></td></tr></table></figure><ul><li><strong>array</strong>: 数组里数据类型必现一致，长度固定</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]; <span class="comment">// 自推断</span></span><br><span class="line"><span class="keyword">let</span> b: [<span class="built_in">i32</span>; <span class="number">5</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]; <span class="comment">// 在方括号中包含每个元素的类型，后跟分号，再后跟数组元素的数量。</span></span><br><span class="line"><span class="keyword">let</span> c = [<span class="number">3</span>; <span class="number">5</span>]; <span class="comment">//变量名为c的数组将包含 5 个元素,数值都为3，等价与let a = [3, 3, 3, 3, 3]</span></span><br></pre></td></tr></table></figure><h2 id="三-流程控制"><a href="#三-流程控制" class="headerlink" title="三. 流程控制"></a>三. 流程控制</h2><h4 id="if-amp-if-let："><a href="#if-amp-if-let：" class="headerlink" title="if &amp;  if let："></a>if &amp;  if let：</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">let</span> number = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">if</span> number &lt; <span class="number">5</span> &#123;</span><br><span class="line">      <span class="built_in">println!</span>(<span class="string">"condition was true"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">println!</span>(<span class="string">"condition was false"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// match pattern and assign variable</span></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(i) = num &#123;</span><br><span class="line">      <span class="built_in">println!</span>(<span class="string">"number is: &#123;&#125;"</span>, i);</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">// if let 语法让我们以一种不那么冗长的方式结合 if 和 let，来处理只匹配一个模式的值而忽略其他模式的情况</span></span><br></pre></td></tr></table></figure><h4 id="loop"><a href="#loop" class="headerlink" title="loop:"></a>loop:</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">loop</span> &#123;</span><br><span class="line">    count += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> count == <span class="number">4</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"break"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Nested loops &amp; labels (循环标签): 如果存在嵌套循环在一个循环上指定一个 循环标签（loop label) 标识为’名字</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">'outer</span>: <span class="keyword">loop</span> &#123;</span><br><span class="line">    <span class="symbol">'inner</span>: <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// This breaks the inner loop</span></span><br><span class="line">        <span class="keyword">break</span> <span class="symbol">'outer</span>; <span class="comment">//   // This breaks the outer loop</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="while-amp-while-let"><a href="#while-amp-while-let" class="headerlink" title="while &amp;  while let:"></a>while &amp;  while let:</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> n &lt; <span class="number">101</span> &#123;</span><br><span class="line">    n += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> optional = <span class="literal">Some</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">let</span> <span class="literal">Some</span>(i) = optional &#123;</span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">"&#123;&#125;"</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="for-遍历集合"><a href="#for-遍历集合" class="headerlink" title="for 遍历集合:"></a>for 遍历集合:</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>];</span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> a &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"the value is: &#123;element&#125;"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用iter()</span></span><br><span class="line"><span class="keyword">let</span> array = [(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">3</span>)];</span><br><span class="line"><span class="keyword">for</span> (x, y) <span class="keyword">in</span> array.iter() &#123;</span><br><span class="line">    <span class="comment">// x, y accessible in loop body only</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"x=&#123;&#125;,y=&#123;&#125;"</span>, x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="match"><a href="#match" class="headerlink" title="match:"></a>match:</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> optional = <span class="literal">Some</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">match</span> optional &#123;</span><br><span class="line">    <span class="literal">Some</span>(i) =&gt; <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, i),</span><br><span class="line">    <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">"No value."</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四-所有权-amp-引用-amp-借用"><a href="#四-所有权-amp-引用-amp-借用" class="headerlink" title="四.所有权&amp;引用&amp;借用"></a>四.所有权&amp;引用&amp;借用</h2><h4 id="所有权规则"><a href="#所有权规则" class="headerlink" title="所有权规则:"></a>所有权规则:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Rust 中的每一个值都有一个 所有者（owner）</span><br><span class="line">值在任一时刻有且只有一个所有者</span><br><span class="line">当所有者（变量）离开作用域，这个值将被丢弃</span><br></pre></td></tr></table></figure><h4 id="借用规则：-引用的行为"><a href="#借用规则：-引用的行为" class="headerlink" title="借用规则：(引用的行为)"></a>借用规则：(引用的行为)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">同一作用域内，一个资源要么有一个可变引用，要么存在多个不可变引用</span><br><span class="line">引用总是有效的</span><br></pre></td></tr></table></figure><h4 id="String引用："><a href="#String引用：" class="headerlink" title="String引用："></a>String引用：</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">"hello world!"</span>);</span><br><span class="line"><span class="keyword">let</span> s1_ref = s1; <span class="comment">// immutable reference</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> s2 = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">let</span> s2_ref = &amp;<span class="keyword">mut</span> s2; <span class="comment">// mutable reference</span></span><br><span class="line">s2_ref.push_str(<span class="string">" world!"</span>);</span><br></pre></td></tr></table></figure><ul><li>函数里使用值，<strong>但不获取所有权, 使用&amp;，获取变量引用 ，仅读权限</strong></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line">    <span class="keyword">let</span> len = calculate_length(&amp;s1);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"The length of '&#123;&#125;' is &#123;&#125;."</span>, s1, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">calculate_length</span></span>(s: &amp;<span class="built_in">String</span>) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">    s.len()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>函数里参数可变引用, <strong>使用&amp;mut ，获取变量可变操作</strong></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line">    change(&amp;<span class="keyword">mut</span> s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  对参数声明&amp;mut ，操作写字符</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">change</span></span>(some_string: &amp;<span class="keyword">mut</span> <span class="built_in">String</span>) &#123;</span><br><span class="line">    some_string.push_str(<span class="string">", world"</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, some_string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="操作符对应的权限："><a href="#操作符对应的权限：" class="headerlink" title="操作符对应的权限："></a>操作符对应的权限：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x   不可变的值（所有权）</span><br><span class="line">&amp;x  x不可变的引用 （只读）</span><br><span class="line">&amp;mut x  x的可变引用（读写）</span><br></pre></td></tr></table></figure><h4 id="字符串-slice"><a href="#字符串-slice" class="headerlink" title="字符串 slice:"></a>字符串 slice:</h4><ul><li>slice 允许你引用集合中一段连续的元素序列，而不用引用整个集合。slice 是一类引用，它没有所有权</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">"hello world"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> hello = &amp;s[<span class="number">0</span>..<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">let</span> world = &amp;s[<span class="number">6</span>..<span class="number">11</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五-struct"><a href="#五-struct" class="headerlink" title="五. struct"></a>五. struct</h2><ul><li><strong>普通结构体： struct+一个名字，在大括号中每一部分可以是不同类型，定义每一部分数据的名字和类型，称之为结构体字段</strong></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span></span> &#123;</span><br><span class="line">    active: <span class="built_in">bool</span>,</span><br><span class="line">    username: <span class="built_in">String</span>,</span><br><span class="line">    email: <span class="built_in">String</span>,</span><br><span class="line">    sign_in_count: <span class="built_in">u64</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>创建一个实例需要以结构体的名字开头，接着在大括号中使用 key: value 键-值对的形式提供字段</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> userinfo = User &#123;</span><br><span class="line">    email: <span class="built_in">String</span>::from(<span class="string">"someone@example.com"</span>),</span><br><span class="line">    username: <span class="built_in">String</span>::from(<span class="string">"someusername123"</span>),</span><br><span class="line">    active: <span class="literal">true</span>,</span><br><span class="line">    sign_in_count: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="元组结构体（tuple-structs"><a href="#元组结构体（tuple-structs" class="headerlink" title="元组结构体（tuple structs):"></a>元组结构体（tuple structs):</h4><ul><li>元组结构体有着结构体名称提供的含义，但没有具体的字段名，只有字段的类型</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Color</span></span>(<span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>(<span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> black = Color(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> origin = Point(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类单元结构体（unit-like-structs）"><a href="#类单元结构体（unit-like-structs）" class="headerlink" title="类单元结构体（unit-like structs）:"></a>类单元结构体（unit-like structs）:</h4><ul><li>没有任何字段的结构体</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AlwaysEqual</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> subject = AlwaysEqual;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="impl为结构体添加方法："><a href="#impl为结构体添加方法：" class="headerlink" title="impl为结构体添加方法："></a>impl为结构体添加方法：</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span> &#123;</span><br><span class="line">    width: <span class="built_in">u32</span>,</span><br><span class="line">    height: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Rectangle &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">area</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>&amp;self 实际上是 self: &amp;Self 的缩写。在一个 impl 块中，Self 类型是 impl 块的类型的别名。方法的第一个参数必须有一个名为 self 的Self 类型的参数</li></ul><h4 id="impl里的关联函数："><a href="#impl里的关联函数：" class="headerlink" title="impl里的关联函数："></a>impl里的关联函数：</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> Rectangle &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">square</span></span>(size: <span class="built_in">u32</span>) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            width: size,</span><br><span class="line">            height: size,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>所有在 impl 块中定义的函数被称为 <strong>关联函数（associated functions</strong>），因为它们与 impl 后面命名的类型相关。我们可以定义不以 self 为第一参数的关联函数（因此不是方法），因为它们并不作用于一个结构体的实例</p></li><li><p><strong>多个 impl 块</strong>： 每个结构体都允许拥有多个 impl 块, 但一个方法只能属于一个impl块。</p></li></ul><h2 id="六-Enum"><a href="#六-Enum" class="headerlink" title="六.Enum"></a>六.Enum</h2><ul><li>结构体给予将字段和数据聚合在一起的方法，像 Rectangle 结构体有 width 和 height 两个字段。而枚举给予你将一个值成为一个集合之一的方法。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">IpAddrKind</span></span> &#123;</span><br><span class="line">    V4,</span><br><span class="line">    V6,</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">IpAddrKind</span></span> &#123;</span><br><span class="line">    V4,</span><br><span class="line">    V6,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> four = IpAddrKind::V4;</span><br><span class="line">    <span class="keyword">let</span> six = IpAddrKind::V6;</span><br><span class="line">    route(IpAddrKind::V4);</span><br><span class="line">    route(IpAddrKind::V6);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">route</span></span>(ip_kind: IpAddrKind) &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="枚举可以包含不同的类型"><a href="#枚举可以包含不同的类型" class="headerlink" title="枚举可以包含不同的类型:"></a><strong>枚举可以包含不同的类型:</strong></h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Message</span></span> &#123;</span><br><span class="line">    Quit, <span class="comment">// 没有关联任何数据</span></span><br><span class="line">    Move &#123; x: <span class="built_in">i32</span>, y: <span class="built_in">i32</span> &#125;, <span class="comment">//类似结构体包含命名字段</span></span><br><span class="line">    Write(<span class="built_in">String</span>), <span class="comment">//包含单独一个 String</span></span><br><span class="line">    ChangeColor(<span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>), <span class="comment">//包含三个 i32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>结构体和枚举还有另一个相似点：<strong>就像可以使用 impl 来为结构体定义方法那样</strong>，也可以在枚举上定义方法。这是一个定义于我们 Message 枚举上的叫做 call 的方法：</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Message</span></span> &#123;</span><br><span class="line">        Quit,</span><br><span class="line">        Move &#123; x: <span class="built_in">i32</span>, y: <span class="built_in">i32</span> &#125;,</span><br><span class="line">        Write(<span class="built_in">String</span>),</span><br><span class="line">        ChangeColor(<span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> Message &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">call</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">            <span class="comment">// 在这里定义方法体</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> m = Message::Write(<span class="built_in">String</span>::from(<span class="string">"hello"</span>));</span><br><span class="line">    m.call();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="标准库中实用的枚举：Option"><a href="#标准库中实用的枚举：Option" class="headerlink" title="标准库中实用的枚举：Option"></a>标准库中实用的枚举：Option</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Option</span></span>&lt;T&gt; &#123;</span><br><span class="line">        <span class="literal">None</span>,</span><br><span class="line">        <span class="literal">Some</span>(T),</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum Result&lt;T, E&gt; &#123;</span><br><span class="line">    OK(T),</span><br><span class="line">    Err(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="七-match控制流结构"><a href="#七-match控制流结构" class="headerlink" title="七.match控制流结构"></a>七.match控制流结构</h2><ul><li><p>前面流程控制简单说明了match使用，<strong>结合enum来看看match的更多使用场景总结</strong></p></li><li><p><strong>基础匹配语法：</strong></p></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> number = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">match</span> number &#123;</span><br><span class="line">    <span class="number">1</span> | <span class="number">2</span> =&gt; <span class="built_in">println!</span>(<span class="string">"1 or 2"</span>), <span class="comment">// 匹配到某一个</span></span><br><span class="line">    <span class="number">3</span>..=<span class="number">5</span> =&gt; <span class="built_in">println!</span>(<span class="string">"3到5"</span>),  <span class="comment">// 通过 ..= 匹配值的范围</span></span><br><span class="line">    _ =&gt; <span class="built_in">println!</span>(<span class="string">"invalid"</span>),    <span class="comment">//未匹配到 _</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="match-解构结构体"><a href="#match-解构结构体" class="headerlink" title="match 解构结构体:"></a>match 解构结构体:</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span> &#123;</span><br><span class="line">    x: <span class="built_in">i32</span>,</span><br><span class="line">    y: <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> p = Point &#123; x: <span class="number">0</span>, y: <span class="number">7</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> Point &#123; x: a, y: b &#125; = p;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">0</span>, a);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">7</span>, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解构枚举："><a href="#解构枚举：" class="headerlink" title="解构枚举："></a>解构枚举：</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Message</span></span> &#123;</span><br><span class="line">    Quit,</span><br><span class="line">    Move &#123; x: <span class="built_in">i32</span>, y: <span class="built_in">i32</span> &#125;,</span><br><span class="line">    Write(<span class="built_in">String</span>),</span><br><span class="line">    ChangeColor(<span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> msg = Message::ChangeColor(<span class="number">0</span>, <span class="number">160</span>, <span class="number">255</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> msg &#123;</span><br><span class="line">        Message::Quit =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"The Quit variant has no data to destructure."</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        Message::Move &#123; x, y &#125; =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(</span><br><span class="line">                <span class="string">"Move in the x direction &#123;&#125; and in the y direction &#123;&#125;"</span>,</span><br><span class="line">                x, y</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        Message::Write(text) =&gt; <span class="built_in">println!</span>(<span class="string">"Text message: &#123;&#125;"</span>, text),</span><br><span class="line">        Message::ChangeColor(r, g, b) =&gt; <span class="built_in">println!</span>(</span><br><span class="line">            <span class="string">"Change the color to red &#123;&#125;, green &#123;&#125;, and blue &#123;&#125;"</span>,</span><br><span class="line">            r, g, b</span><br><span class="line">        ),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印结果到change the color....</span></span><br></pre></td></tr></table></figure><h4 id="解构嵌套的结构体和枚举"><a href="#解构嵌套的结构体和枚举" class="headerlink" title="解构嵌套的结构体和枚举:"></a>解构嵌套的结构体和枚举:</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span></span> &#123;</span><br><span class="line">    Rgb(<span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>),</span><br><span class="line">    Hsv(<span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Message</span></span> &#123;</span><br><span class="line">    Quit,</span><br><span class="line">    Move &#123; x: <span class="built_in">i32</span>, y: <span class="built_in">i32</span> &#125;,</span><br><span class="line">    Write(<span class="built_in">String</span>),</span><br><span class="line">    ChangeColor(Color),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> msg = Message::ChangeColor(Color::Hsv(<span class="number">0</span>, <span class="number">160</span>, <span class="number">255</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> msg &#123;</span><br><span class="line">        Message::ChangeColor(Color::Rgb(r, g, b)) =&gt; <span class="built_in">println!</span>(</span><br><span class="line">            <span class="string">"Change the color to red &#123;&#125;, green &#123;&#125;, and blue &#123;&#125;"</span>,</span><br><span class="line">            r, g, b</span><br><span class="line">        ),</span><br><span class="line">        Message::ChangeColor(Color::Hsv(h, s, v)) =&gt; <span class="built_in">println!</span>(</span><br><span class="line">            <span class="string">"Change the color to hue &#123;&#125;, saturation &#123;&#125;, and value &#123;&#125;"</span>,</span><br><span class="line">            h, s, v</span><br><span class="line">        ),</span><br><span class="line">        _ =&gt; (),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="用-忽略剩余值"><a href="#用-忽略剩余值" class="headerlink" title="用 .. 忽略剩余值:"></a>用 .. 忽略剩余值:</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过使用 .. 来忽略 Point 中除 x 以外的字段</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span> &#123;</span><br><span class="line">        x: <span class="built_in">i32</span>,</span><br><span class="line">        y: <span class="built_in">i32</span>,</span><br><span class="line">        z: <span class="built_in">i32</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> origin = Point &#123; x: <span class="number">0</span>, y: <span class="number">0</span>, z: <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> origin &#123;</span><br><span class="line">        Point &#123; x, .. &#125; =&gt; <span class="built_in">println!</span>(<span class="string">"x is &#123;&#125;"</span>, x),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Match-guards"><a href="#Match-guards" class="headerlink" title="Match guards:"></a><strong>Match guards:</strong></h4><ul><li>匹配守卫（match guard）是一个指定于 match 分支模式之后的额外 if 条件，它也必须被满足才能选择此分支</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> num = <span class="literal">Some</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">match</span> num &#123;</span><br><span class="line">        <span class="literal">Some</span>(x) <span class="keyword">if</span> x &lt; <span class="number">5</span> =&gt; <span class="built_in">println!</span>(<span class="string">"less than five: &#123;&#125;"</span>, x),</span><br><span class="line">        <span class="literal">Some</span>(x) =&gt; <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, x),</span><br><span class="line">        <span class="literal">None</span> =&gt; (),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="绑定"><a href="#绑定" class="headerlink" title="@绑定:"></a><strong>@绑定:</strong></h4><ul><li>运算符@，允许我们在创建一个存放值的变量的同时，测试其值是否匹配模式。即@ 可以在一个模式中同时测试和保存变量值。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Message</span></span> &#123;</span><br><span class="line">        Hello &#123; id: <span class="built_in">i32</span> &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> msg = Message::Hello &#123; id: <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="keyword">match</span> msg &#123;</span><br><span class="line">        Message::Hello &#123;</span><br><span class="line">            id: id_variable @ <span class="number">3</span>..=<span class="number">7</span>, <span class="comment">//使用id_variable变量配合@，以便此分支相关联的代码可以使用它</span></span><br><span class="line">        &#125; =&gt; <span class="built_in">println!</span>(<span class="string">"Found an id in range: &#123;&#125;"</span>, id_variable),</span><br><span class="line">        Message::Hello &#123; id: <span class="number">10</span>..=<span class="number">12</span> &#125; =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"Found an id in another range"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        Message::Hello &#123; id &#125; =&gt; <span class="built_in">println!</span>(<span class="string">"Found some other id: &#123;&#125;"</span>, id),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Rust精简笔记&quot;&gt;&lt;a href=&quot;#Rust精简笔记&quot; class=&quot;headerlink&quot; title=&quot;Rust精简笔记&quot;&gt;&lt;/a&gt;Rust精简笔记&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;适用对Rust感兴趣，想快速学习上手（多学几轮）、Rust知识点速查、回顾。&lt;/</summary>
      
    
    
    
    <category term="Rust" scheme="https://zhulg.github.io/categories/Rust/"/>
    
    
    <category term="Rust" scheme="https://zhulg.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Flutter Widget生命周期总结</title>
    <link href="https://zhulg.github.io/posts/f4ca6a79.html"/>
    <id>https://zhulg.github.io/posts/f4ca6a79.html</id>
    <published>2022-05-27T06:26:29.000Z</published>
    <updated>2024-07-07T04:21:27.923Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Flutter Widget生命周期分为2种，一种有状态的组件StatefulWidget的生命周期，和无状态的StatelessWidget 组件的生命周期。</li></ul><h2 id="一-StatefulWidget的生命周期"><a href="#一-StatefulWidget的生命周期" class="headerlink" title="一.StatefulWidget的生命周期"></a>一.StatefulWidget的生命周期</h2><ul><li>先看一张statefulwidget生命周期图 <strong>（若文中图片无法显示，请科学上网查看：<a href="https://order.yizhihongxing.network/aff.php?aff=12299" target="_blank" rel="noopener">推荐工具</a>）</strong></li><li>继承StatefulWidget的组件会先进行构造方法，在进行对应的Widget的CreateState, 在State里</li></ul><p><img src="https://raw.githubusercontent.com/zhulg/allpic/master/flutter_widgetlifecycle.png" alt></p><h3 id="1-createState："><a href="#1-createState：" class="headerlink" title="1.createState："></a><em>1.createState：</em></h3><ul><li>创建新的StatefulWidget的时候，就会立即执行createState方法，<strong>返回一个state的实例与当前widget建立关系。</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class MyHomePage extends StatefulWidget &#123;</span><br><span class="line">  const MyHomePage(&#123;Key? key, required this.title&#125;) : super(key: key);</span><br><span class="line">  final String title;</span><br><span class="line">  @override</span><br><span class="line">  State&lt;MyHomePage&gt; createState() =&gt; _MyHomePageState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-initState："><a href="#2-initState：" class="headerlink" title="2. initState："></a><em>2. initState：</em></h3><ul><li>initState 是 StatefulWidget 创建完后，在State里调用的第一个方法, 只执行一次（iOS 的 viewDidLoad()、Android 的 onCreate）, StatefulWidget 已经被加载到渲染树里了但还没开始渲染，这里常做一些初始化变量工作。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@override</span><br><span class="line">void initState()&#123;</span><br><span class="line">  super.initState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-didChangeDependencies"><a href="#3-didChangeDependencies" class="headerlink" title="3. didChangeDependencies:"></a><em>3. didChangeDependencies:</em></h3><ul><li>在initState回调函数执行之后立即调用，之后当 StatefulWidget 刷新的时候，就不会调用了, <strong>当State对象的依赖发生变化时会被再次调用（层级变化&amp;共享依赖变化）</strong>。官网文档举例，如果之前build构建里依赖的 InheritedWidget 发生变化之后，那么他的 didChangeDependencies 会被再次调用。（InheritedWidget是 Flutter 中非常重要的一个功能型组件，它提供了一种在 widget 树中从上到下共享数据的方式，应用的根 widget 中通过InheritedWidget共享了一个数据，可以在任意子widget 中来获取该共享的数据）（场景：主题颜色、地区语言或者其他通用变量等）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@override</span><br><span class="line">void didChangeDependencies() &#123; &#125;</span><br></pre></td></tr></table></figure><h3 id="4-build："><a href="#4-build：" class="headerlink" title="4. build："></a><em>4. build：</em></h3><ul><li>build方法在didChangeDependencies之后会立即调用，之后每次当setState方法被调用后，都会进行重新build，并返回要渲染的widiget </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@override</span><br><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  return Scaffold()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-didUpdateWidget："><a href="#5-didUpdateWidget：" class="headerlink" title="5. didUpdateWidget："></a><em>5. didUpdateWidget：</em></h3><ul><li>比较严谨官方描述:  If the parent widget changes its properties or configurations, and the parent wants to rebuild the child widget, with the same Runtime Type, then didUpdateWidget is triggered. This unsubscribes to the old widget and subscribes to the configuration changes of the new widget! </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@override</span><br><span class="line">  void didUpdateWidget(covariant CurrentClass oldWidget) &#123;</span><br><span class="line">    // TODO: implement didUpdateWidget</span><br><span class="line">    super.didUpdateWidget(oldWidget);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="6-deactivate："><a href="#6-deactivate：" class="headerlink" title="6.  deactivate："></a><em>6.  deactivate：</em></h3><ul><li>当要将 State 对象从渲染树中移除的时候，就会调用 deactivate 生命周期，这标志着 StatefulWidget 将要销毁，但是有时候 State 不会被销毁，而是重新插入到渲染树种(例如；当使用Navigator.push 移动到下一个屏幕)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@override</span><br><span class="line">  void deactivate() &#123;</span><br><span class="line">    super.deactivate();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="7-dispose"><a href="#7-dispose" class="headerlink" title="7. dispose"></a><em>7. dispose</em></h3><ul><li>当 View 不需要再显示，从渲染树中移除的时候，State 就会永久的从渲染树中移除，就会调用 dispose 生命周期，(在 dispose 里做一些取消监听、动画的操作，和 initState 是相反)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@override</span><br><span class="line">  void dispose() &#123;</span><br><span class="line">    super.dispose();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="二-StatelessWidget的生命周期"><a href="#二-StatelessWidget的生命周期" class="headerlink" title="二. StatelessWidget的生命周期"></a>二. StatelessWidget的生命周期</h2><ul><li>StatelessWidget的生命周期比较简单，通过构造方法，build方法来进行渲染需要的widget，由于是无状态的也就执行一次。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;Flutter Widget生命周期分为2种，一种有状态的组件StatefulWidget的生命周期，和无状态的StatelessWidget 组件的生命周期。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;一-StatefulWidget的生命周期&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="flutter" scheme="https://zhulg.github.io/categories/flutter/"/>
    
    
    <category term="flutter" scheme="https://zhulg.github.io/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter架构构成和渲染原理</title>
    <link href="https://zhulg.github.io/posts/c8a78489.html"/>
    <id>https://zhulg.github.io/posts/c8a78489.html</id>
    <published>2022-05-13T09:04:58.000Z</published>
    <updated>2024-07-07T04:21:27.924Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-Flutter架构构成"><a href="#一-Flutter架构构成" class="headerlink" title="一.Flutter架构构成"></a>一.Flutter架构构成</h2><ul><li><p>Flutter的架构是一个可扩展的分层系统设计，上层组件各自依赖下层组件，层级不可越级访问，各个层级模块可替换</p></li><li><p><strong>Flutter从分层构成看主要分为3个层级：</strong></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Dart Framework</span><br><span class="line">C++ Engine</span><br><span class="line">Platform Embedder</span><br></pre></td></tr></table></figure><ul><li>从官网的架构图片层级分析：（科学上网可见图片）</li></ul><div align="center" width="100%">  <img width="80%" src="https://raw.githubusercontent.com/zhulg/allpic/master/flutter_arch.png"></div><h3 id="1-Platform-Embedder：-平台嵌入层"><a href="#1-Platform-Embedder：-平台嵌入层" class="headerlink" title="1. Platform Embedder：(平台嵌入层)"></a><em>1. Platform Embedder：(平台嵌入层)</em></h3><ul><li><strong>平台层潜入层作用:</strong>是把 Flutter 代码打包嵌入到具体的实现平台, 来呈现所有 Flutter 内容的原生系统应用, 它充当着宿主操作系统（android/ios/macOS/..）和 Flutter 之间的粘合剂的角色。</li><li>提供flutter的运行入口，初始化 Flutter 引擎，管理flutter应用生命周期</li><li>并对上层提供最基础的能力(渲染画布、插件系统、交互管理、消息循环等)</li></ul><h3 id="2-C-C-Engine"><a href="#2-C-C-Engine" class="headerlink" title="2. C/C++ Engine:"></a><strong><em>2. C/C++ Engine:</em></strong></h3><ul><li>它的主要职责是光栅化合成上屏幕用于显示绘制内容（当需要绘制新一帧的内容时，将负责对需要合成的场景进行栅格化）</li><li>提供了 Flutter 核心 API 的底层实现，包括图形（通过 Skia）、文本布局、文件及网络 IO、辅助功能支持、插件架构和 Dart 运行环境及编译环境的工具链。</li><li>引擎将底层 C++ 代码包装成 Dart 代码，通过 dart:ui 暴露给 Flutter 框架层，而dart:ui 包是 Flutter App 的构建基础</li></ul><h3 id="3-Dart-Framework"><a href="#3-Dart-Framework" class="headerlink" title="3. Dart Framework:"></a><strong><em>3. Dart Framework:</em></strong></h3><ul><li>提供了以 Dart 语言编写的现代响应式框架，对渲染逻辑做了统一封装，屏蔽了底层实现，对底层 C++ Engine 提供双向通信能力</li><li><strong>开发者只需要通过该层使用widget控件构建 App 视图即可</strong></li><li>Dart Framework 包括丰富的平台，布局和基础库。从上层到下层，依次有：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Material 和 Cupertino 分别实现了 android Material 和 iOS 设计规范。</span><br><span class="line">widget 层是一种组合的抽象,widgets 层让可以自由组合你需要复用的各种控件类</span><br><span class="line">渲染层 用于提供操作布局的抽象，负责控件布局摆放及更新</span><br><span class="line">基础的 foundational 类及一些基层之上的构建块服务， animation、 painting 和 gestures，它们可以提供上层常用的抽象。</span><br></pre></td></tr></table></figure><h2 id="Flutter核心组件"><a href="#Flutter核心组件" class="headerlink" title="Flutter核心组件"></a>Flutter核心组件</h2><h3 id="1-Widget-应用开发者直接使用"><a href="#1-Widget-应用开发者直接使用" class="headerlink" title="1.Widget (应用开发者直接使用)"></a>1.Widget (应用开发者直接使用)</h3><ul><li>Widget是Flutter的核心部分, Flutter的口号 Everything’s a widget,是构建应用的基础块</li><li>Widgets 通过布局组合形成一种层次结构关系。每个 Widget 都嵌套在其父级的内部，并可以通过父级接收上下文</li><li>Widget 不只表示UI 控件，还表示一些功能性的组件Navigator、GestureDetector 组件</li></ul><h3 id="2-Element-（实例化的-Widget-对象）"><a href="#2-Element-（实例化的-Widget-对象）" class="headerlink" title="2. Element （实例化的 Widget 对象）"></a>2. Element （实例化的 Widget 对象）</h3><ul><li>在构建的阶段，Flutter 会将代码中描述的 widgets 转换成对应的 Element 树，每一个 Widget 都有一个对应的 Element。<strong>每一个 Element 代表了树状层级结构中特定位置的 widget 实例。</strong></li><li>目前有两种 Element 的基本类型：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ComponentElement : Element 的宿主 </span><br><span class="line">RenderObjectElement :参与布局或绘制阶段的 Element。</span><br></pre></td></tr></table></figure><ul><li><strong>在代码阶段的widget层级在生成绘制后会多一些层级（源码和官网演示看查看到）</strong>，这里面多一些的层级往往就是参与布局和绘制RenderObjectElement</li></ul><div align="center" width="100%">  <img width="80%" src="https://raw.githubusercontent.com/zhulg/allpic/master/element-tree.png"></div><ul><li>注：ColoredBox 、RawImage、RichText 为绘制时产生的新增widget层级（科学上网可见图片）</li></ul><h3 id="3-RenderObject（树形）"><a href="#3-RenderObject（树形）" class="headerlink" title="3.RenderObject（树形）"></a>3.RenderObject（树形）</h3><ul><li>用于应用界面的布局和绘制，保存了元素的大小，布局等信息</li><li><strong>在构建阶段，Flutter 会为 Element 树中的每个 RenderObjectElement 创建或更新其对应的一个从 RenderObject 继承的对象</strong>。</li><li><strong>当应用运行时 Flutter 使用 RenderObject 的数据绘制应用界面，最终形成一个 Render Tree</strong>。(图片需要科学上网)</li></ul><div align="center" width="100%">  <img width="80%" src="https://raw.githubusercontent.com/zhulg/allpic/master/flutter-renderTree.png"></div><ul><li>大部分的 Flutter widget 是由一个继承了 RenderBox 的子类的对象渲染的，真正负责干活（layout、paint）</li><li>所有 RenderObject 的根节点是 RenderView，代表了渲染树的总体输出。当平台需要渲染新的一帧内容时（例如一个 vsync 信号或者一个纹理的更新完成），会调用一次 compositeFrame() 方法，它是 RenderView 的一部分。该方法会创建一个 SceneBuilder 来触发当前画面的更新。当画面更新完毕，RenderView 会将合成的画面传递给 dart:ui 中的 Window.render() 方法，控制 GPU 进行渲染。</li></ul><h3 id="三者直接关系："><a href="#三者直接关系：" class="headerlink" title="三者直接关系："></a>三者直接关系：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Widget 是应用界面的声明的控件，为开发者直接使用的控件</span><br><span class="line">Element 链接 Widget 和 RenderObject，管理界面的更新和修改。</span><br><span class="line">RenderObject 保存具体的布局信息，负责绘制 UI, 为实际渲染</span><br></pre></td></tr></table></figure><ul><li><strong>Widget重新创建，Element 树和 RenderObject 树并不会完全重新创建</strong>，如果 newWidget 与oldWidget 的 runtimeType 和 key 相等时，更新已经存在的 Element 对象，不然就选择重新创建新的 Element。</li></ul><h2 id="二-Flutter渲染原理"><a href="#二-Flutter渲染原理" class="headerlink" title="二.Flutter渲染原理"></a>二.Flutter渲染原理</h2><ul><li>从Flutter的核心控件大概已经初步了解到了渲染的相关流程，核心控件到绘制的情况。</li><li><strong>一般计算机绘图原理：</strong>屏幕显示器一般以60Hz的固定频率刷新，每一帧图像绘制完成后，会继续绘制下一帧，这时显示器就会发出一个Vsync信号，按60Hz计算，屏幕每秒会发出60次这样的信号。CPU计算好显示内容提交给GPU，GPU渲染好传递给显示器显示。flutter 渲染原理相同。渲染过程会使用上边介绍的核心流程控件。</li></ul><div align="center" width="100%">  <img width="80%" src="https://raw.githubusercontent.com/zhulg/allpic/master/flutter-render.png"></div><ul><li>Flutter 的渲染流水线也包括两个线程，<strong>UI 线程和 GPU 线程，UI 线程主要负责的是根据 UI 界面的描述生成 UI 界面的绘制指令，建立过程中生成 Render，往下布局、绘制大小等工作，完成以后会生成一个 Layer Tree，到了 GPU 线程之后会调用 Skia 做渲染</strong></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一-Flutter架构构成&quot;&gt;&lt;a href=&quot;#一-Flutter架构构成&quot; class=&quot;headerlink&quot; title=&quot;一.Flutter架构构成&quot;&gt;&lt;/a&gt;一.Flutter架构构成&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Flutter的架构是一个可扩展的</summary>
      
    
    
    
    <category term="flutter" scheme="https://zhulg.github.io/categories/flutter/"/>
    
    
    <category term="flutter" scheme="https://zhulg.github.io/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>NFT是什么有哪些应用场景</title>
    <link href="https://zhulg.github.io/posts/64ceaf0c.html"/>
    <id>https://zhulg.github.io/posts/64ceaf0c.html</id>
    <published>2022-05-06T05:59:54.000Z</published>
    <updated>2024-07-07T04:21:27.925Z</updated>
    
    <content type="html"><![CDATA[<h2 id="NFT是什么"><a href="#NFT是什么" class="headerlink" title="NFT是什么"></a>NFT是什么</h2><ul><li>NFT的全称为 Non-fungible Tokens（非同质化代币 ) ，<strong>用以代表独特物品所有权的代币</strong></li><li><strong>非同质化</strong>是一个经济术语，用它来描述家具、歌曲、字画、电脑等物品，<strong>这些东西不能与其他物品互换，因为它们具有独特属性。</strong></li><li><strong>NFT的主要功能是作为可验证的所有权证明，并显示资产所有权随时间推移的转移记录</strong></li><li>NFT起源于2017年的加密猫游戏，用于表示每只猫拥有的不同花色、基因、代际等信息。</li><li>目前最热的在数字艺术品、收藏品只是使用 NFT 的一种方式，NFT可以代表任何独特资产的所有权。<div align="center" width="100%"><img width="80%" src="https://raw.githubusercontent.com/zhulg/allpic/master/NFT_PIC.jpeg"></div></li><li><strong>（若文中图片无法显示，请科学上网查看：<a href="https://order.yizhihongxing.network/aff.php?aff=12299" target="_blank" rel="noopener">推荐工具</a>）</strong></li></ul><h2 id="NFT的工作原理"><a href="#NFT的工作原理" class="headerlink" title="NFT的工作原理"></a>NFT的工作原理</h2><ul><li>NFT通过工作量证明（PoW）区块链运作，PoW是一个过程，其中一方向其他方证明已经为一个目标付出了一定量的努力</li><li>NFT 一次只能有一个所有者。 通过唯一的 ID 和其他代币无法复制的元数据管理所有权。</li><li>NFT 通过智能合约铸造，智能合约分配 NFT 的所有权并管理它们的可转让性。</li><li>有人创建或铸造 NFT 时，他们会执行存储在符合不同标准的智能合约中的代码(如 ERC-721。 此信息会添加到正在管理 NFT 的区块链中)</li><li>铸造过程具有以下步骤：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">新建区块</span><br><span class="line">验证信息</span><br><span class="line">将信息录入区块链</span><br></pre></td></tr></table></figure><h2 id="NFT与去中心化"><a href="#NFT与去中心化" class="headerlink" title="NFT与去中心化"></a>NFT与去中心化</h2><ul><li>NFT的核心是内容和所有权验证，由于区块链不适合存储大量数据，因此一般将NFT的元数据（metadata）存储在去中心化存储网络上（一般是IPFS），将NFT的发行、流通记录存储在区块链上</li></ul><h2 id="NFT-有什么用"><a href="#NFT-有什么用" class="headerlink" title="NFT 有什么用"></a>NFT 有什么用</h2><ul><li>加速数字化，数字化后更便于流通、存证、防伪、溯源，复制实体物品的属性，稀缺性、独特性和所有权证明形成NFT</li><li>解决了当前互联网上存在的一些问题。</li></ul><table><thead><tr><th>NFT互联网</th><th>目前互联网</th></tr></thead><tbody><tr><td>NFT 在数字世界里是独一无二的，没有两个相同的 NFT</td><td>文件副本（如.mp3 或 .jpg）与原始文件并无二致</td></tr><tr><td>每个 NFT 必须有一个所有者，而且是一条公开记录，任何人都可以轻松核实。</td><td>数字物品的所有权记录存储在由机构控制的服务器上 - 您必须相信他们的话</td></tr><tr><td>NFT 与使用以太坊构建的任何内容都兼容交换</td><td>拥有数字产品的公司必须构建自己的基础设施。 例如，一个售卖活动数字门票的应用程序必须建立自己的门票交易所。</td></tr><tr><td>内容创建人可以在任何地方出售他们的作品，并可以进入全球市场。</td><td>创建人依靠所用平台的基础设施和分布。 这些通常受到使用条款和地理限制的制约。</td></tr><tr><td>创建人可以保留对自己作品的所有权，并直接要求收取转售版税。</td><td>音乐媒体服务等平台扣留了大部分销售利润</td></tr></tbody></table><h2 id="如何创建NFT"><a href="#如何创建NFT" class="headerlink" title="如何创建NFT"></a>如何创建NFT</h2><ul><li>NFT交易平台均可创建，如：OpenSea、Rarible、SuperRare、MakersPlace、KnowOrigin、Mintbase、Foundation、AsyncArt等。</li><li>其本质为数字资产token化，数字资产分两类：原生数字资产（如：纯数字载体艺术品）、数字化后的物理资产（如：实体油画的扫描电子版、嵌入NFC芯片的实体雕塑等）</li></ul><h2 id="NFT的应用场景和未来"><a href="#NFT的应用场景和未来" class="headerlink" title="NFT的应用场景和未来"></a>NFT的应用场景和未来</h2><ul><li>NFT有可能带来盗版保护、知识产权安全、数字身份验证系统、内容创作者收入系统、游戏、许可、证书、美术的全新世界，甚至允许拥有巨大价值的房地产的部分所有权。</li><li>数字艺术品：艺术家可以将其数字艺术品变现、游戏中创建可验证的游戏物品、游戏中创建可验证的游戏物品</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GIF</span><br><span class="line">收藏品</span><br><span class="line">音乐</span><br><span class="line">视频</span><br><span class="line">车内饰品</span><br><span class="line">真实世界活动的门票</span><br><span class="line">代币化发票</span><br><span class="line">法律文档</span><br><span class="line">签名</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;NFT是什么&quot;&gt;&lt;a href=&quot;#NFT是什么&quot; class=&quot;headerlink&quot; title=&quot;NFT是什么&quot;&gt;&lt;/a&gt;NFT是什么&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;NFT的全称为 Non-fungible Tokens（非同质化代币 ) ，&lt;strong&gt;用以</summary>
      
    
    
    
    <category term="元宇宙" scheme="https://zhulg.github.io/categories/元宇宙/"/>
    
    
    <category term="区块链" scheme="https://zhulg.github.io/tags/区块链/"/>
    
    <category term="元宇宙" scheme="https://zhulg.github.io/tags/元宇宙/"/>
    
  </entry>
  
  <entry>
    <title>元宇宙是什么有哪些应用场景</title>
    <link href="https://zhulg.github.io/posts/263.html"/>
    <id>https://zhulg.github.io/posts/263.html</id>
    <published>2022-04-28T08:17:29.000Z</published>
    <updated>2024-07-07T04:21:27.932Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-元宇宙是什么："><a href="#一-元宇宙是什么：" class="headerlink" title="一,元宇宙是什么："></a>一,元宇宙是什么：</h2><ul><li><strong>元宇宙本质上是对现实世界的虚拟化、数字化的一些列技术</strong></li><li>通过多种技术构成的一种虚拟世界和现实的映射，这些技术最主要的构成包括：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">人机交互设备</span><br><span class="line">网络传输</span><br><span class="line">芯片算力</span><br><span class="line">人工智能</span><br><span class="line">区块链</span><br><span class="line">云服务</span><br><span class="line">游戏技术</span><br><span class="line">....</span><br></pre></td></tr></table></figure><ul><li><strong>目前更多对元宇宙的探索多停留在虚拟空间和世界</strong>，但元宇宙远远不至此，更多的技术结合还在探索和落地。</li><li>在元宇宙世界里，人们可以自由穿梭于物理世界和数字世界，在虚拟空间和时间节点所构成的元宇宙中学习、工作、交友、购物、旅游等等 </li></ul><h2 id="二-元宇宙包含哪些技术："><a href="#二-元宇宙包含哪些技术：" class="headerlink" title="二,元宇宙包含哪些技术："></a>二,元宇宙包含哪些技术：</h2><ul><li><strong>（若文中图片无法显示，请科学上网查看：<a href="https://order.yizhihongxing.network/aff.php?aff=12299" target="_blank" rel="noopener">推荐工具</a>）</strong></li></ul><div align="center" width="100%">  <img width="80%" src="https://raw.githubusercontent.com/zhulg/allpic/master/%E5%85%83%E5%AE%87%E5%AE%99.jpeg"></div><h4 id="人机交互设备："><a href="#人机交互设备：" class="headerlink" title="人机交互设备："></a><em>人机交互设备：</em></h4><ul><li>这个大家很容易想到AR、VR、MR等，特别是 XR，持续迭代升级，虚拟沉浸现实体验的基础</li></ul><h4 id="网络传输："><a href="#网络传输：" class="headerlink" title="网络传输："></a><em>网络传输：</em></h4><ul><li>未来需要更强的网络传输能力包括6G等，零延迟，满足高分辨率图像和视频传输能力</li></ul><h4 id="芯片算力："><a href="#芯片算力：" class="headerlink" title="芯片算力："></a><em>芯片算力：</em></h4><ul><li>需要更多对算力满足对数据技术等软硬件能力，包括GPU 服务器、CPU、量子计算等</li></ul><h4 id="人工智能："><a href="#人工智能：" class="headerlink" title="人工智能："></a><em>人工智能：</em></h4><ul><li>这个包括机器学习、视觉处理、自然语言、知识图谱等满足人类更多智能推断和判定需求</li></ul><h4 id="区块链技术："><a href="#区块链技术：" class="headerlink" title="区块链技术："></a><em>区块链技术：</em></h4><ul><li>区块链技术满足了虚拟世界中去中心化，数字货币，智能合约等天然技术基础</li></ul><h4 id="云服务："><a href="#云服务：" class="headerlink" title="云服务："></a><em>云服务：</em></h4><ul><li>大量的数据需要云技术、云存储、边缘计算满足终端设备数据显示和存储需求</li></ul><h4 id="游戏技术"><a href="#游戏技术" class="headerlink" title="游戏技术"></a><em>游戏技术</em></h4><ul><li>新的业务场景需要游戏引擎、3D、unity技术结合构建图形化技术和沉浸式画面体验</li></ul><h2 id="三-元宇宙未来发展阶段："><a href="#三-元宇宙未来发展阶段：" class="headerlink" title="三,元宇宙未来发展阶段："></a>三,元宇宙未来发展阶段：</h2><ul><li><strong>个人认为目前的元宇宙更多在概念阶段，也包括一些通过元宇宙来概念和骗局，大家需要理清技术原理慎重投资</strong></li></ul><h3 id="1-已落地场景："><a href="#1-已落地场景：" class="headerlink" title="1.已落地场景："></a>1.已落地场景：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AR/VR 虚拟游戏</span><br><span class="line">链游</span><br><span class="line">3D网购</span><br></pre></td></tr></table></figure><h3 id="2-进展中场景："><a href="#2-进展中场景：" class="headerlink" title="2.进展中场景："></a>2.进展中场景：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">智能头盔</span><br><span class="line">虚拟场景会议</span><br><span class="line">沉浸式社交、游戏</span><br><span class="line">沉浸式娱乐、体育、健康模拟等应用</span><br><span class="line">形成人类虚拟式，面对面体验</span><br></pre></td></tr></table></figure><h3 id="3-未来场景"><a href="#3-未来场景" class="headerlink" title="3.未来场景"></a>3.未来场景</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在已有场景中包含有工作</span><br><span class="line">资产的交易</span><br><span class="line">元宇宙中角色职位</span><br><span class="line">真实世界互通、形成元宇宙社会形态</span><br></pre></td></tr></table></figure><h2 id="四-元宇宙构成和应用场景"><a href="#四-元宇宙构成和应用场景" class="headerlink" title="四,元宇宙构成和应用场景"></a>四,元宇宙构成和应用场景</h2><ul><li>通过一张图来概括元宇宙从底层技术到应用场景的构成，来更好理解元宇宙的生态和落地场景。</li><li>从技术视角也许<strong>没有创造性的技术产出</strong>，但是随着元宇宙快速发展和巨头的投入，<strong>未来一定会有创新的落地和业务</strong>，为用户提供更多的体验和便利场景。</li></ul><div align="center" width="100%">  <img width="90%" src="https://raw.githubusercontent.com/zhulg/allpic/master/%E5%85%83%E5%AE%87%E5%AE%99%E7%94%9F%E6%80%81.png"></div><h2 id="五-元宇宙的投资："><a href="#五-元宇宙的投资：" class="headerlink" title="五,元宇宙的投资："></a>五,元宇宙的投资：</h2><ul><li>目前投资大多在链游、AR\VR应用和硬件、技术投资参考大公司风向标，关注新技术。</li><li><strong>以元宇宙&amp;区块链的炒作、技术类用户慎重投资</strong></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一-元宇宙是什么：&quot;&gt;&lt;a href=&quot;#一-元宇宙是什么：&quot; class=&quot;headerlink&quot; title=&quot;一,元宇宙是什么：&quot;&gt;&lt;/a&gt;一,元宇宙是什么：&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;元宇宙本质上是对现实世界的虚拟化、数字化的一些列技术&lt;/</summary>
      
    
    
    
    <category term="元宇宙" scheme="https://zhulg.github.io/categories/元宇宙/"/>
    
    <category term="区块链" scheme="https://zhulg.github.io/categories/元宇宙/区块链/"/>
    
    
    <category term="区块链" scheme="https://zhulg.github.io/tags/区块链/"/>
    
    <category term="元宇宙" scheme="https://zhulg.github.io/tags/元宇宙/"/>
    
  </entry>
  
  <entry>
    <title> Web3是什么与区块链关系</title>
    <link href="https://zhulg.github.io/posts/55503.html"/>
    <id>https://zhulg.github.io/posts/55503.html</id>
    <published>2022-04-23T14:03:44.000Z</published>
    <updated>2024-07-07T04:21:27.926Z</updated>
    
    <content type="html"><![CDATA[<h2 id="web3是什么"><a href="#web3是什么" class="headerlink" title="web3是什么"></a>web3是什么</h2><h3 id="1-先从维基百科看Web3的解释"><a href="#1-先从维基百科看Web3的解释" class="headerlink" title="1.先从维基百科看Web3的解释:"></a>1.先从维基百科看Web3的解释:</h3><ul><li>Web 3.0是关于万维网发展的一个概念，主要与基于区块链的去中心化、加密货币以及非同质化代币有关。</li><li>区块链有关的web3概念是由以太坊联合创始人Gavin Wood于2014年提出，并于2021年受到加密货币爱好者、大型科技公司, 风险投资公司的关注Web3</li></ul><h3 id="2-对比web1-0和web2-0来理解："><a href="#2-对比web1-0和web2-0来理解：" class="headerlink" title="2. 对比web1.0和web2.0来理解："></a>2. 对比web1.0和web2.0来理解：</h3><ul><li><strong>Web 1.0 is like a one-way system.</strong> 用户只能被动地浏览文本、图片以及简单的视频内容，网站提供什么，用户查看什么。几乎没有互动可言。</li><li><strong>In Web 2.0 of the internet.</strong> 互联网开始与人互动,论坛、语音、朋友圈</li><li><strong>In Web 3.0, data will be connected in a decentralized way.</strong>  数据已去中心用户生活在互联网中</li></ul><h3 id="3-从时代规则来进行对比：（若文中图片无法显示，请科学上网查看：推荐工具）"><a href="#3-从时代规则来进行对比：（若文中图片无法显示，请科学上网查看：推荐工具）" class="headerlink" title="3.从时代规则来进行对比：（若文中图片无法显示，请科学上网查看：推荐工具）"></a>3.从时代规则来进行对比：<strong>（若文中图片无法显示，请科学上网查看：<a href="https://order.yizhihongxing.network/aff.php?aff=12299" target="_blank" rel="noopener">推荐工具</a>）</strong></h3><ul><li>Web 1.0 时代规则：<strong>平台进行创造、所有、控制、并自身受益。（早期信息网站）</strong></li><li>Web 2.0时代规则：<strong>用户来创造、平台所有和控制、平台分配。（近期比较火的自媒体、抖音短视频等）</strong></li><li>Web 3.0时代规则：<strong>用户来创造、用户所有和控制、协议分配。（归属明确，协议不可篡改，去中心化）</strong></li></ul><div align="center" width="100%">  <img width="80%" src="https://raw.githubusercontent.com/zhulg/allpic/master/web3%E5%AF%B9%E6%AF%94.png"></div><h3 id="4-对比目前Web2-0的应用来看web3-0"><a href="#4-对比目前Web2-0的应用来看web3-0" class="headerlink" title="4.对比目前Web2.0的应用来看web3.0:"></a>4.对比目前Web2.0的应用来看web3.0:</h3><div align="center" width="100%">  <img width="80%" src="https://raw.githubusercontent.com/zhulg/allpic/master/web3app.jpeg"></div><h2 id="web3与区块链的关系"><a href="#web3与区块链的关系" class="headerlink" title="web3与区块链的关系"></a>web3与区块链的关系</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.区块链是一个去中心化计算协议，区块链技术确保了数据不可篡改，明确了相关归属，具备天然的分布式数据储存</span><br><span class="line">2.在协议方面区块链有智能合约概念，通过合约，用户权利与价值的分配协议可以无需借助可信第三方。</span><br><span class="line">3.区块链技术满足了web3定义的相关规则，是一种重要的技术实现手段。</span><br></pre></td></tr></table></figure><div align="center" width="100%">  <img width="90%" src="https://github.com/zhulg/allpic/blob/master/web3chain.png?raw=true"></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;web3是什么&quot;&gt;&lt;a href=&quot;#web3是什么&quot; class=&quot;headerlink&quot; title=&quot;web3是什么&quot;&gt;&lt;/a&gt;web3是什么&lt;/h2&gt;&lt;h3 id=&quot;1-先从维基百科看Web3的解释&quot;&gt;&lt;a href=&quot;#1-先从维基百科看Web3的解释&quot;</summary>
      
    
    
    
    <category term="web3" scheme="https://zhulg.github.io/categories/web3/"/>
    
    <category term="区块链" scheme="https://zhulg.github.io/categories/web3/区块链/"/>
    
    
    <category term="区块链" scheme="https://zhulg.github.io/tags/区块链/"/>
    
    <category term="web3" scheme="https://zhulg.github.io/tags/web3/"/>
    
  </entry>
  
  <entry>
    <title>MVC/MVP/MVVM/MVI架构模式</title>
    <link href="https://zhulg.github.io/posts/9541.html"/>
    <id>https://zhulg.github.io/posts/9541.html</id>
    <published>2022-02-13T02:51:41.000Z</published>
    <updated>2024-07-07T04:21:27.925Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-MVC"><a href="#1-MVC" class="headerlink" title="1.MVC:"></a>1.MVC:</h2><div align="center" width="100%">  <img width="80%" src="https://raw.githubusercontent.com/zhulg/allpic/master/mvc.png"></div><ol><li>View 层接受输入，并送到指令到 Controller层</li><li>Controller 处理业务逻辑后，对 Model 改变状态，有时也直接更新View</li><li>Model 更新数据发送到 View，View层更新界面</li></ol><h2 id="2-MVP"><a href="#2-MVP" class="headerlink" title="2.MVP:"></a>2.MVP:</h2><div align="center" width="100%">  <img width="80%" src="https://raw.githubusercontent.com/zhulg/allpic/master/mvp.png"></div><ol><li>View 与 Model 不再进行通信</li><li>View 与 Model 通过Presenter层通信降低耦合</li><li>View层负责界面展示，Presenter层处理逻辑业务代码会变厚</li></ol><h2 id="3-MVVM："><a href="#3-MVVM：" class="headerlink" title="3.MVVM："></a>3.MVVM：</h2><div align="center" width="100%">  <img width="80%" src="https://raw.githubusercontent.com/zhulg/allpic/master/mvvm.png"></div><ol><li>View 与 Model 保持不直接通信，与MVP思想大致相同</li><li>通过绑定思想建立View层和ViewModel映射，实现界面和数据自动同步</li><li>ViewModel层多包含处理的业务逻辑，并与Model层通信</li></ol><h2 id="4-MVI"><a href="#4-MVI" class="headerlink" title="4.MVI:"></a>4.MVI:</h2><ul><li>MVI 是 <strong>Model-View-Intent</strong> 的缩写，它也是一种响应式 + 流式处理思想的架构（数据模型驱动界面）。</li></ul><div align="center" width="100%">  <img width="80%" src="https://raw.githubusercontent.com/zhulg/allpic/master/mvi.png"></div><ol><li>把用户操作，形成以<code>Intent</code>的形式，通知<code>Model</code>里对应的状态方法</li><li><code>Model</code>基于<code>Intent</code>更新<code>State</code>，保证状态逻辑的一致性</li><li><code>View</code>接收到<code>State</code>变化刷新界面层</li></ol><h3 id="Android架构中MVI与MVVM分层变动："><a href="#Android架构中MVI与MVVM分层变动：" class="headerlink" title="Android架构中MVI与MVVM分层变动："></a>Android架构中MVI与MVVM分层变动：</h3><ul><li>MVVM 代码分层的 View 和 ViewModel 在 MVI 中统一称为 UI Layer，而 Model 层在 MVI 中变成了 Data Layer。</li><li>MVI 概念中的 Model 作为状态模型，在 UI Layer 的 ViewModel 和 Data Layer 的 Repository 中分别体现为 UI State 和 Data Flow</li></ul><p><em>MVI优点:</em></p><ul><li>通<strong>过数据模型驱动界面，</strong>应用会更便于测试、更稳定可靠</li><li><strong>强调数据单向流动</strong>，容易对状态变化进行跟踪和回溯</li></ul><p><em>MVI缺点:</em></p><ul><li>所有的操作都会转换成State，所以当复杂页面的State容易膨胀</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-MVC&quot;&gt;&lt;a href=&quot;#1-MVC&quot; class=&quot;headerlink&quot; title=&quot;1.MVC:&quot;&gt;&lt;/a&gt;1.MVC:&lt;/h2&gt;&lt;div align=&quot;center&quot; width=&quot;100%&quot;&gt;
  &lt;img width=&quot;80%&quot; src=&quot;h</summary>
      
    
    
    
    <category term="Android" scheme="https://zhulg.github.io/categories/Android/"/>
    
    <category term="架构" scheme="https://zhulg.github.io/categories/Android/架构/"/>
    
    
    <category term="App" scheme="https://zhulg.github.io/tags/App/"/>
    
    <category term="架构" scheme="https://zhulg.github.io/tags/架构/"/>
    
  </entry>
  
  <entry>
    <title>iOS设备型号和名称对照</title>
    <link href="https://zhulg.github.io/posts/14423.html"/>
    <id>https://zhulg.github.io/posts/14423.html</id>
    <published>2022-01-11T12:00:05.000Z</published>
    <updated>2024-07-07T04:21:27.929Z</updated>
    
    <content type="html"><![CDATA[<ul><li>方便线上日志根据获取到的设备标示，去查找对应具体设备名称</li></ul><h1 id="iPad设备标示和设备名称对应表："><a href="#iPad设备标示和设备名称对应表：" class="headerlink" title="iPad设备标示和设备名称对应表："></a>iPad设备标示和设备名称对应表：</h1><table><thead><tr><th>iPad设备型号</th><th>设备名称</th></tr></thead><tbody><tr><td>iPad1,1</td><td>iPad</td></tr><tr><td>iPad1,2</td><td>iPad 3G</td></tr><tr><td>iPad2,1</td><td>iPad 2</td></tr><tr><td>iPad2,2</td><td>iPad 2</td></tr><tr><td>iPad2,3</td><td>iPad 2</td></tr><tr><td>iPad2,4</td><td>iPad 2</td></tr><tr><td>iPad2,5</td><td>iPad Mini</td></tr><tr><td>iPad2,6</td><td>iPad Mini</td></tr><tr><td>iPad2,7</td><td>iPad Mini</td></tr><tr><td>iPad3,1</td><td>iPad 3</td></tr><tr><td>iPad3,2</td><td>iPad 3</td></tr><tr><td>iPad3,3</td><td>iPad 3</td></tr><tr><td>iPad3,4</td><td>iPad 4</td></tr><tr><td>iPad3,5</td><td>iPad 4</td></tr><tr><td>iPad3,6</td><td>iPad 4</td></tr><tr><td>iPad4,1</td><td>iPad Air</td></tr><tr><td>iPad4,2</td><td>iPad Air</td></tr><tr><td>iPad4,3</td><td>iPad Air</td></tr><tr><td>iPad4,4</td><td>iPad Mini 2</td></tr><tr><td>iPad4,5</td><td>iPad Mini 2</td></tr><tr><td>iPad4,6</td><td>iPad Mini 2</td></tr><tr><td>iPad4,7</td><td>iPad Mini 3</td></tr><tr><td>iPad4,8</td><td>iPad Mini 3</td></tr><tr><td>iPad4,9</td><td>iPad Mini 3</td></tr><tr><td>iPad5,1</td><td>iPad Mini 4</td></tr><tr><td>iPad5,2</td><td>iPad Mini 4</td></tr><tr><td>iPad5,3</td><td>iPad Air 2</td></tr><tr><td>iPad5,4</td><td>iPad Air 2</td></tr><tr><td>iPad6,3</td><td>iPad Pro 9.7</td></tr><tr><td>iPad6,4</td><td>iPad Pro 9.7</td></tr><tr><td>iPad6,7</td><td>iPad Pro 12.9</td></tr><tr><td>iPad6,8</td><td>iPad Pro 12.9</td></tr><tr><td>iPad6,11</td><td>iPad 5</td></tr><tr><td>iPad6,12</td><td>iPad 5</td></tr><tr><td>iPad7,1</td><td>iPad Pro 12.9 inch 2nd gen</td></tr><tr><td>iPad7,2</td><td>iPad Pro 12.9 inch 2nd gen</td></tr><tr><td>iPad7,3</td><td>iPad Pro 10.5 inch</td></tr><tr><td>iPad7,4</td><td>iPad Pro 10.5 inch</td></tr><tr><td>iPad7,5</td><td>iPad 6</td></tr><tr><td>iPad7,6</td><td>iPad 6</td></tr><tr><td>iPad7,11</td><td>iPad 7</td></tr><tr><td>iPad7,12</td><td>iPad 7</td></tr><tr><td>iPad8,1 ~ 8,4</td><td>iPad Pro 11-inch</td></tr><tr><td>iPad8,5 ~ 8,8</td><td>iPad Pro 12.9-inch 3rd gen</td></tr><tr><td>iPad8,9 ~ 8,10</td><td>iPad Pro 11-inch 2nd gen</td></tr><tr><td>iPad8,11 ~ 8,12</td><td>iPad Pro 12.9-inch 4th gen</td></tr><tr><td>iPad11,1</td><td>iPad Mini 5</td></tr><tr><td>iPad11,2</td><td>iPad Mini 5</td></tr><tr><td>iPad11,3</td><td>iPad Air 3</td></tr><tr><td>iPad11,4</td><td>iPad Air 3</td></tr><tr><td>iPad11,6</td><td>iPad 8</td></tr><tr><td>iPad11,7</td><td>iPad 8</td></tr><tr><td>iPad13,1</td><td>iPad Air 4</td></tr><tr><td>iPad13,2</td><td>iPad Air 4</td></tr><tr><td>iPad12,1</td><td>iPad 9</td></tr><tr><td>iPad12,2</td><td>iPad 9</td></tr><tr><td>iPad14,1</td><td>iPad Mini 6</td></tr><tr><td>iPad14,2</td><td>iPad Mini 6</td></tr><tr><td>iPad13,4 ~ 13,7</td><td>iPad Pro 11-inch 3nd gen</td></tr><tr><td>iPad13,8 ~ 13,11</td><td>iPad Pro 12.9-inch 5th gen</td></tr><tr><td></td><td></td></tr></tbody></table><h1 id="手机型号对应表："><a href="#手机型号对应表：" class="headerlink" title="手机型号对应表："></a>手机型号对应表：</h1><table><thead><tr><th>iphone对应型号</th><th>名称</th></tr></thead><tbody><tr><td>iPhone3,1</td><td>iPhone 4</td></tr><tr><td>iPhone3,2</td><td>iPhone 4</td></tr><tr><td>iPhone3,3</td><td>iPhone 4</td></tr><tr><td>iPhone4,1</td><td>iPhone 4S</td></tr><tr><td>iPhone5,1</td><td>iPhone 5</td></tr><tr><td>iPhone5,2</td><td>iPhone 5</td></tr><tr><td>iPhone5,3</td><td>iPhone 5c</td></tr><tr><td>iPhone5,4</td><td>iPhone 5c</td></tr><tr><td>iPhone6,1</td><td>iPhone 5s</td></tr><tr><td>iPhone6,2</td><td>iPhone 5s</td></tr><tr><td>iPhone7,1</td><td>iPhone 6 Plus</td></tr><tr><td>iPhone7,2</td><td>iPhone 6</td></tr><tr><td>iPhone8,1</td><td>iPhone 6s</td></tr><tr><td>iPhone8,2</td><td>iPhone 6s Plus</td></tr><tr><td>iPhone8,4</td><td>iPhone SE</td></tr><tr><td>iPhone9,1</td><td>iPhone 7</td></tr><tr><td>iPhone9,2</td><td>iPhone 7 Plus</td></tr><tr><td>iPhone9,3</td><td>iPhone 7</td></tr><tr><td>iPhone9,4</td><td>iPhone 7 Plus</td></tr><tr><td>iPhone10,1</td><td>iPhone 8</td></tr><tr><td>iPhone10,2</td><td>iPhone 8 Plus</td></tr><tr><td>iPhone10,4</td><td>iPhone 8</td></tr><tr><td>iPhone10,5</td><td>iPhone 8 Plus</td></tr><tr><td>iPhone10,3</td><td>iPhone X</td></tr><tr><td>iPhone10,6</td><td>iPhone X</td></tr><tr><td>iPhone11,2</td><td>iPhone XS</td></tr><tr><td>iPhone11,4</td><td>iPhone XS Max</td></tr><tr><td>iPhone11,6</td><td>iPhone XS Max</td></tr><tr><td>iPhone11,8</td><td>iPhone XR</td></tr><tr><td>iPhone12,1</td><td>iPhone 11</td></tr><tr><td>iPhone12,3</td><td>iPhone 11 Pro</td></tr><tr><td>iPhone12,5</td><td>iPhone 11 Pro Max</td></tr><tr><td>iPhone12,8</td><td>iPhone SE 2</td></tr><tr><td>iPhone13,1</td><td>iPhone 12 mini</td></tr><tr><td>iPhone13,2</td><td>iPhone 12</td></tr><tr><td>iPhone13,3</td><td>iPhone 12 Pro</td></tr><tr><td>iPhone13,4</td><td>iPhone 12 Pro Max</td></tr><tr><td>iPhone14,4</td><td>iPhone 13 mini</td></tr><tr><td>iPhone14,5</td><td>iPhone 13</td></tr><tr><td>iPhone14,2</td><td>iPhone 13 Pro</td></tr><tr><td>iPhone14,3</td><td>iPhone 13 Pro Max</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;方便线上日志根据获取到的设备标示，去查找对应具体设备名称&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;iPad设备标示和设备名称对应表：&quot;&gt;&lt;a href=&quot;#iPad设备标示和设备名称对应表：&quot; class=&quot;headerlink&quot; title=&quot;iPad设备标示和</summary>
      
    
    
    
    <category term="ios" scheme="https://zhulg.github.io/categories/ios/"/>
    
    
    <category term="ios" scheme="https://zhulg.github.io/tags/ios/"/>
    
  </entry>
  
  <entry>
    <title>技术开发流程</title>
    <link href="https://zhulg.github.io/posts/26749.html"/>
    <id>https://zhulg.github.io/posts/26749.html</id>
    <published>2021-09-12T15:20:34.000Z</published>
    <updated>2024-07-07T04:21:27.933Z</updated>
    
    <content type="html"><![CDATA[<h2 id="技术开发流程"><a href="#技术开发流程" class="headerlink" title="技术开发流程"></a>技术开发流程</h2><ul><li>产品研发过程中，涉及到技术实现环节的相关流程梳理的梳理是非常重要的，在多年的技术管理过程中一直实践并不断总结和完善开发流程、管理方法论。</li><li>相关的方法论也是经过验证在产品交付、项目把控、人员能力提升等环节都有非常好的使用价值。</li><li><strong>技术管理和技术开发流程没有一成不变，只有最适合自己团队发展现状的管理方法</strong>。</li></ul><h3 id="1-图解流程"><a href="#1-图解流程" class="headerlink" title="1.图解流程"></a>1.图解流程</h3><p><img src="https://raw.githubusercontent.com/zhulg/allpic/master/jishu.jpg" alt></p><h3 id="2-核心阶段："><a href="#2-核心阶段：" class="headerlink" title="2.核心阶段："></a>2.核心阶段：</h3><ul><li>第一阶段，研发需要对业务进行深度体验，吃透业务场景，分析里面使用技术，形成基于业务场景的技术选型和架构。</li><li>第二阶段，在产品人员进行业务设计阶段，研发需要开始着手搭建，不基于产品层面的所有底层基础技术。</li><li>第三阶段，在产品评审完成研发任务后，进入开发阶段，研发需要提供排期和项目里程碑点，预留技术buffer时间和备选方案，里程碑验收。</li></ul><h3 id="3-版本迭代规范："><a href="#3-版本迭代规范：" class="headerlink" title="3.版本迭代规范："></a>3.版本迭代规范：</h3><ul><li>版本迭代基本规范，遵循大小版本，大功能点提前准备，隔版本上线，小版本当前版本上线。</li><li>版本迭代中，除产品需求外，默认包括线上问题bugfix ,性能优化，代码完善，研发排期需要预留时间。</li><li>隔代版本技术预研，要在版本迭代中研发提前安排进入预言阶段，确保隔代版本能进入下版本上线。</li></ul><h3 id="4-研发核心遵守："><a href="#4-研发核心遵守：" class="headerlink" title="4.研发核心遵守："></a>4.研发核心遵守：</h3><ul><li>预研先行，提前储备</li><li>技术实现，遵循产品需求，业务评审文档</li><li>代码编写，遵循通用及各端语言规范，入库review流程</li><li>需求变动，知会到负责人（产品&amp;技术），并要明确确认和风险</li><li>技术文档，记录研发过程技术实现相关设计，时序图等，达到第2人能交接标准</li><li>跟踪文档，记录每个版本产品需求、技术、优化改动的，提测前知会QA，协助验收。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;技术开发流程&quot;&gt;&lt;a href=&quot;#技术开发流程&quot; class=&quot;headerlink&quot; title=&quot;技术开发流程&quot;&gt;&lt;/a&gt;技术开发流程&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;产品研发过程中，涉及到技术实现环节的相关流程梳理的梳理是非常重要的，在多年的技术管理过程中一直实</summary>
      
    
    
    
    <category term="管理杂烩" scheme="https://zhulg.github.io/categories/管理杂烩/"/>
    
    
    <category term="管理杂烩" scheme="https://zhulg.github.io/tags/管理杂烩/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统安装rvm管理rbuy版本</title>
    <link href="https://zhulg.github.io/posts/17705.html"/>
    <id>https://zhulg.github.io/posts/17705.html</id>
    <published>2021-09-12T14:34:48.000Z</published>
    <updated>2024-07-07T04:21:27.930Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ruby使用"><a href="#ruby使用" class="headerlink" title="ruby使用"></a>ruby使用</h3><ul><li>ruby是个面向对象的脚本语言，相对比较小众使用，随着python的兴起。但是对应工具类的使用还是占有一席之地，使用也比较广泛很多创业公司也在只用。</li></ul><h3 id="rvm是管理ruby的版本"><a href="#rvm是管理ruby的版本" class="headerlink" title="rvm是管理ruby的版本"></a>rvm是管理ruby的版本</h3><ul><li>rvm类似node的nvm，方便管理对版本的管理和使用切换。由于ruby是不经常使用，<strong>现用现学，快速解决问题，ruby也更简洁符合人类思维</strong>。最近工具类使用了下对后续使用快速搭建环境做个简单的记录，后续能快速恢复知识和使用。</li></ul><h4 id="安装rvm"><a href="#安装rvm" class="headerlink" title="安装rvm"></a>安装rvm</h4><ul><li><p>1.可能会失败、按指示进行或者重复几次，依赖网络和翻墙情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L get.rvm.io | bash -s stable</span><br></pre></td></tr></table></figure></li><li><p>2 . 查看rvm安装情况, 并生效配置其中的配置项  source /usr/local/rvm/scripts/rvm</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -name rvm</span><br></pre></td></tr></table></figure><ul><li><ol start="3"><li>查看版本情况（可能你需要特定的版本安装）</li></ol></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rvm list known</span><br></pre></td></tr></table></figure><ul><li><ol start="4"><li>安装版本ruby（从上边选择你期望的版本）</li></ol></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rvm install  xxx</span><br></pre></td></tr></table></figure><ul><li><ol start="5"><li>使用版本ruby</li></ol></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rvm use  xxx</span><br></pre></td></tr></table></figure><h3 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;ruby使用&quot;&gt;&lt;a href=&quot;#ruby使用&quot; class=&quot;headerlink&quot; title=&quot;ruby使用&quot;&gt;&lt;/a&gt;ruby使用&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;ruby是个面向对象的脚本语言，相对比较小众使用，随着python的兴起。但是对应工具类的使用还</summary>
      
    
    
    
    <category term="Ruby" scheme="https://zhulg.github.io/categories/Ruby/"/>
    
    
    <category term="Ruby" scheme="https://zhulg.github.io/tags/Ruby/"/>
    
  </entry>
  
</feed>

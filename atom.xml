<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zhulg笔记</title>
  
  <subtitle>兴趣是最好的老师，其次是耻辱</subtitle>
  <link href="https://zhulg.github.io/atom.xml" rel="self"/>
  
  <link href="https://zhulg.github.io/"/>
  <updated>2024-08-18T05:51:25.041Z</updated>
  <id>https://zhulg.github.io/</id>
  
  <author>
    <name>zhulg</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2024年客户端、前端开发，这些赛道值得你关注</title>
    <link href="https://zhulg.github.io/posts/9826b570.html"/>
    <id>https://zhulg.github.io/posts/9826b570.html</id>
    <published>2024-08-19T05:43:25.000Z</published>
    <updated>2024-08-18T05:51:25.041Z</updated>
    
    <content type="html"><![CDATA[<p>首先，这篇文章没有任何广告，只是给目前前端开发、客户端开发伙伴们的一些个人思考和建议。</p><p>前几年，移动互联网如火如荼，给大家在吃住行方面带来了巨大的便利，也改变了大家的生活方式。外卖、打车、支付、金融等应用极大地方便了人们的日常生活。</p><p>特别是客户端开发的岗位，前几年由于开发需求旺盛，薪资非常可观。但随着移动APP生态的完善，APP的需求也接近饱和，进入了维护期。许多资深前端工程师、客户端Android、iOS、Flutter工程师由于种种原因，职业发展也进入了瓶颈期。一方面担心失业问题，另一方面市场上的新岗位也不如以前多。</p><p><strong>人通常都是有惰性的，即便知道这个行业在走下坡路，可能还是不好轻易的做出改变和尝试新赛道</strong></p><p>确实转型新赛道来进行开发，也有一些学习成本，那我们要尽可能选择适合自己的技术栈，能快速切入的一些领域。</p><p><strong>先尝试的学习和用起来，看看实际写起来是怎么样子的，了解岗位薪资和赛道人数。</strong></p><p>就比如之前做J2EE(现在很少听这个名字了)开发大火时期，业余里进行了Android、iOS研究，没想到在1-2年内业余薪资迅速远远超过了主业工资2倍，且大量移动岗位冒出，那怎么办，放弃J2EE,  顺应时代趋势来开发啊。</p><p>目前，互联网可以说处于Web3.0阶段，这个时期或未来的发展如何，可以看到的是区块链和大模型AI行业。今天先看一下前端和客户端技术人员在区块链行业有哪些可以做的事情。</p><p>这里的区块链指的是区块链相关的开发岗位有哪些可以切入的，也是政府支持和开展的 图片引用：<a href="https://www.gov.cn/" target="_blank" rel="noopener">https://www.gov.cn/</a></p><p><a href="https://www.gov.cn/lianbo/bumen/202401/content_6925730.htm" target="_blank" rel="noopener">2025年初步形成支撑区块链发展标准体系</a></p><p><a href="https://www.gov.cn/lianbo/difang/202405/content_6952135.htm" target="_blank" rel="noopener">上海启动首批国资国企区块链创新应用场景建设</a></p><p><strong>区块链技术是一种分布式账本技术，可以让信息记录更加安全、透明和不可篡改</strong>。从官方发布的信息看，技术可以应用于许多领域，比如共识机制、分布式应用、智能合约、数据上链等。</p><p>那适合前端和客户端开发，又比较好进行切入，或者可以先尝试起来的区块链开发岗都有哪些，薪资如何，我觉得可以从这些方面进行尝试：</p><h3 id="DAPP开发"><a href="#DAPP开发" class="headerlink" title="DAPP开发"></a>DAPP开发</h3><p> 如果你是做前端开发的JavaScript、React、vue不在话下，那可以直接来构建DApp的前端部分，并结合Web3.js或Ethers.js进行智能合约交互。<strong>Web3.js</strong> 用于与以太坊区块链进行交互，支持发送交易、调用智能合约等操作。<strong>Ethers.js</strong> 功能类似于Web3.js，但更加现代化和模块化。</p><p>如果你是客户端开发其实也可以进行DAPP来开发，通过WalletConnect协议，开发支持移动设备的DApp开发，这些都可以沿用一些移动开发的经验。与智能合约进行交互，这部分学习和你在移动开发中与后端API交互的经验相似。</p><h3 id="智能合约开发"><a href="#智能合约开发" class="headerlink" title="智能合约开发"></a><strong>智能合约开发</strong></h3><p>无论前端还是客户端如果接触了区块链还可以进行智能合约的开发，可以理解它是自动执行合约条款的代码，运行在区块链上，确保交易的透明和安全。</p><p>智能合约编写语言，主要有Solidity：是太坊及其兼容区块链平台，Rust ：用于Polkadot、Solana区块链平台的智能合约开发，这个可能需要学习一下Solidity, rust语言了。</p><p>如果是前端和客户端开发，这2个语言学习起来还是比较容易的，语法也比较类似 Solidity也有JavaScript的借鉴，rust也是跟kotlin、swift有相似之处。</p><h3 id="其他区块链开发"><a href="#其他区块链开发" class="headerlink" title="其他区块链开发"></a><strong>其他区块链开发</strong></h3><p>还有一些区块链的其他开发方向，比如共识算法、公链开发等。这些需要较高的技术功底，涉及密码学和安全学，可能不太适合目前前端、客户端开发的技术基础。</p><p><strong>DAPP开发和智能合约开发比较适合前端、客户端开发人员尝试切换赛道、可以在业余时间进行学习和研究，而且行业薪资待遇不错，业内人数也不拥挤。</strong>长远看，这是一种技术趋势和应用创新，从上方官方新闻也可以看的出。</p><h2 id="思考总结"><a href="#思考总结" class="headerlink" title="思考总结"></a><strong>思考总结</strong></h2><p>以上就是对前端、客户端开发，比较低成本切换到区块链岗位赛道的建议，可以业余尝试和了解，多学总是没有坏处的。</p><p>技术不是一成不变的，业务需求也是一直变革，前端、客户端开发还是要做好未雨绸缪提升自己技术力。</p><p>切换技术赛道和岗位时，还是要结合自身的技术栈来适应技术潮流，提升竞争力，拓宽自己的岗位选择。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;首先，这篇文章没有任何广告，只是给目前前端开发、客户端开发伙伴们的一些个人思考和建议。&lt;/p&gt;
&lt;p&gt;前几年，移动互联网如火如荼，给大家在吃住行方面带来了巨大的便利，也改变了大家的生活方式。外卖、打车、支付、金融等应用极大地方便了人们的日常生活。&lt;/p&gt;
&lt;p&gt;特别是客户端</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>技术管理，要用人之长</title>
    <link href="https://zhulg.github.io/posts/34ec9bec.html"/>
    <id>https://zhulg.github.io/posts/34ec9bec.html</id>
    <published>2024-08-18T04:44:11.000Z</published>
    <updated>2024-08-18T05:23:05.990Z</updated>
    
    <content type="html"><![CDATA[<p><strong>在技术团队的管理中，我们常常希望团队能够更符合自己的价值观，在用人方面也更倾向于选择与自己脾气秉性相投的人。</strong></p><p>这种想法很自然，但它也容易让管理者掉入一个陷阱：总是想尽办法去改变团队成员的某个“缺点”，试图让团队成员在性格上趋于一致。然而，这样的团队往往缺少灵气，而改变的结果也常常适得其反。（这里所说的“缺点”，并不是指这些人能力不足或不能胜任工作，而更多是每个人独特的特点或性格因素。）</p><p><strong>自己之前也犯过类似错误，随着团队管理经验磨炼，我们要发挥团队最大战斗力，最重要的在于发现和利用团队成员的长处，而不是执着于修补他们的短板。</strong></p><h2 id="从“改造人”到“成就人”"><a href="#从“改造人”到“成就人”" class="headerlink" title="从“改造人”到“成就人”"></a>从“改造人”到“成就人”</h2><p>技术团队就像一片森林，每棵树都有自己的形状和特点。有的高大挺拔，有的矮小结实，各有各的用处。作为技术管理者，你是选择硬生生地把这些树都修剪成一样的模样，还是让它们各自生长，发挥所长？</p><p>当你试图改变某个工程师的短处，比如让一个不擅长沟通的人变得能说会道，你可能会发现，这个过程不仅让他痛苦，也让你头疼。因为短板往往是根深蒂固的特质，并不容易被改变。结果，搞不好你花了大力气，他却失去了本来的优势——那个他最擅长的领域反倒退步了。</p><p>试图改造别人，往往是一条崎岖不平的路。与其逼迫每个人去做自己不擅长的事，不如看看他们究竟有什么特长，然后把这些特长发挥出来。这样，你不仅能看到更好的结果，团队的士气也会随之提升。</p><h2 id="现实例子"><a href="#现实例子" class="headerlink" title="现实例子"></a>现实例子</h2><p>说到管理团队，举个例子，如果做为管理者带过团队，你可能也有共鸣，比如有两位主管，A和B。他们的管理方式截然不同。</p><p>A主管是个严谨的人，凡事都喜欢亲力亲为。他的团队成员几乎没有什么决策空间，因为A主管总是喜欢把关每个细节。他常常告诉团队成员：“你这样不行，那样也不对。有些可能也是自己不擅长的领域，但成员碍于面子不想反驳，久而久之，团队里的人都觉得压力山大，干劲儿被磨得差不多了，创新的火花也渐渐熄灭了。（某种程度的一言堂）</p><p>B主管呢，他的做法则显得更加轻松。他会先了解每个团队成员的优点，然后有针对性地安排任务。B主管喜欢说：“你在这方面很有一套，试试看能不能搞出点新东西。”在他的团队里，大家自由发挥，气氛活跃。于是，团队成员的积极性高了，项目进度和质量也都相当不错。</p><p>两个不同的管理方式，带来了截然不同的结果。A主管执着于修正下属的缺点，结果使得团队士气低落，项目进展不顺；而B主管则注重挖掘和利用下属的长处，团队反而呈现出一片生机勃勃的景象。</p><h2 id="用人之长提升团队"><a href="#用人之长提升团队" class="headerlink" title="用人之长提升团队"></a>用人之长提升团队</h2><p>作为技术管理者，你的任务不仅仅是指挥和监督，更重要的是发现团队成员的优势，并把这些优势最大化。一个好的管理者，像是一名园丁，懂得如何修剪树木让它们更好地生长，而不是强迫它们长成同一个模样。</p><p>在识别团队成员的长处时，要多观察他们的工作表现，听听他们对工作的想法和建议。有人喜欢钻研技术，有人擅长团队协作，还有人对项目管理得心应手。找到这些优势后，你要做的就是把他们放在合适的位置上，让他们在擅长的领域内发光发热。</p><p>举个例子，对于那些技术能力超强的工程师，给他们挑战性的任务，同时提供一定的自由度，让他们可以发挥创造力。而对于那些沟通能力强的成员，可以让他们负责跨部门的协调工作，确保团队和其他部门的顺畅合作。</p><h2 id="用人之长提升管理"><a href="#用人之长提升管理" class="headerlink" title="用人之长提升管理"></a>用人之长提升管理</h2><p>技术管理是一门艺术，而不是一门科学。管理者的职责，不是强行让每个成员变得“完美”，而是要发现每个人的长处，并加以利用。就像一支乐队，各种乐器各司其职，才能奏出和谐的乐章。</p><p>当你放下改造他人的执念，(只要不是他无法胜任问题)，都应转而专注于如何让每个人都在自己擅长的领域发光，你会发现，团队的效率提高了，氛围也好了。这样的团队，不仅能在技术上有所突破，更能在项目中取得成功。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;在技术团队的管理中，我们常常希望团队能够更符合自己的价值观，在用人方面也更倾向于选择与自己脾气秉性相投的人。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这种想法很自然，但它也容易让管理者掉入一个陷阱：总是想尽办法去改变团队成员的某个“缺点”，试图让团队成员在性格上趋于</summary>
      
    
    
    
    <category term="技术成长" scheme="https://zhulg.github.io/categories/技术成长/"/>
    
    
    <category term="技术成长" scheme="https://zhulg.github.io/tags/技术成长/"/>
    
  </entry>
  
  <entry>
    <title>告别焦虑，技术人的“慢功夫”哲学</title>
    <link href="https://zhulg.github.io/posts/fe63084d.html"/>
    <id>https://zhulg.github.io/posts/fe63084d.html</id>
    <published>2024-08-17T10:25:01.000Z</published>
    <updated>2024-08-17T10:38:54.080Z</updated>
    
    <content type="html"><![CDATA[<h1 id="告别焦虑，技术人的“慢功夫”哲学"><a href="#告别焦虑，技术人的“慢功夫”哲学" class="headerlink" title="告别焦虑，技术人的“慢功夫”哲学"></a><strong>告别焦虑，技术人的“慢功夫”哲学</strong></h1><p>我们现在处一个快节奏的时代，每一个行业都在高速发展，我们也常常被告知要抓住每一个机会，快速成长，迅速成功。但对许多技术人来说，所谓的“快”，有时反而会让我们失去平衡，陷入焦虑和迷茫， 常常又进入事倍功半的困境。</p><p>之前遇到过一位刚入行不久的年轻技术人，他一脸焦虑地问我：“如果我现在不快点提高，是不是以后就没机会了？他同事只比他大1岁就已经P7了，心里充满了压力，害怕自己到那个年龄也达不到P7。。。担心自己成长太慢了。</p><p>这种情况并不罕见。在技术领域，很多人都经历过类似的心境：希望自己能够迅速成功，但现实却常常让人感到沮丧。</p><p>我觉得真正的成功往往需要时间的积累和经验的沉淀，不要忽略重要的职业成长哲学——“慢功夫”。</p><h3 id="什么是“慢功夫”？"><a href="#什么是“慢功夫”？" class="headerlink" title="什么是“慢功夫”？"></a><strong>什么是“慢功夫”？</strong></h3><p>我觉得“慢功夫”并不是指要拖延时间，而是一种深刻的成长观念。</p><p>我们在职业发展中，有些人技术人能早早财务自由，有些能有好的机会进入大厂，这里面有自身的能力和努力，但也一定有运气，所以不要焦虑自己没能达到一定的薪资，没有进入好的大厂，一定要有自己的节奏，时间的积累和持续的努力才是成功的关键，更要从内心坚定自己。</p><h3 id="从内心摆脱焦虑"><a href="#从内心摆脱焦虑" class="headerlink" title="从内心摆脱焦虑"></a><strong>从内心摆脱焦虑</strong></h3><p>如前面说到的例子，很多技术人知道这行前期薪资高付出也需要多，而在职业初期都会面临巨大的压力，他们常常担心，如果在毕业后的头几年没有迅速提升自己，那么未来的职业生涯将会受到严重影响。这种焦虑感让他们在短时间内急于求成，结果往往是事倍功半，甚至可能导致职业倦怠。</p><p>摆脱这种焦虑的有效方法之一就是接受“慢功夫”的哲学。认识到成功需要时间，并且在职业发展中保持耐心，会帮助你在长期中找到自己的节奏。</p><p>真正的技术成就往往不是一蹴而就，而是经过不断的实践和学习才，还有运气，在运气没来之前只管坚持正确的努力，从内心要认定这件事。</p><p>慢慢地，你会发现，职业的高度并不完全取决于短期的表现，而是源于持续的积累和深度的成长。</p><h3 id="选择合适的榜样"><a href="#选择合适的榜样" class="headerlink" title="选择合适的榜样"></a><strong>选择合适的榜样</strong></h3><p>在职业发展过程中，</p><p>在寻找职业发展的方向时，选择合适的榜样至关重要。不要过分崇拜那些在年轻时就取得巨大成功的偶像。虽然他们的成就令人钦佩，但这种极端个例并不适用于每个人。</p><p>相反，选择一些经历丰富、成功稳重的前辈作为榜样会更有帮助。例如，巴菲特和芒格等人虽然在年轻时并未显著成名，但他们的职业生涯却是通过长期的积累和稳步的前行获得成功的。这样的榜样能够给予你更为实际的职业发展思路，帮助你在漫长的职业道路上保持坚定的信心。</p><h3 id="一些慢功夫个人建议"><a href="#一些慢功夫个人建议" class="headerlink" title="一些慢功夫个人建议"></a><strong>一些慢功夫个人建议</strong></h3><p><strong>1. 一天一点，慢慢积累：</strong><br>不用急着去掌握所有新技术，也不用担心自己今天还不够“厉害”。每天学习一点新东西，哪怕只是一个新函数、一段代码优化，日积月累，你会发现自己其实进步了很多。关键是保持好奇心和学习的动力，慢慢来，一切都会水到渠成。</p><p><strong>2. 给自己留点喘息的时间：</strong><br>工作不是马拉松，一口气跑到终点可不是好主意。每天工作之余，给自己留点休息的时间，哪怕只是出门散散步、泡杯咖啡，都是让大脑放松的好方法。要知道，休息也是一种生产力，反而能让你在工作中更加高效。</p><p><strong>3. 别急着和别人比：</strong><br>你周围可能有一些同事看起来特别牛，年纪轻轻就拿到了高薪或升职。这种时候，别让自己陷入“别人的成功就是自己的失败”这种心态里。每个人都有自己的节奏，有些人跑得快，有些人走得稳，而最后能坚持到终点的，往往是那些知道自己步伐的人。</p><p><strong>4. 坚持做让自己有成就感的事：</strong></p><p>这点科学家颜宁在一个采访视频里也提到过，她也是这样的，要用一点点的成就感正向激励自己，这点比较重要。在工作中找到一些让自己感到开心、有成就感的事情。可能是解决了一个困扰已久的bug，或者是学会了一个新技术。只要你能从工作中找到这种“小确幸”，你就会慢慢培养出对工作的热爱，而这种热爱，会成为你持续前进的动力。</p><p><strong>5. 给未来留点耐心：</strong><br>成功不是今天努力，明天就立刻能看到结果的事情。要相信，时间会给你回报。那些看似微不足道的努力，日后都会转化为你的竞争力。所以，给自己多点耐心，稳步前进，你会发现，未来的路其实会越走越宽。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然我前面提到过，“慢功夫”要坚持并等待机会，但并不意味着就等机会来敲门，它更像是一种有意识的选择——不慌不忙地提升自己，在每一步中都积累经验。</p><p>成功就像是一道慢火煮的好菜，需要时间来慢慢熬制。与其急功近利，不如踏踏实实地专注于眼前的每一项技能，不断学习，积累经验。给自己设立一个长期的目标，培养出足够的耐心，关注自己的成长，这样才能在未来的职业道路上走得更稳、更远。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;告别焦虑，技术人的“慢功夫”哲学&quot;&gt;&lt;a href=&quot;#告别焦虑，技术人的“慢功夫”哲学&quot; class=&quot;headerlink&quot; title=&quot;告别焦虑，技术人的“慢功夫”哲学&quot;&gt;&lt;/a&gt;&lt;strong&gt;告别焦虑，技术人的“慢功夫”哲学&lt;/strong&gt;&lt;/h1&gt;</summary>
      
    
    
    
    <category term="技术成长" scheme="https://zhulg.github.io/categories/技术成长/"/>
    
    
    <category term="技术成长" scheme="https://zhulg.github.io/tags/技术成长/"/>
    
  </entry>
  
  <entry>
    <title>全栈工程师-基础：共识算法知多少</title>
    <link href="https://zhulg.github.io/posts/68935246.html"/>
    <id>https://zhulg.github.io/posts/68935246.html</id>
    <published>2024-07-30T15:30:59.000Z</published>
    <updated>2024-07-30T15:33:38.165Z</updated>
    
    <content type="html"><![CDATA[<p>共识算法，简单理解是通过算法让参与其中成员共同达成共识。</p><p>在计算机里共识算法主要在分布式系统中通过参与之中的节点，对数据或者状态达成一致的方法。</p><p>那是不是可以理解为参与人，按照认可的规则来就好。</p><p>你可能会想到，那石头剪刀布游戏，参与方也认同这个规则算法，这个算不算共识算法？</p><p>不算。</p><p>虽然它涉及多个参与者之间的决策过程，但它的目的是决定一个赢家，而不是在分布式系统中达成一致的状态。</p><h2 id="共识算法强调什么"><a href="#共识算法强调什么" class="headerlink" title="共识算法强调什么"></a>共识算法强调什么</h2><ul><li><strong>一致性</strong>：确保所有节点在任何时间点都能对某一状态或数据达成一致。</li><li><strong>容错性</strong>：能够容忍一定数量的节点故障或恶意节点的存在，并且系统仍然能够正常运行。</li><li><strong>去中心化</strong>：没有单一的控制节点，所有节点都平等参与共识过程。</li><li><strong>安全性</strong>：防止恶意节点的攻击，确保数据的完整性和不可篡改性。</li></ul><p>其实这些核心也正是在分布式系统里的最基本保障。</p><p>有了大概的理解和概念后，看看现在常用的共识算法都有哪些，这些共识算法不会进行详细展开，因为每一种共识算法，都有复杂的算法基础和相关论文支持，根据汇总的常用算法可以进行深入论文学习。</p><h2 id="共识算法有哪些"><a href="#共识算法有哪些" class="headerlink" title="共识算法有哪些"></a>共识算法有哪些</h2><h3 id="工作量证明（PoW）："><a href="#工作量证明（PoW）：" class="headerlink" title="工作量证明（PoW）："></a><strong>工作量证明（PoW）</strong>：</h3><ul><li>参与者通过解决复杂问题（如数学难题）来证明他们的工作量，从而获得权利执行某些操作。这种方法确保系统不易被攻击。</li><li>例如用于防止垃圾邮件和保护分布式网络的安全性。</li></ul><h3 id="权益证明（PoS）："><a href="#权益证明（PoS）：" class="headerlink" title="权益证明（PoS）："></a><strong>权益证明（PoS）</strong>：</h3><ul><li>持有更多资源（通常是加密货币）的用户，拥有更大的影响力和决策权。这种方法可以确保系统参与者有利益维护系统的稳定和安全。</li><li>最常见应用于加密货币的区块链网络中，如以太坊的Casper协议，通过持有以太币来参与验证和安全维护网络。</li></ul><h3 id="委托权益证明（DPoS）："><a href="#委托权益证明（DPoS）：" class="headerlink" title="委托权益证明（DPoS）："></a>委托<strong>权益证明（DPoS）</strong>：</h3><ul><li>用户通过投票选出少数代表（通常是验证者）来执行决策，以提高系统的效率和扩展性。</li><li><strong>应用场景例子</strong>：用于去中心化的社交媒体平台，如Steemit，用户可以通过持有代币来投票选择内容和平台发展方向的代表。</li></ul><h3 id="拜占庭容错（BFT）："><a href="#拜占庭容错（BFT）：" class="headerlink" title="拜占庭容错（BFT）："></a><strong>拜占庭容错（BFT）</strong>：</h3><ul><li>系统通过多轮投票确保即使在存在恶意节点的情况下也能达成一致，增强系统的安全性和可靠性。</li><li>广泛用于航空航天、军事和金融领域的分布式系统，确保在存在恶意节点的情况下系统仍能正常运行。</li></ul><h3 id="实用拜占庭容错（PBFT）："><a href="#实用拜占庭容错（PBFT）：" class="headerlink" title="实用拜占庭容错（PBFT）："></a><strong>实用拜占庭容错（PBFT）</strong>：</h3><ul><li>预选的节点通过多轮投票快速达成共识，适用于需要高效和低延迟的分布式系统。</li><li><strong>应用场景例子</strong>：企业内部的分布式数据库管理系统，如Ripple的XRP Ledger，通过PBFT算法快速确认和执行跨国支付交易。</li></ul><p>以下这几个更多用在区块链相关的共识算法上，可以稍微了解下证明容量（PoC）、证明燃烧（PoB）和证明时间和空间（PoST）是共识算法，通过提供存储空间、销毁资源或等待时间来获得操作权。PoC鼓励资源共享，PoB减少资源供应防止滥用，PoST结合存储和时间增加系统安全性，确保资源公平分配。这些算法在区块链和其他分布式系统中广泛应用，如分布式存储、在线服务和云存储。</p><p>如前面介绍，共识算法的核心是确保分布式系统中各个节点达成一致，即使有部分节点可能出现故障或恶意行为，基于这些特性，常常在区块链、分布式数据库、云存储等领域使用。有这么一个基础，对后续一些共识领域的理解还是很有帮助的，当然每一个共识算法在具体应用中都需要深入研究和学习，我们文中介绍更多还是先有个核心原理和概念的认知。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;共识算法，简单理解是通过算法让参与其中成员共同达成共识。&lt;/p&gt;
&lt;p&gt;在计算机里共识算法主要在分布式系统中通过参与之中的节点，对数据或者状态达成一致的方法。&lt;/p&gt;
&lt;p&gt;那是不是可以理解为参与人，按照认可的规则来就好。&lt;/p&gt;
&lt;p&gt;你可能会想到，那石头剪刀布游戏，参与</summary>
      
    
    
    
    <category term="区块链" scheme="https://zhulg.github.io/categories/区块链/"/>
    
    
    <category term="区块链" scheme="https://zhulg.github.io/tags/区块链/"/>
    
  </entry>
  
  <entry>
    <title>技术人的空窗期,你的涅槃重生</title>
    <link href="https://zhulg.github.io/posts/de2623a0.html"/>
    <id>https://zhulg.github.io/posts/de2623a0.html</id>
    <published>2024-07-30T15:23:14.000Z</published>
    <updated>2024-07-30T15:26:56.788Z</updated>
    
    <content type="html"><![CDATA[<p>最近几个月，之前的同事们陆续打听有没有在招人，有没有职位空缺，他们有大厂的技术大牛，也有小公司的技术负责人。</p><p>很明显，他们并不是在找更好的跳槽机会，而是遇到了空窗期在找一份稳定踏实的工作，这种无奈和焦虑深深地触动了我，也想写一下自己对这块的一个思考。</p><p><strong>每个技术人或早或晚都会经历职业生涯中的空窗期，包括自己。</strong></p><p>这个空窗期可能会突如其来：比如你负责的项目要突然终止，曾经投入的工作不再需要你，曾经引以为傲的技能变得陈旧过时，然后，你可能会经历长期找不到合适工作的焦虑，看到新技术层出不穷却无力跟上的无助，甚至面对亲朋好友对你职业前景的担忧。这种空窗期就像一片无边无际的黑暗，把你推向深渊，击垮你的自信心。每一次面试的失败都像是一次次否定，让你陷入无尽的自我怀疑之中。</p><p><strong>这一切可能措手不及，同时也残酷无比，这个时期，除了要给自己打气，更要换一种思路来看待这个过程。</strong></p><p>空窗期可能是你的最低谷期，但如果利用得好，这段时间恰恰是你涅槃重生的关键。想一想，在这段时间里，你被迫停下来思考，重新评估自己的目标和方向。虽然这是一个痛苦的过程，但也是一次难得的自我认知之旅。你要反思自己为何会陷入这样的困境，自己真正热爱的是什么，自己究竟想要的是什么。</p><p>在这个过程中，你心理承受着巨大的冲击，焦虑和抑郁时常来袭，仿佛身处无尽的黑暗。然而，正是在这段黑暗中，你将学会了如何与自己对话，如何面对自己的内心。通过深刻的思考和内在的认知调整，你会发现那些曾经模糊不清的目标逐渐变得清晰而坚定。</p><p>空窗期不仅是心理的磨砺，更是意志的锤炼。很多时候，最终拼的不是智商，而是意志力。通过日复一日的坚持，每一次小小的进步，都在无形中为你积蓄力量。你逐渐学会如何更高效地学习新技术，如何更敏锐地捕捉行业动态，如何更智慧地应对职业的挑战。</p><p>乔布斯曾被自己创办的苹果公司解雇。在那段低谷期，他创办了NeXT和Pixar，不断尝试和创新，最终以更强大的姿态回归苹果，带领公司走向巅峰。正是那段空窗期，给了他重新思考和调整的机会，让他能够以新的视角和更深的洞察力面对未来的挑战。</p><p><strong>要成功渡过空窗期，并迎来职业生涯的新起点，这里有几个自己心得思考不妨一起试试：</strong></p><ol><li><strong>持续学习并更新技能</strong>：利用这段时间，系统地学习新技术，更新自己的知识储备。可以通过在线课程、技术论坛、阅读专业书籍等途径来充实自己。</li><li><strong>多交流摸清行业需求</strong>：分享彼此的困惑和经验，相互鼓励，摸清行业需求，帮助彼此度过难关。</li><li><strong>坚持完成小目标</strong>：通过每天的努力，一步步接近自己的大目标。小目标的实现不仅能带来成就感，还能不断激励你前行。</li><li><strong>保持积极的心态</strong>：相信自己终将渡过难关，迎来新的机遇。积极的心态能帮助你更好地面对挑战，找到解决问题的办法。</li></ol><p>技术人的空窗期，不是失败的象征，而是重生的序曲，这段时间是提升自己的宝贵机会。</p><p>最后，无论空窗期有多长，都不要放弃对未来的希望。利用这段时间好好充实自己，重新找到自己的方向和热情。</p><p>相信自己，每一个低谷都是为了迎接更高的山峰，每一段黑暗都是为了见到更亮的光明。技术人的空窗期，正是你涅槃重生的最好时机。</p><p><strong>“沉舟侧畔千帆过，病树前头万木春。”当你度过了这段空窗期，你会发现自己如凤凰般涅槃重生，迎来了一个崭新的起点。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近几个月，之前的同事们陆续打听有没有在招人，有没有职位空缺，他们有大厂的技术大牛，也有小公司的技术负责人。&lt;/p&gt;
&lt;p&gt;很明显，他们并不是在找更好的跳槽机会，而是遇到了空窗期在找一份稳定踏实的工作，这种无奈和焦虑深深地触动了我，也想写一下自己对这块的一个思考。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="技术成长" scheme="https://zhulg.github.io/categories/技术成长/"/>
    
    
    <category term="技术成长" scheme="https://zhulg.github.io/tags/技术成长/"/>
    
  </entry>
  
  <entry>
    <title>想成为技术架构师？这些核心能力你是否已经具备</title>
    <link href="https://zhulg.github.io/posts/667740ac.html"/>
    <id>https://zhulg.github.io/posts/667740ac.html</id>
    <published>2024-07-24T15:08:39.000Z</published>
    <updated>2024-07-24T15:11:41.451Z</updated>
    
    <content type="html"><![CDATA[<p>技术架构师在软件系统开发中扮演着重要的角色，决定了用什么技术、如何架构设计系统、技术攻关、方案选型等</p><p>如同建造高楼大厦，需要安全可靠的图纸和精准无误的规划设计，都离不开架构师的规划建设能力。</p><p>为保证系统稳定可靠，要成为技术架构师需要更要从各个方面练就自己，先来看看架构师职责，以及要具备哪些能力。</p><h3 id="架构师核心职责有哪些"><a href="#架构师核心职责有哪些" class="headerlink" title="架构师核心职责有哪些"></a><strong>架构师核心职责有哪些</strong></h3><ul><li><p>负责软件系统整体架构设计、技术和组件选型、模块间通信管理、数据模型设计等。</p></li><li><p>围绕系统的架构、扩展性、稳定性、技术攻关、安全性等方面进行开展工作，确保系统整体完善水平。</p></li><li><p>通过与业务的深入学习，促使业务和技术的结合，合理架构并设计出符合产品所需要的最优方案。</p></li></ul><p><strong>具备的核心能力</strong></p><p>无论是负责系统的整体架构师，还是在细分领域做架构师，比如后端架构师、前端架构师、客户端架构师，他们的基础核心能力是相通的。</p><p><strong>01 理论基础</strong></p><p>很多做技术的，无论现在所处的阶段，初级还是中高级、架构师都需要基本扎实的基础，这个犹如地基，地基不稳，很多时候高楼大厦也是很难拔地而起的。</p><p>成为技术架构师前，通常需要大量的基础编程积累，在基础编程工作时候要熟知计算机的基础知识。</p><p>这些核心基础包括数据结构、网络传输原理、系统运行原理、控件生命周期、内存管理、IO读写等等。</p><p>如果觉得比较抽象，不妨先从相关图书了解，比如数据结构与算法、操作系统、网络传输、编译原理、图形渲染、算法、linux操作、软件工程等。</p><p>消化掉这些基础科目后能满足最基础知识储备，后续可以针对具体领域进行深入学习。</p><p><strong>02 编程能力</strong></p><p>要成为技术架构师，首先要有扎实的编程能力，虽不可能掌握所有的开发语言来进行编程，但任何一门优秀的开发语言都是相似的。</p><p><strong>编程能力，换句话来说就是使用开发语言解决业务问题的能力。</strong></p><p>在系统构成的整体上，至少要熟练应用一门语言来进行深入编程，可以是后端、前端、移动端、数据、AI领域等。</p><p>我说的是要深入一门语言的编程，并熟知该语言的设计和编译原理。</p><p>从语言的设计源码层面理解，可以是JAVA、GO、Kotlin、OC、Swift、Rust、JavaScript、Flutter、Dart等。</p><p>理解面向对象、函数式、声明式等不同的编程范式，能够根据实际问题选择最适合的编程范式。</p><p>编程时具备算法和数据结构的使用，代码是否可读、可维护、可测试、参与开源项目代码贡献、关注编程思维的提升。</p><p>具备宽泛和深入的编程能力，广度上理解各种语言解决的问题和适合的业务场景，深度上掌握编程实施、结构设计和算法应用。</p><p><strong>03 架构设计能力</strong></p><p>架构师的职责中，设计高效、可扩展、易于维护的系统架构是至关重要的。</p><p>具备好的架构设计能力是需要编程和常用设计原则、设计模式、业务规则、引擎算法等相结合的。</p><p>需要知道对应的SOLID是什么？</p><p>23种设计模式有哪些，他们的使用场景有哪些？</p><p>模块之间的解耦怎么做、模块化怎么搭建、组件化又是什么？</p><p>在整体设计上，如何做分层设计、业务层、数据层、适配层，模块设计上如何划分通用模块、业务组件、数据组件、模块间如何通信、数据库上如何做主从，如何处理并发、如何处理大规模数据访问。</p><p>前端领域架构师要考虑同样问题分层设计、模块化划分、同时考虑前端页面的可插拔功能建设，组件化，动态配置、内存、性能优化、自修复自升级等。</p><p>想成为架构师，可以对比看看是否这些架构设计能力目前的掌握了解程度。</p><p>当然这里面的每一项能力都需要日积月累，刻意练习，不可忽视细节，但也不能陷入细节之中</p><p>架构设计能力关注整个系统全局的建设视野，同时关注核心重要的细节。</p><p><strong>04 业务理解能力</strong></p><p>软件架构设计都离不开对业务的深入理解和预见能力，否则设计出的软件产品可能是一塌糊涂。</p><p>做好业务的学习和理解，可以多深入一线体验业务和产品，结合实际业务流程来对产品进行方案架构设计。</p><p>提高业务理解能力，要主动和业务产品人员一起多交流和反馈，确保技术和业务之间的信息畅通，结合业务提前考虑对应的技术方案预研工作。</p><p>在充分理解业务的基础上，从中抽象梳理出对应的技术架构方案。</p><p>在落地架构设计时，从业务实际情况做出规划、折中技术架构方案，不过度设计。</p><p>这些能力都需要对业务发展的充分理解和认识。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;技术架构师在软件系统开发中扮演着重要的角色，决定了用什么技术、如何架构设计系统、技术攻关、方案选型等&lt;/p&gt;
&lt;p&gt;如同建造高楼大厦，需要安全可靠的图纸和精准无误的规划设计，都离不开架构师的规划建设能力。&lt;/p&gt;
&lt;p&gt;为保证系统稳定可靠，要成为技术架构师需要更要从各个方面</summary>
      
    
    
    
    <category term="技术成长" scheme="https://zhulg.github.io/categories/技术成长/"/>
    
    
    <category term="技术成长" scheme="https://zhulg.github.io/tags/技术成长/"/>
    
  </entry>
  
  <entry>
    <title>技术重构何时做，为什么做要想清楚</title>
    <link href="https://zhulg.github.io/posts/39b94e3a.html"/>
    <id>https://zhulg.github.io/posts/39b94e3a.html</id>
    <published>2024-07-14T10:58:39.000Z</published>
    <updated>2024-07-14T11:01:51.201Z</updated>
    
    <content type="html"><![CDATA[<h1 id="技术重构何时做，为什么做要想清楚"><a href="#技术重构何时做，为什么做要想清楚" class="headerlink" title="技术重构何时做，为什么做要想清楚"></a>技术重构何时做，为什么做要想清楚</h1><p><em>代码重构（Refactoring）是指在不改变代码外部行为的前提下，对代码内部结构进行调整，以提高代码的可读性、可维护性和可扩展性。</em></p><ul><li><p>重构的目标是让代码变得更简洁、更优雅、更容易理解和修改</p></li><li><p>重构不难，何时做，以及为什么要做要想清楚，不要为了重构而重构、不为了KPI 夸大事实来重构。</p></li></ul><h1 id="何时进行代码重构"><a href="#何时进行代码重构" class="headerlink" title="何时进行代码重构"></a>何时进行代码重构</h1><h2 id="1-交付快慢"><a href="#1-交付快慢" class="headerlink" title="1.交付快慢"></a>1.交付快慢</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当写一个需求发现代码新增量比较大，代码编写比较多</span><br><span class="line"></span><br><span class="line">扩展一个功能发现要改动范围比较多，涉及多个文件或者类</span><br></pre></td></tr></table></figure><ul><li><p>可能要考虑是否原来的代码没有基建，造成重复增加代码。</p></li><li><p>扩展的功能没有模块化、没有分层、要反复改动多处。</p></li></ul><p><strong>交付缓慢，当代码变得难以理解和维护且错误频出时，可能就是重构的最佳时机</strong></p><h2 id="2-使用体验"><a href="#2-使用体验" class="headerlink" title="2.使用体验"></a>2.使用体验</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当使用产品时卡顿、不流畅，页面加载时间比较长</span><br><span class="line">使用中应用频繁出错、页面出错，内存读写等问题</span><br></pre></td></tr></table></figure><ul><li>可能需要看下卡顿的原因，性能问题、渲染问题、数据量过大造成请求缓慢等问题，可能来源于代码的效率低下、资源的过度消耗等。</li></ul><p><strong>当系统体验已经严重影响用户了，就需要重构提高系统的响应速度和稳定性</strong></p><h2 id="3-需求变化"><a href="#3-需求变化" class="headerlink" title="3.需求变化"></a>3.需求变化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当需求或者业务发生变化时，代码无法通过相关配置进行快速开发</span><br><span class="line">为满足需求变化，需要改动大的模块进行调整，牵一发而动全身的代码调整代价</span><br></pre></td></tr></table></figure><ul><li>需要从架构设计、模块耦合、数据隔离等方面来判断造成代码耦合度高，不能快速响应业务和需求变化的原因。</li></ul><p><strong>更好地适应新的需求变化，此时进行重构，确保系统的灵活性和可扩展性</strong></p><h2 id="4-技术问题"><a href="#4-技术问题" class="headerlink" title="4.技术问题"></a>4.技术问题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当原有的系统使用框架、组件在开发需求中不能满足新的呈现形式</span><br><span class="line"></span><br><span class="line">当老的控件开发速度缓慢、还有相关老技术所暴露的安全隐患类问题</span><br></pre></td></tr></table></figure><ul><li>需要评估老技术的局限性，并判断新技术的稳定性、快捷性，能从效率和稳定性上改善老系统</li></ul><p><strong>如果系统依赖于过时的技术，此时需要重构来升级技术、确保系统安全和可维护性。</strong></p><h2 id="5-团队人员变化"><a href="#5-团队人员变化" class="headerlink" title="5.团队人员变化"></a>5.团队人员变化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当团队人员发生变化，老的系统、代码无人知晓和熟悉</span><br><span class="line">新人不知道原来逻辑，要看懂别人代码、维护代码成本都会比较高</span><br></pre></td></tr></table></figure><ul><li>当对系统的代码不熟悉，新的扩展和改动逻辑都会是比较危险的事情，可能里面一些坑因为不知道逻辑，导致系统频繁出错。</li></ul><p><strong>此时进行重构可以帮助新成员更快地上手业务、梳理代码逻辑，同时熟悉到系统间关联代码。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;技术重构何时做，为什么做要想清楚&quot;&gt;&lt;a href=&quot;#技术重构何时做，为什么做要想清楚&quot; class=&quot;headerlink&quot; title=&quot;技术重构何时做，为什么做要想清楚&quot;&gt;&lt;/a&gt;技术重构何时做，为什么做要想清楚&lt;/h1&gt;&lt;p&gt;&lt;em&gt;代码重构（Refac</summary>
      
    
    
    
    <category term="技术成长" scheme="https://zhulg.github.io/categories/技术成长/"/>
    
    
    <category term="技术成长" scheme="https://zhulg.github.io/tags/技术成长/"/>
    
  </entry>
  
  <entry>
    <title>35岁+技术人成长和思考</title>
    <link href="https://zhulg.github.io/posts/a07268b7.html"/>
    <id>https://zhulg.github.io/posts/a07268b7.html</id>
    <published>2024-07-13T04:46:46.000Z</published>
    <updated>2024-07-13T04:59:25.369Z</updated>
    
    <content type="html"><![CDATA[<h1 id="35岁-技术人成长和思考"><a href="#35岁-技术人成长和思考" class="headerlink" title="35岁+技术人成长和思考"></a>35岁+技术人成长和思考</h1><p>当前经济下新业务增长放缓，企业降本增效、裁员风波频发，技术人年龄增长、生活和家庭责任亦愈加繁重，房子、车子等等这些方面的压力迎面而来。</p><p>在这种不确定性中，技术人如何找到自己的定位、如何稳定情绪并做到坚定信念、如何持续迭代自己的技能与知识，直面所谓的35岁+危机，破解焦虑，实现个人与职业的持续成长，以下几个方面可以与大家一起思考和共勉。</p><h2 id="1-认知和调整"><a href="#1-认知和调整" class="headerlink" title="1.认知和调整"></a>1.认知和调整</h2><p>最近技术圈整体现状来看，如果目前的工作让你疲惫不堪的在苟且偷生、或者已经经历了大礼包的洗礼、亦或正在不被重用、边缘化，或者PUA等等。</p><p>首先，需要意识到这些变化并不是个人失败的象征（如果你浑水摸鱼，这个无解), 而是行业整体环境的反映，欣然接受这一现实也没有什么不好意思，更不要怀疑自己的能力。</p><p>其次，静下心享受这个过程，调整我们的职业期望和目标，仔细审视自己的职业发展路径是否与当前市场的需求和技术发展的趋势相匹配，所面对的人和事，自己是否有迭代优化的地方</p><p>调整心态练就在逆境中前进的能力，对正确的事继续坚持，对不足进行挖掘和复盘，把不足写下来，疯狂练起来。</p><p>最后，无论遇到什么样的问题和挑战，都不能忘记技术人的价值不仅仅在于掌握的技术和解决的问题，更在于我们的思考方式对问题认知和理解。</p><p>调整心态，忘记不公、做到及时止损，顺应趋势的努力，思考如何将过去的经验学习和新业务结合起来。你可以用技术降维打击创新业务，同时也要接触多思维方式，避免一条道轴到底。</p><h2 id="2-技能与学习"><a href="#2-技能与学习" class="headerlink" title="2.技能与学习"></a>2.技能与学习</h2><p>技术的进步日新月异，在技术行业专业技能的迭代和更新至关重要的，持续学习新东西的前提是有足够的兴趣，并了解新技术带来哪些生成力的提升，以及对目前的业务和项目有哪些提升，学习成本如何、能否与业务进行结合，在持续提升技术的同时，需要认清自身的局限性，以及错误的观念，先来审视一下。</p><h4 id="补足基础："><a href="#补足基础：" class="headerlink" title="补足基础："></a>补足基础：</h4><p>在技术领域，所有的创新和开发语言的迭代，都离不开行业基础，因此你的基础需要扎实，在学习任何新技术时，先把已有的基础掌握了，不要盲目认为新技术、换技术栈就可以能学的很好。</p><p>当你计算机基础功底不够时，任何新的技术都不是能快速学习和掌握的，即便掌握也是在皮毛层进行应用，因此当原理不清，学习原理，基础不会，学习基础，补足基础能力。</p><h4 id="保持技术热爱："><a href="#保持技术热爱：" class="headerlink" title="保持技术热爱："></a>保持技术热爱：</h4><p>35岁+技术人大概率经历过早期互联网1.0红利，到移动互联网黄金时代2.0，再到目前眼下互联网3.0 、AI、区块链、 web3.0 、以OpenAI为代表的大模型技术、智能驾驶等等。</p><p>所有新的技术都不会以断层的形式横空出世，都会在原有基础上更新和迭代，包括各种开发语言 Java go kotlin swift flutter rust Typescript 以及仓颉语言等等，他用似曾相识的语法和各有千秋的创新来解决面临的问题，从并发，从速度，从内存等等。</p><p>怎么做是不是全学一遍？不是。</p><p>需要对一种语言进行深入学习，同时对新语言和框架能从原理认识和学习，在足够深度下涉猎广度的学习，语言只是工具，数据结构和问题解决思路才是核心。</p><p>不要断层式学习要持续学习，当你见过足够多各有千秋语言，对各种框架设计足够理解，保持新技术学习和理解，学习新东西的速度也会更快和轻松，万变不离其宗。</p><h2 id="3-软硬实力"><a href="#3-软硬实力" class="headerlink" title="3.软硬实力"></a>3.软硬实力</h2><p>这个年龄的技术人大多已经具备了不错的硬实力，也就是专业技术领域，架构设计等，技术人需要具备的能力，但软实力在这个年龄段又也是必须的， 技术人更应该注重自己软技能的历练。</p><h4 id="沟通能力"><a href="#沟通能力" class="headerlink" title="沟通能力"></a>沟通能力</h4><p>能够清晰、准确地表达自己的想法，同时也要善于倾听他人的观点。核心要能能清晰表达与非技术人员进行沟通和交流，能让他们听懂你语言和表达，注意用非技术语言陈述。</p><h4 id="团队协作"><a href="#团队协作" class="headerlink" title="团队协作"></a>团队协作</h4><p>在项目开发过程中，团队协作尤为重要，技术人员需要具备良好的团队精神，能够和团队成员有效合作，共同完成任务，多学他人的优点，多看别人优势。</p><h4 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h4><p>这个年龄的技术人，在看到问题时，更多需要关注问题产生的原因，通过问题现象挖掘本质，总结产生问题的周边防范措施，不仅仅是在解决在某一个问题上。</p><h4 id="业务和产品思维"><a href="#业务和产品思维" class="headerlink" title="业务和产品思维"></a>业务和产品思维</h4><p>无论在不在技术管理岗或者产品岗，这个阶段都需要具备产品思维，理解产品的需求，知道如何利用技术来实现产品的价值，理解业务的运作模式，知道如何利用技术来推动业务的发展。</p><h4 id="汇报和向上管理"><a href="#汇报和向上管理" class="headerlink" title="汇报和向上管理"></a>汇报和向上管理</h4><p>向上汇报要提炼出核心的东东，具备总结能力、抽象能力，有一定的思考和吹泡泡(ppt)能力，满足向上管理需要，上级没时间从长篇大论里提炼信息，需要浓缩在PPT里进行呈现汇报。</p><p>尽管多数技术人鄙视这种文化，但现实中你还是要具备ppt的汇报总结能力。</p><p>向上管理更多是主动反馈和汇报，事事有回应 ，件件有着落 ，定期向上级报告工作进度和结果，理解和支持上级的决策。</p><p>哪怕是你遇到上级很傻的决定，或许有你看不到的背景和信息，就坚定的支持（威胁你的合法利益的除外），给上级提供正确解决方案建立信任（如果上级已经看你不顺眼，开始穿小鞋，那也就没必要自作多情，及时止损）</p><p>无论何时得罪你上级可能不是明智的，但也不是陪着老板一起瞎搞，至少要做一个正直的技术人，不作恶，在明显的错误决策下，也要给出一些合理建议出来。</p><h2 id="4-职业发展"><a href="#4-职业发展" class="headerlink" title="4.职业发展"></a>4.职业发展</h2><p>这个年龄的技术人可能也会从3个方面发展，一个是技术专家路线，一个是技术管理路线，一个是其他路线。其他路线可能是换赛道、创业、新的铁人三项等等。(如果不知道什么新铁人三项，就忽略说明不适合)</p><h4 id="专家路线"><a href="#专家路线" class="headerlink" title="专家路线"></a>专家路线</h4><p>深耕技术领域。虽然国内最早有35+一道坎，技术人也是青春饭说法，但身边一些技术大牛也有不少40+，这个说明国内行业也在慢慢变化，愿意走专家路线的就不要担心年龄，十年如一日的技能、经验，也一定可以在这个行业行的通。</p><p>但也要警惕自己理论专家，脱离实际业务和场景，只忽悠老板的专家，这样就只剩下现在我们认为的”专家”了。</p><h4 id="管理路线"><a href="#管理路线" class="headerlink" title="管理路线"></a>管理路线</h4><p>管理路线并不是要放弃技术，更多要具备自己技术判断力，问题定位能力，人员协调组织效率最大好，以团队的力量完成整体项目。</p><p>初期需要从0-1的技术攻坚能力，后期需要足够的团队人员管理能力，需要技术突破时也依旧能顶得上。</p><h4 id="其他路线"><a href="#其他路线" class="headerlink" title="其他路线"></a>其他路线</h4><p>对技术人来说也是不错的选择，工作只是生活的一小部分，技术人不要固执的死磕一个领域，或缺先尝试也是不错的选择，相信你身边也会有工作赛道切换后生活更多彩的人，跟随内心勇于尝试。</p><p>无论专家路线、管理路线，其他路线，核心都要把事情做好，知道自己的目标和方向，想想1年后，2年后你要做成什么样子，为你希望的样子现在需要做些什么。</p><p>把你想成为的样子写下来，把要分解的事情写下来，把要做的事情执行起来，如果预期结果不是你要的，定期纠偏复盘重新来过。</p><h2 id="5-健康生活"><a href="#5-健康生活" class="headerlink" title="5.健康生活"></a>5.健康生活</h2><p>如果现在还能保持上学期间的体重，大概率是比较自律、生活规律的技术人，毕竟在技术圈子里大家早出晚归，缺乏锻炼的大有人在，职业属性颈椎病，鼠标手、三高、前列腺等等，大部分还是长期电脑前久坐导致</p><h4 id="体重和运动"><a href="#体重和运动" class="headerlink" title="体重和运动"></a>体重和运动</h4><p>到了这个年龄了身体管理需要提上日程，技术圈高工作强度也是很容易肥胖产生，并为健康埋下隐患。控制体重进行减肥，这个过程一定会很痛苦，可以尝试一下：</p><ul><li>找一个健身博主跟随练习，坚持下去</li><li>黄瓜、西红柿、生菜可以大量吃，控制油糖摄入</li><li>每天坚持饭后半小时运动，公司爬楼梯，跑步，跳绳等有氧运动</li></ul><p>按照这个操作，先坚持1月看看，以个人经验，3个月拿掉30斤以上体重已完全可能，需要注意是坚持运动，控制碳水摄入，但不是不吃碳水，当碳水摄入太少，期间掉头发这种情况也是真实存在。</p><h4 id="充足休息"><a href="#充足休息" class="headerlink" title="充足休息"></a>充足休息</h4><p>保证充足的休息时间，遇到事不要影响到睡眠，这个很难，可以通过分散精力方式，实在不行把自己累起来，跑跑步，运动起来，累了相对好入睡一些，如果睡眠不足，可能你效率和反应都会随之降低。</p><h2 id="6-坚持执行"><a href="#6-坚持执行" class="headerlink" title="6.坚持执行"></a>6.坚持执行</h2><p>所以这些说起来简单，道理也显而易见，但执行起来也并非容易。</p><p>特别年龄的增长心态的变化、情绪的稳定都需要极强的定力，除此之外家庭生活的压力也要关注和调节，保持内心平静。</p><p>到了这个年龄，意志力与世俗对抗显得格外珍贵，如果要健康，就练起来，能力不足就补起来，抵制不住娱乐陋习就卸掉你那无聊某音某手APP。</p><p>很多人和多事会给你挫败，如果实在难以控制，就不如躺平歇一会，给自己个期限，歇完马上重新雄起。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;35岁-技术人成长和思考&quot;&gt;&lt;a href=&quot;#35岁-技术人成长和思考&quot; class=&quot;headerlink&quot; title=&quot;35岁+技术人成长和思考&quot;&gt;&lt;/a&gt;35岁+技术人成长和思考&lt;/h1&gt;&lt;p&gt;当前经济下新业务增长放缓，企业降本增效、裁员风波频发，技术人</summary>
      
    
    
    
    <category term="技术成长" scheme="https://zhulg.github.io/categories/技术成长/"/>
    
    
    <category term="技术成长" scheme="https://zhulg.github.io/tags/技术成长/"/>
    
  </entry>
  
  <entry>
    <title>A Rust CLI-Based Chat Tool Utilizing the ChatGPT API</title>
    <link href="https://zhulg.github.io/posts/dca54e0f.html"/>
    <id>https://zhulg.github.io/posts/dca54e0f.html</id>
    <published>2023-03-15T00:08:07.000Z</published>
    <updated>2024-07-07T04:21:27.922Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ChatGPT-CLI"><a href="#ChatGPT-CLI" class="headerlink" title="ChatGPT CLI"></a>ChatGPT CLI</h1><ul><li>A tool for chatting using the ChatGPT API, written in Rust CLI.You can use this tool to chat, just by setting your API Key.</li><li>You can modify the API domain and other API parameters when you start the chat.</li><li>The source code will be shared in the article for reference.</li></ul><h2 id="Why-create-ChatGPT-CLI"><a href="#Why-create-ChatGPT-CLI" class="headerlink" title="Why create ChatGPT CLI"></a>Why create ChatGPT CLI</h2><ul><li><p><strong>If you can access the network through VPN, you can watch this video to learn more.</strong></p> <iframe width="560" height="315" src="https://www.youtube.com/embed/UXSgo9Ounuk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></li></ul><p> <strong>（若文中视频&amp;图片无法显示，请科学上网查看：<a href="https://order.yizhihongxing.network/aff.php?aff=12299" target="_blank" rel="noopener">推荐工具</a>）</strong></p><h2 id="Introduction-to-the-core-code"><a href="#Introduction-to-the-core-code" class="headerlink" title="Introduction to the core code"></a>Introduction to the core code</h2><ul><li><strong>首先构建命令行工具和信息：</strong>let matches = Command::new(“ChatGPT CLI”).使用 clap 库创建一个命令行工具，其中包含多个命令行参数（如 DomainName，APIKey 等）和一个命令行帮助信息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">let matches = Command::new(&quot;ChatGPT CLI&quot;)</span><br><span class="line">    .author(&quot;lg.json@gmail.com&quot;)</span><br><span class="line">    .version(&quot;1.0.0&quot;)</span><br><span class="line">    .about(</span><br><span class="line">        &quot;x\n</span><br><span class="line">                ChatGPT CLI Create by zhulg (lg.json@gmail.com)</span><br><span class="line">        | 1.You just need to input your api key, the cli version V0.1.1     |</span><br><span class="line">        | 2.No need access internet with VPN, and just enjoy it.            |</span><br><span class="line">        | 3.If you want to use it in China, you can use my api key.         |                                                   |</span><br><span class="line">        |-------------------------------------------------------------------|&quot;,</span><br><span class="line">    )</span><br><span class="line">    .arg(</span><br><span class="line">        Arg::new(&quot;DomainName&quot;)</span><br><span class="line">            .action(ArgAction::Set)</span><br><span class="line">            .short(&apos;d&apos;)</span><br><span class="line">            .long(&quot;Domain&quot;)</span><br><span class="line">            .default_value(&quot;api.openai.com&quot;)</span><br><span class="line">            .help(&quot;Sets the API Domain name.&quot;),</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><ul><li>支持自定义API域名和API密钥，支持从命令行参数或环境变量中设置密钥</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fn read_api_key() -&gt; String &#123;</span><br><span class="line">    // If the OPENAI_API_KEY environment variable is not set,</span><br><span class="line">    // ask the user to input the API key and save it to the</span><br><span class="line">    // environment variables for future use.</span><br><span class="line">    let api_key = env::var(&quot;OPENAI_API_KEY&quot;).unwrap_or_else(|_| &#123;</span><br><span class="line">        console::set_colors_enabled(true);</span><br><span class="line">        let prompt_style = Style::new().yellow();</span><br><span class="line">        let api_key: String = Input::new()</span><br><span class="line">            .with_prompt(prompt_style.apply_to(&quot;Input your API key&quot;).to_string())</span><br><span class="line">            .interact_text()</span><br><span class="line">            .unwrap();</span><br><span class="line">        env::set_var(&quot;OPENAI_API_KEY&quot;, &amp;api_key);</span><br><span class="line">        api_key</span><br><span class="line">    &#125;);</span><br><span class="line">    api_key</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过控制台输入一个消息并回车，该CLI会将该消息发送给OpenAI GPT-3.5-turbo模型，并显示该模型返回的响应消息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let response = client</span><br><span class="line">    .post(url)</span><br><span class="line">    .header(&quot;Content-Type&quot;, &quot;application/json&quot;)</span><br><span class="line">    .header(&quot;Authorization&quot;, format!(&quot;Bearer &#123;&#125;&quot;, api_key))</span><br><span class="line">    .json(&amp;json!(&#123;</span><br><span class="line">        &quot;model&quot;: &quot;gpt-3.5-turbo&quot;,</span><br><span class="line">        &quot;max_tokens&quot;: max_tokens.parse::&lt;i32&gt;().unwrap(),</span><br><span class="line">        &quot;temperature&quot;: 0.5 ,</span><br><span class="line">        &quot;messages&quot;: [&#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: line&#125;]</span><br><span class="line">    &#125;))</span><br><span class="line">    .send()</span><br><span class="line">    .await?</span><br><span class="line">    .json::&lt;Value&gt;()</span><br><span class="line">    .await?;</span><br></pre></td></tr></table></figure><h2 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h2><h3 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h3><ol><li><p>build code </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo build</span><br></pre></td></tr></table></figure></li><li><p>cd target/debug </p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./chatgpt_rust</span><br></pre></td></tr></table></figure><h3 id="Other-Install"><a href="#Other-Install" class="headerlink" title="Other Install"></a>Other Install</h3><ul><li><strong>If you have Rust installed, you can install the CLI using cargo:</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo install chatgpt_rust</span><br></pre></td></tr></table></figure><h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><ul><li><p>Linux/MacOS Run the following command in your terminal:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chatgpt_rust</span><br></pre></td></tr></table></figure></li><li><p><strong>（若文中图片无法显示，请科学上网查看：<a href="https://order.yizhihongxing.network/aff.php?aff=12299" target="_blank" rel="noopener">推荐工具</a>）</strong></p></li></ul><div align="center" width="100%">  <img width="80%" src="https://raw.githubusercontent.com/zhulg/allpic/master/chatgpt_cli.png"></div><ul><li>chatgpt_rust –help </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">                    ChatGPT CLI Create by zhulg (lg.json@gmail.com)</span><br><span class="line">            | 1.You just need to input your api key, the cli version    |</span><br><span class="line">            | 2.No need access internet with VPN, and just enjoy it.    |</span><br><span class="line">            | 3.If you want to use it in China, you can use my api key. |</span><br><span class="line">            | --------------------------------------------------------- |</span><br><span class="line"></span><br><span class="line">Usage: chatgpt_rust [OPTIONS]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -d, --Domain &lt;DomainName&gt;  Sets the API Domain name. [default: api.openai.com]</span><br><span class="line">  -k, --key &lt;APIKey&gt;         Sets the API key. If not provided, the cli will ask for it,</span><br><span class="line">                             You can also set the OPENAI_API_KEY environment variable. [default: ]</span><br><span class="line">  -t, --tokens &lt;max_tokens&gt;  sets the max_tokens, default is 1000 [default: 1000]</span><br><span class="line">  -h, --help                 Print help</span><br><span class="line">  -V, --version              Print version</span><br></pre></td></tr></table></figure><h2 id="Option"><a href="#Option" class="headerlink" title="Option:"></a>Option:</h2><p> Set your ‘OPENAI_API_KEY’ Environment Variable using zsh,  No set will ask the user to input the API key in the terminal.</p><ol><li>Run the following command in your terminal, replacing yourkey with your API key. </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;export OPENAI_API_KEY=&apos;yourkey&apos;&quot; &gt;&gt; ~/.zshrc</span><br></pre></td></tr></table></figure><ol start="2"><li>Update the shell with the new variable:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure><ol start="3"><li>Confirm that you have set your environment variable using the following command. </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $OPENAI_API_KEY</span><br></pre></td></tr></table></figure><p>The value of your API key will be the resulting output.</p><h2 id="Source-code"><a href="#Source-code" class="headerlink" title="Source code"></a>Source code</h2><p><a href="https://github.com/zhulg/ChatGPT_CLI_Rust" target="_blank" rel="noopener">SourceCode</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ChatGPT-CLI&quot;&gt;&lt;a href=&quot;#ChatGPT-CLI&quot; class=&quot;headerlink&quot; title=&quot;ChatGPT CLI&quot;&gt;&lt;/a&gt;ChatGPT CLI&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;A tool for chatting using th</summary>
      
    
    
    
    <category term="ChatGPT" scheme="https://zhulg.github.io/categories/ChatGPT/"/>
    
    
    <category term="ChatGPT" scheme="https://zhulg.github.io/tags/ChatGPT/"/>
    
  </entry>
  
  <entry>
    <title>ChatGPT API介绍及使用</title>
    <link href="https://zhulg.github.io/posts/c22af37b.html"/>
    <id>https://zhulg.github.io/posts/c22af37b.html</id>
    <published>2023-03-09T23:44:59.000Z</published>
    <updated>2024-07-07T04:21:27.923Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ChatGPT-API介绍和使用"><a href="#ChatGPT-API介绍和使用" class="headerlink" title="ChatGPT API介绍和使用"></a>ChatGPT API介绍和使用</h2><ul><li>ChatGPT API的发布，可以让大家快速使用，不仅可以搭建类似ChatGPT应用，还可以通过API制作自己的应用、接入自己的产品、快速拥有强大的AI能力。</li><li>本文介绍ChatGPT API如何使用、API key的创建，请求花费、定价规则、运行官方起名应用快速入门ChatGPT API 的使用。</li></ul><h3 id="ChatGPT-API-介绍"><a href="#ChatGPT-API-介绍" class="headerlink" title="ChatGPT API 介绍"></a>ChatGPT API 介绍</h3><ul><li><strong>先看下张图：</strong>从这图上官方正式介绍，可以使用API方式接入ChatGPT到自己的应用里了，这不仅仅对开发者，更多对不懂开发的人也可以通过自然语言及指令接入自己应用中。<br><strong>（若文中图片无法显示，请科学上网查看：<a href="https://order.yizhihongxing.network/aff.php?aff=12299" target="_blank" rel="noopener">推荐工具</a>）</strong></li></ul><div align="center" width="100%">  <img width="80%" src="https://raw.githubusercontent.com/zhulg/allpic/master/chatgptapi_1.png"></div><ul><li><strong>API更新介绍：</strong><br>这里说到gpt-3.5-turbo是ChatGPT产品中使用的相同模型，但其价格为每1k tokens为0.002美元，相当于每100万token只需要2美元。 比我们现有的GPT-3.5模型便宜10倍，这是3月1号最新官网介绍。</li></ul><div align="center" width="100%">  <img width="80%" src="https://raw.githubusercontent.com/zhulg/allpic/master/chatgptapi_2.png"></div><h3 id="Tokens是什么"><a href="#Tokens是什么" class="headerlink" title="Tokens是什么"></a>Tokens是什么</h3><ul><li><p><strong>API计费单位</strong>。</p></li><li><p><strong>一次提问怎么计费 : 问题tokens + 答案tokens</strong></p></li><li><p>具体来讲，在模型里它指系统将句子和单词分解成的文本块，以便预测接下来应该输出什么文本。根据 OpenAI 官方文档显示，“ChatGPT is great!”这组单词需要六个 token，它的 API 将其分解为“Chat”、“G”、“PT”、“is”、“great”和“!”。与此同时，OpenAI 还专门提供了一个用于检查解释一串文本需要多少 token 的工具，并表示，按照一般的经验来看，在英语中“一个 token 通常对应大约 4 个字符”</p><div align="center" width="100%"><img width="80%" src="https://raw.githubusercontent.com/zhulg/allpic/master/tokeninfo.png"></div></li><li><p><strong>1000个tokens大概750个单词</strong></p></li></ul><div align="center" width="100%">  <img width="80%" src="https://raw.githubusercontent.com/zhulg/allpic/master/models.png"></div><h3 id="如何预估tokens"><a href="#如何预估tokens" class="headerlink" title="如何预估tokens:"></a>如何预估tokens:</h3><ul><li>提供了技术tokens的方法，可以参考理解tokens的计算：</li></ul><div align="center" width="100%">  <img width="80%" src="https://raw.githubusercontent.com/zhulg/allpic/master/tokens.png"></div><h2 id="创建账号和API-Key"><a href="#创建账号和API-Key" class="headerlink" title="创建账号和API Key"></a>创建账号和API Key</h2><ul><li>第一步我们需要登录openAI并注册账号，没有的需要先进行注册 (如果国内无法注册，可以看下方邮件地址邮件我）注册的账号里会先送有18美元，可以对基本的API测试和使用足够了。</li><li>第二步，通过账号登录后进行API key的创建，可以通过个人中心 View API keys来创建，点击创建即可。也可以通过QuickStart里的demo一步步创建。都是可以的，创建好要记得保存下来，后边将不会全部显示了，如果忘记需要移除再次创建。<div align="center" width="100%"><img width="80%" src="https://raw.githubusercontent.com/zhulg/allpic/master/keycreate.png"></div></li></ul><h2 id="使用API"><a href="#使用API" class="headerlink" title="使用API"></a>使用API</h2><ul><li>为了快速演示，使用curl来进行访问接口。 国内的朋友一定要记得科学上网，这个接口否则无法访问（代理一定要设置好，否则接口是无法访问的），我这里验证了后对API返回的数据也进行各说明，如图，返回的接口里有API给的信息和这次请求的花费。</li></ul><div align="center" width="100%">  <img width="80%" src="https://raw.githubusercontent.com/zhulg/allpic/master/api.png"></div><ul><li>返回的数据包括了此次请求花费显示：</li></ul><div align="center" width="100%">  <img width="80%" src="https://raw.githubusercontent.com/zhulg/allpic/master/apidata.png"></div><ul><li>官方也提供了其他语言的SDK，你都可以快速接入。<div align="center" width="100%"><img width="80%" src="https://raw.githubusercontent.com/zhulg/allpic/master/othersdk.png"></div></li></ul><h2 id="应用演示"><a href="#应用演示" class="headerlink" title="应用演示"></a>应用演示</h2><ul><li>运行官方的例子，可以通过代码和页面来查看具体API的使用方法。可以使用node来进行运行起来，并查看具体的代码, 运行后如图：<div align="center" width="100%"><img width="80%" src="https://raw.githubusercontent.com/zhulg/allpic/master/pet.png"></div></li><li>这个demo 通过npm install 之后可以快速启动起来。官方也提供了其他产品接入的演示。希望给大家带来更多整合应用的灵感。</li><li>这个demo的运行需要注意，一个是node的版本不要太低18之后最好，其次访问时还是要科学上网。（有任何代理和账号注册问题都可以邮件我）</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ChatGPT-API介绍和使用&quot;&gt;&lt;a href=&quot;#ChatGPT-API介绍和使用&quot; class=&quot;headerlink&quot; title=&quot;ChatGPT API介绍和使用&quot;&gt;&lt;/a&gt;ChatGPT API介绍和使用&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;ChatGPT </summary>
      
    
    
    
    <category term="ChatGPT" scheme="https://zhulg.github.io/categories/ChatGPT/"/>
    
    
    <category term="ChatGPT" scheme="https://zhulg.github.io/tags/ChatGPT/"/>
    
  </entry>
  
  <entry>
    <title>Damus Android版APK下载包Amethyst</title>
    <link href="https://zhulg.github.io/posts/f235cc57.html"/>
    <id>https://zhulg.github.io/posts/f235cc57.html</id>
    <published>2023-02-03T03:32:01.000Z</published>
    <updated>2024-07-07T04:21:27.923Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Damus是一个建立在去中心化网络上的社交软件，目前iOS可以通过appstore直接下载使用。</li><li><strong>Android版是需要通过googleplay下载Amethyst，国内Android手机由于周知原因，无法直接安装，特提供安装包供大家下载安装</strong>。</li></ul><h3 id="Amethyst安装包下载："><a href="#Amethyst安装包下载：" class="headerlink" title="Amethyst安装包下载："></a>Amethyst安装包下载：</h3><ul><li>点击下载获取该Android版本安装包：<a href="https://raw.githubusercontent.com/zhulg/allpic/master/Amethyst_0.11.5.apk" target="_blank" rel="noopener">Amethyst 安装包点击下载</a>  pc上直接点击下载，手机上通过浏览器打开再点击。</li><li>下载安装到Androids手机即可，如有问题可邮件(<a href="mailto:lg.json@gmail.com" target="_blank" rel="noopener">lg.json@gmail.com</a>) 单独再提供安装包</li></ul><div align="center" width="100%">  <img width="80%" src="https://raw.githubusercontent.com/zhulg/allpic/master/googleplay.png"></div><ul><li><strong>（若文中图片无法显示，请科学上网查看：<a href="https://order.yizhihongxing.network/aff.php?aff=12299" target="_blank" rel="noopener">推荐工具</a>）</strong></li></ul><h3 id="安装后登陆："><a href="#安装后登陆：" class="headerlink" title="安装后登陆："></a>安装后登陆：</h3><ul><li>进入后，先创建公钥，如图所示进入后在登录页面，选择创建进入即可，会自动生成对应的私钥。</li></ul><div align="center" width="100%">  <img width="70%" src="https://raw.githubusercontent.com/zhulg/allpic/master/d_user_create.png"></div><h3 id="私钥获取："><a href="#私钥获取：" class="headerlink" title="私钥获取："></a>私钥获取：</h3><ul><li>第一次创建后，点击左上角头像»Profile »长按***复制私钥。</li><li>自动复制到剪贴板（目前没任何提示）粘贴后可查看，请安全保存后边用于登录账号。<div align="center" width="100%"><img width="70%" src="https://raw.githubusercontent.com/zhulg/allpic/master/d_user_getkey.png"></div></li></ul><h3 id="私钥登录："><a href="#私钥登录：" class="headerlink" title="私钥登录："></a>私钥登录：</h3><ul><li>保存好的私钥后，<strong>选择登出APP后，通过私钥再次登陆</strong>，这样就可以使用了。</li><li>个人中心有公钥显示，可以选择分享，分享给他人进行关注（朋友圈那一串串的符合）</li><li><strong>私钥用来登录自己的账号，保存好！！</strong></li></ul><h3 id="其他："><a href="#其他：" class="headerlink" title="其他："></a>其他：</h3><ul><li>到这一步可以查看了正常使用了，可以搜索关注我 <strong>npub1z40ckftt5tq70uqvtng4jz6lv34am6k85vkzlrgfzqs22rkrqjyqkga4cj</strong></li><li>后边头像更换、发贴添加节点闪电网络等，<strong>进去后自己玩即可有问题可以邮件私信</strong>。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;Damus是一个建立在去中心化网络上的社交软件，目前iOS可以通过appstore直接下载使用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Android版是需要通过googleplay下载Amethyst，国内Android手机由于周知原因，无法直接安装，特提供安装包</summary>
      
    
    
    
    <category term="区块链" scheme="https://zhulg.github.io/categories/区块链/"/>
    
    
    <category term="Android" scheme="https://zhulg.github.io/tags/Android/"/>
    
    <category term="区块链" scheme="https://zhulg.github.io/tags/区块链/"/>
    
  </entry>
  
  <entry>
    <title>Rust CLI反编译Android APK</title>
    <link href="https://zhulg.github.io/posts/b176cd6e.html"/>
    <id>https://zhulg.github.io/posts/b176cd6e.html</id>
    <published>2022-11-06T03:26:52.000Z</published>
    <updated>2024-07-07T04:21:27.925Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Rust-CLI使用"><a href="#Rust-CLI使用" class="headerlink" title="Rust-CLI使用"></a>Rust-CLI使用</h2><ul><li>Rust提供了比较好的CLI接口,可以快速的编写CLI应用, 用于日常的工具类使用</li><li>Android 反编译APK的过程，可以通过Rust来整合成命令行一步完成, 整合其中出来过程, 来应用Rust CLI的实践</li><li><strong>目的熟悉Rust CLI来编写应用，并通过命令行自动化反编译APK几个过程，作为日常工具提效</strong></li></ul><h2 id="编写准备："><a href="#编写准备：" class="headerlink" title="编写准备："></a>编写准备：</h2><ul><li><strong>反编译APK依赖的必要库：</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d2j-dex2jar</span><br><span class="line">jd-cli</span><br><span class="line">Apktool</span><br></pre></td></tr></table></figure><p>应用该库使用为最新版本，如果有不支持兼容的需要确认Java使用的相关版本即可。</p><ul><li><strong>Rust CLI 编写依赖的库：</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">clap </span><br><span class="line">console</span><br><span class="line">execute </span><br><span class="line">indicatif</span><br><span class="line">text2art</span><br></pre></td></tr></table></figure><p>这些库的使用方式和说明可在<a href="https://crates.io/" target="_blank" rel="noopener">crates.io</a>查到说明</p><h2 id="代码解析："><a href="#代码解析：" class="headerlink" title="代码解析："></a>代码解析：</h2><ul><li><strong>编写CLI处理接口：</strong></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> matches = Command::new(<span class="string">"Decompile APK"</span>)</span><br><span class="line">    .author(<span class="string">"lg.json@gmail.com"</span>)</span><br><span class="line">    .version(<span class="string">"1.0.0"</span>)</span><br><span class="line">    .about(<span class="string">"ApkDecompiler for Android, create by Spark Coding BU"</span>)</span><br><span class="line">    .arg(</span><br><span class="line">        Arg::new(<span class="string">"file"</span>)</span><br><span class="line">            .action(ArgAction::Set)</span><br><span class="line">            .short(<span class="string">'f'</span>)</span><br><span class="line">            .long(<span class="string">"file"</span>)</span><br><span class="line">            .default_value(<span class="string">"-"</span>)</span><br><span class="line">            .help(<span class="string">"The path to your apk."</span>),</span><br><span class="line">    )</span><br><span class="line">    .after_help(</span><br><span class="line">        <span class="string">"Longer explanation to appear after the options when \</span></span><br><span class="line"><span class="string">              displaying the help information from --help or -h"</span>,</span><br><span class="line">    )</span><br><span class="line">    .get_matches();</span><br></pre></td></tr></table></figure><ul><li><p>Command使用的是clap来创建， 通过Arg创建对应的参数和应用，可以创建读个arg进行添加。</p></li><li><p><strong>读取CLI的输入参数：</strong></p></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> file_path = <span class="keyword">match</span> matches.get_one::&lt;<span class="built_in">String</span>&gt;(<span class="string">"file"</span>) &#123;</span><br><span class="line">      <span class="literal">Some</span>(it) =&gt; it,</span><br><span class="line">      _ =&gt; <span class="keyword">return</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">let</span> apk_path = PathBuf::from(file_path);</span><br></pre></td></tr></table></figure><ul><li><strong>开始执行:</strong></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">start_decompile</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">self</span>.show_tools_info()?;</span><br><span class="line">    <span class="keyword">self</span>.create_output_dir()?;</span><br><span class="line">    <span class="keyword">self</span>.start_dex2jar()?;</span><br><span class="line">    <span class="keyword">self</span>.start_decompile_class()?;</span><br><span class="line">    <span class="keyword">self</span>.start_decompile_res()?;</span><br><span class="line">    <span class="keyword">self</span>.open_output()?;\</span><br><span class="line">    <span class="literal">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开始执行会显示工具对应的信息，创建文件输出的地址，开始解析对应的包</p><ul><li><strong>举例命令行的创建：</strong></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///use dex2jar get APK's jar in output_path</span></span><br><span class="line"> <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">start_dex2jar</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">Result</span>&lt;()&gt; &#123;</span><br><span class="line">     <span class="keyword">let</span> <span class="keyword">mut</span> command = Command::new(<span class="string">"sh"</span>);</span><br><span class="line"></span><br><span class="line">     command</span><br><span class="line">         .arg(<span class="keyword">self</span>.exe_dir.join(<span class="string">"lib/dex2jar/d2j-dex2jar.sh"</span>))</span><br><span class="line">         .arg(<span class="string">"-f"</span>)</span><br><span class="line">         .arg(&amp;<span class="keyword">self</span>.apk_path)</span><br><span class="line">         .arg(<span class="string">"-o"</span>)</span><br><span class="line">         .arg(<span class="keyword">self</span>.output_path.join(<span class="string">"app.jar"</span>));</span><br><span class="line"></span><br><span class="line">     execute_state(command, <span class="string">"dex2jar"</span>);</span><br><span class="line">     <span class="literal">Ok</span>(())</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li><strong>工程注意点：</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.使用build.rs在构建前需要把代码依赖的lib库拷到对应的target下，这里使用了构建脚本, 具体参见代码工程</span><br><span class="line">2.如何使用cli的执行状态，来显示处理过程, 是CLI下常用的工具</span><br></pre></td></tr></table></figure><ul><li>最终工具处理效果： <strong>（文中图片无法显示，请科学上网查看：<a href="https://order.yizhihongxing.network/aff.php?aff=12299" target="_blank" rel="noopener">推荐工具</a>）</strong><div align="center" width="100%"><img width="950%" src="https://raw.githubusercontent.com/zhulg/allpic/master/decompilerapk.gif"></div></li></ul><h2 id="源码地址："><a href="#源码地址：" class="headerlink" title="源码地址："></a>源码地址：</h2><ul><li>源码 <a href="https://github.com/zhulg/RustDecompileApk" target="_blank" rel="noopener">Github地址</a></li><li>使用方式：./apkdecompiler -f ./test.apk</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  _____                      _        _____                                        _  _</span><br><span class="line"> / ____|                    | |      |  __ \                                      (_)| |</span><br><span class="line">| (___   _ __    __ _  _ __ | | __   | |  | |  ___   ___   ___   _ __ ___   _ __   _ | |  ___  _ __</span><br><span class="line"> \___ \ | &apos;_ \  / _` || &apos;__|| |/ /   | |  | | / _ \ / __| / _ \ | &apos;_ ` _ \ | &apos;_ \ | || | / _ \| &apos;__|</span><br><span class="line"> ____) || |_) || (_| || |   |   &lt;    | |__| ||  __/| (__ | (_) || | | | | || |_) || || ||  __/| |</span><br><span class="line">|_____/ | .__/  \__,_||_|   |_|\_\   |_____/  \___| \___| \___/ |_| |_| |_|| .__/ |_||_| \___||_|</span><br><span class="line">        | |                                                                | |</span><br><span class="line">        |_|                                                                |_|</span><br><span class="line">begin del old file...in /Users/developer/apkdecompiler/output</span><br><span class="line">✅ create ouput:/Users/developer/apkdecompiler/output</span><br><span class="line">✅ dex2jar...done</span><br><span class="line">✅ decompile class...done</span><br><span class="line">✅ decompile Resource...done</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Rust-CLI使用&quot;&gt;&lt;a href=&quot;#Rust-CLI使用&quot; class=&quot;headerlink&quot; title=&quot;Rust-CLI使用&quot;&gt;&lt;/a&gt;Rust-CLI使用&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Rust提供了比较好的CLI接口,可以快速的编写CLI应用, 用</summary>
      
    
    
    
    <category term="Rust" scheme="https://zhulg.github.io/categories/Rust/"/>
    
    
    <category term="Rust" scheme="https://zhulg.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>iOS集成Rust使用</title>
    <link href="https://zhulg.github.io/posts/e04cad1e.html"/>
    <id>https://zhulg.github.io/posts/e04cad1e.html</id>
    <published>2022-10-23T01:37:06.000Z</published>
    <updated>2024-07-07T04:21:27.929Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iOS调用Rust"><a href="#iOS调用Rust" class="headerlink" title="iOS调用Rust"></a>iOS调用Rust</h1><h2 id="一，开发环境："><a href="#一，开发环境：" class="headerlink" title="一，开发环境："></a>一，开发环境：</h2><ul><li>确保xcode开发环境，推荐官方文档, 安装即可</li><li>rust开发环境</li><li>xcode及iOS调试设备</li><li>末尾附带demo工程源码，供初学者集成原理学习使用（简单步骤有省略，有疑问可邮件我）</li></ul><h2 id="二，添加rust交叉编译"><a href="#二，添加rust交叉编译" class="headerlink" title="二，添加rust交叉编译"></a>二，添加rust交叉编译</h2><ul><li>同android一样，可以添加支持ios的编译</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rustup target add aarch64-apple-ios x86_64-apple-ios</span><br></pre></td></tr></table></figure><ul><li>初始化 cargo-lipo : 这个create可以编译rs为iOS需要的库</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo install cargo-lipo</span><br></pre></td></tr></table></figure><h2 id="三，创建工程"><a href="#三，创建工程" class="headerlink" title="三，创建工程"></a>三，创建工程</h2><ul><li>这里的rs代码直接 <strong>(参考了mozilla的例子，只为测试验证集成过程）</strong></li><li>创建iOS基本工程，并创建rust的库工程，可以创建lib，也可以直接rs工程。 <strong>（一套rust代码，提供多个平台，那一般可以创建lib库，这样rust工程来调试后，统一对外提供lib库代码，由lib库代码编译对应的so,或者.a文件)</strong></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo new Rust_iOS --lib</span><br></pre></td></tr></table></figure><ul><li>这里使用 Rust_iOS 作为为iOS工程提供的rust 库代码，通过 cargo-lipo 编译出.a的库文件，为ios工程进行调用。</li></ul><h3 id="rust代码添加"><a href="#rust代码添加" class="headerlink" title="rust代码添加"></a>rust代码添加</h3><ul><li><ol><li><strong>在lib.rs里添加下边代码</strong></li></ol></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ffi::&#123;CStr, CString&#125;;</span><br><span class="line"><span class="keyword">use</span> std::os::raw::c_char;</span><br><span class="line"></span><br><span class="line"><span class="comment">//#[no_mangle] 告诉编译器不要破坏函数名，确保函数名称被导入到 C 文件</span></span><br><span class="line"><span class="comment">//extern 告诉 Rust 编译器方法将要在 Rust 以外的地方调用，要确保其按照 C 的调用规则编译。</span></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">fn</span> <span class="title">rust_greeting</span></span>(to: *<span class="keyword">const</span> c_char) -&gt; *<span class="keyword">mut</span> c_char &#123;</span><br><span class="line">    <span class="keyword">let</span> c_str = <span class="keyword">unsafe</span> &#123; CStr::from_ptr(to) &#125;;</span><br><span class="line">    <span class="keyword">let</span> recipient = <span class="keyword">match</span> c_str.to_str() &#123;</span><br><span class="line">        <span class="literal">Err</span>(_) =&gt; <span class="string">"there"</span>,</span><br><span class="line">        <span class="literal">Ok</span>(string) =&gt; string,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    CString::new(<span class="string">"Hello "</span>.to_owned() + recipient)</span><br><span class="line">        .unwrap()</span><br><span class="line">        .into_raw()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">fn</span> <span class="title">rust_greeting_free</span></span>(s: *<span class="keyword">mut</span> c_char) &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> s.is_null() &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        CString::from_raw(s)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><ol start="2"><li><strong>greetings.h ：</strong>src下添加一个名为 greetings.h 的新文件，来定义一下 C 接口，iOS调用的Rust函数在这里定义</li></ol></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">char</span>* rust_greeting(<span class="keyword">const</span> <span class="built_in">char</span>* to);</span><br><span class="line">void rust_greeting_free(<span class="built_in">char</span> *);</span><br></pre></td></tr></table></figure><ul><li><ol start="3"><li><strong>Cargo.toml定义编译类型：</strong><br>staticlib 编译会生成 .a 文件（在 Linux 和 MacOS 上），或 .lib 文件（在 Windows 上）。</li></ol></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[lib]</span><br><span class="line">name = &quot;greetings&quot;</span><br><span class="line">crate-type = [&quot;staticlib&quot;, &quot;cdylib&quot;]</span><br></pre></td></tr></table></figure><ul><li><ol start="4"><li><strong>编译成静态库:</strong></li></ol></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo lipo --release</span><br></pre></td></tr></table></figure><p>构建产物位置在 target/下，通用 iOS 库的位置在  /target/universal/release/libRust_iOS.a</p><h2 id="四，iOS工程引入Rust库："><a href="#四，iOS工程引入Rust库：" class="headerlink" title="四，iOS工程引入Rust库："></a>四，iOS工程引入Rust库：</h2><h3 id="导入-libRust-iOS-a-库"><a href="#导入-libRust-iOS-a-库" class="headerlink" title="导入 libRust_iOS.a 库:"></a>导入 libRust_iOS.a 库:</h3><ul><li>创建demo ios 工程, <strong>导入 libRust_iOS.a 库</strong>（从rust工程找到，直接拖进入工程target下general）</li><li>链接 libresolv.tbd。 点击 Linked Frameworks 列表底部的 + 并在搜索框中键入 libresolv。 选择 libresolv.tbd</li></ul><h3 id="bridging-header创建："><a href="#bridging-header创建：" class="headerlink" title="bridging header创建："></a>bridging header创建：</h3><ul><li><p>创建之前先把之前定义在rust工程里的.h文件引入过来，这个.h文件是rust代码调用的声明入口(File\Add files to“iOSIntegratingRust” )</p></li><li><p><strong>创建bridging header：</strong> File\New\File..。 从提供的选项中选择 iOS Source Header File 并选择 Next。 将文件命名为 Greetings-Bridging-Header.h 并选择 Create</p></li><li><p>引入greetings.h</p></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#ifndef Greetings_Bridging_Header_h</span><br><span class="line">#define Greetings_Bridging_Header_h</span><br><span class="line">#import <span class="string">"greetings.h"</span></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h3 id="iOS-Build-Settings"><a href="#iOS-Build-Settings" class="headerlink" title="iOS Build Settings:"></a>iOS Build Settings:</h3><ul><li><strong>设置Objective-C Bridging Header链接要的.h文件</strong>， 工程 target 里打开 Build Settings 选项卡。 将 Objective-C Bridging Header设置为$(PROJECT_DIR)/Greetings-Bridging-Header.h （要看自己.h所在的位置）</li><li><strong>设置 Xcode 要链接 Rust 库的路径</strong>，  Build Settings 中 Library Search Paths中设置 $(PROJECT_DIR)/../Rust_iOS/target/universal/release (要看自己库实际位置)</li></ul><h2 id="五，iOS代码调用："><a href="#五，iOS代码调用：" class="headerlink" title="五，iOS代码调用："></a>五，iOS代码调用：</h2><ul><li>从刚demo工程里新建一个 swift 文件，命名为 RustGreetings</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RustGreetings</span> &#123;</span></span><br><span class="line">    func sayHello(to: String) -&gt; String &#123;</span><br><span class="line">        let result = rust_greeting(to)</span><br><span class="line">        let swift_result = String(cString: result!)</span><br><span class="line">        rust_greeting_free(UnsafeMutablePointer(mutating: result))</span><br><span class="line">        <span class="keyword">return</span> swift_result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ViewController.swift里 添加代码验证调用</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">override</span> func <span class="title">viewDidLoad</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    super.viewDidLoad()</span><br><span class="line">    <span class="comment">// Do any additional setup after loading the view.</span></span><br><span class="line">    let rustGreetings = RustGreetings()</span><br><span class="line">    print(<span class="string">"\(rustGreetings.sayHello(to: "</span>world<span class="string">"))"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>例子只验证rust调用使用的过程 <a href="https://github.com/zhulg/iOSUseRust" target="_blank" rel="noopener">源码下载</a> ，有问题邮件我<a href="mailto:lg.json@gmail.com" target="_blank" rel="noopener">lg.json@gmail.com</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;iOS调用Rust&quot;&gt;&lt;a href=&quot;#iOS调用Rust&quot; class=&quot;headerlink&quot; title=&quot;iOS调用Rust&quot;&gt;&lt;/a&gt;iOS调用Rust&lt;/h1&gt;&lt;h2 id=&quot;一，开发环境：&quot;&gt;&lt;a href=&quot;#一，开发环境：&quot; class=&quot;he</summary>
      
    
    
    
    <category term="Rust" scheme="https://zhulg.github.io/categories/Rust/"/>
    
    
    <category term="Rust" scheme="https://zhulg.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Android集成Rust使用</title>
    <link href="https://zhulg.github.io/posts/fc64e719.html"/>
    <id>https://zhulg.github.io/posts/fc64e719.html</id>
    <published>2022-10-19T14:47:19.000Z</published>
    <updated>2024-07-07T04:21:27.923Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Andorid调用Rust"><a href="#Andorid调用Rust" class="headerlink" title="Andorid调用Rust"></a>Andorid调用Rust</h1><ul><li>目前rust在移动端上的应用，一般作为应用sdk的提供，供各端使用，目前飞书底层使用Rust编写通用组件。</li><li>末尾附带该使用Rust工程源码，供初学者集成原理学习使用（简单步骤有省略，有疑问可邮件我）</li></ul><h2 id="一，开发环境："><a href="#一，开发环境：" class="headerlink" title="一，开发环境："></a>一，开发环境：</h2><ul><li>确保rust开发环境，推荐官方文档, 安装即可</li><li>Android相关开发环境，需要NDK的下载安装</li><li>环境变量的配置，为命令行使用提供全局环境</li></ul><h3 id="开发工具："><a href="#开发工具：" class="headerlink" title="开发工具："></a>开发工具：</h3><ul><li><ol><li>如果对android studio比较熟悉，可安装rust插件 <strong>（若文中图片无法显示，请科学上网查看：<a href="https://order.yizhihongxing.network/aff.php?aff=12299" target="_blank" rel="noopener">推荐工具</a>）</strong></li></ol></li></ul><div align="center" width="100%">  <img width="80%" src="https://github.com/zhulg/allpic/blob/master/vs_rust.png?raw=true"></div>安装完毕，对Rust Toolchain 位置进行配置确认，否则可能对rs文件无法识别，就无法愉快使用studio编写rust<ul><li><ol start="2"><li><strong>VScode: 推荐使用编写rust代码。</strong></li></ol></li></ul><h2 id="二，创建Android工程"><a href="#二，创建Android工程" class="headerlink" title="二，创建Android工程:"></a>二，创建Android工程:</h2><ul><li>与普通Android工程创建一样，创建Empty Activity</li><li>先编译通过该空工程</li></ul><h2 id="三，添加rust-lib库："><a href="#三，添加rust-lib库：" class="headerlink" title="三，添加rust lib库："></a>三，添加rust lib库：</h2><ul><li>进入到刚创建的AndroidIntegratingRust工程下</li></ul><h3 id="使用rust-Cargo创建-lib库："><a href="#使用rust-Cargo创建-lib库：" class="headerlink" title="使用rust Cargo创建 lib库："></a>使用rust Cargo创建 lib库：</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cargo new rust_lib --lib</span><br></pre></td></tr></table></figure><ul><li>创建成功后会有rust_lib库，结构如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">├── app</span><br><span class="line">│   ├── build</span><br><span class="line">│   ├── build.gradle</span><br><span class="line">│   ├── libs</span><br><span class="line">│   ├── proguard-rules.pro</span><br><span class="line">│   └── src</span><br><span class="line">├── build</span><br><span class="line">│   └── kotlin</span><br><span class="line">├── build.gradle</span><br><span class="line">├── gradle</span><br><span class="line">│   └── wrapper</span><br><span class="line">├── gradle.properties</span><br><span class="line">├── gradlew</span><br><span class="line">├── gradlew.bat</span><br><span class="line">├── local.properties</span><br><span class="line">├── rust_lib //位置在这</span><br><span class="line">│   ├── Cargo.lock</span><br><span class="line">│   ├── Cargo.toml</span><br><span class="line">│   ├── src</span><br><span class="line">│   └── target</span><br><span class="line">└── settings.gradle</span><br></pre></td></tr></table></figure><h3 id="编辑Cargo-toml"><a href="#编辑Cargo-toml" class="headerlink" title="编辑Cargo.toml"></a>编辑Cargo.toml</h3><ul><li>输入目前需要的jni库依赖, <a href="https://crates.io/" target="_blank" rel="noopener">https://crates.io/</a>地址下确认版本, create-type 填写cdylib 动态链接库</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[lib]</span><br><span class="line">name = <span class="string">"rust_lib"</span></span><br><span class="line">crate-type = ["cdylib"]</span><br><span class="line"></span><br><span class="line">[dependencies]</span><br><span class="line">jni = <span class="string">"0.20.0"</span></span><br></pre></td></tr></table></figure><h3 id="配置要编译so的linker及target"><a href="#配置要编译so的linker及target" class="headerlink" title="配置要编译so的linker及target"></a>配置要编译so的linker及target</h3><ul><li><strong>这个在rust_lib下创建.cargo目录，添加config.toml配置文件</strong></li><li>填入linker对应的ndk地址：</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[target.aarch64-linux-android]</span><br><span class="line">linker = <span class="string">"/Users/android-sdk-macosx/ndk-bundle/toolchains/llvm/prebuilt/darwin-x86_64/bin/aarch64-linux-android21-clang++"</span></span><br><span class="line"></span><br><span class="line">[target.armv7-linux-androideabi]</span><br><span class="line">linker = <span class="string">"/Users/android-sdk-macosx/ndk-bundle/toolchains/llvm/prebuilt/darwin-x86_64/bin/armv7a-linux-androideabi21-clang++"</span></span><br></pre></td></tr></table></figure><p> ps: 这是我的mac上ndk所在位置，参考Android官方ndk文档。</p><ul><li>准备编译rust代码为so的环境已经准备完</li></ul><h2 id="四，开始编写Android和Rust代码："><a href="#四，开始编写Android和Rust代码：" class="headerlink" title="四，开始编写Android和Rust代码："></a>四，开始编写Android和Rust代码：</h2><ul><li><p>创建Android代码, RustGreetings类， 使用kotlin所以用external声明JNI函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class RustGreetings &#123;</span><br><span class="line">    fun sayHello(to: String): String &#123;</span><br><span class="line">        return greeting(to)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    companion object &#123;</span><br><span class="line">        @JvmStatic external fun greeting(pattern: String): String</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在Rust lib库下，编写对应的JNI函数映射，从create.io下可以看到有关JNI的使用，代码如下</p></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> jni::JNIEnv;</span><br><span class="line"></span><br><span class="line"><span class="comment">// These objects are what you should use as arguments to your native</span></span><br><span class="line"><span class="comment">// function. They carry extra lifetime information to prevent them escaping</span></span><br><span class="line"><span class="comment">// this context and getting used after being GC'd.</span></span><br><span class="line"><span class="keyword">use</span> jni::objects::&#123;JClass, JString&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This is just a pointer. We'll be returning it from our function. We</span></span><br><span class="line"><span class="comment">// can't return one of the objects with lifetime information because the</span></span><br><span class="line"><span class="comment">// lifetime checker won't let us.</span></span><br><span class="line"><span class="keyword">use</span> jni::sys::jstring;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This keeps Rust from "mangling" the name and making it unique for this</span></span><br><span class="line"><span class="comment">// crate.</span></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">"system"</span> <span class="function"><span class="keyword">fn</span> <span class="title">Java_com_android_integratingrust_RustGreetings_greeting</span></span>(</span><br><span class="line">    env: JNIEnv,</span><br><span class="line">    <span class="comment">// This is the class that owns our static method. It's not going to be used,</span></span><br><span class="line">    <span class="comment">// but still must be present to match the expected signature of a static</span></span><br><span class="line">    <span class="comment">// native method.</span></span><br><span class="line">    class: JClass,</span><br><span class="line">    input: JString,</span><br><span class="line">) -&gt; jstring &#123;</span><br><span class="line">    <span class="comment">// First, we have to get the string out of Java. Check out the `strings`</span></span><br><span class="line">    <span class="comment">// module for more info on how this works.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> input: <span class="built_in">String</span> = env</span><br><span class="line">        .get_string(input)</span><br><span class="line">        .expect(<span class="string">"Couldn't get java string!"</span>)</span><br><span class="line">        .into();</span><br><span class="line"></span><br><span class="line">    input = append_string(&amp;input);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Then we have to create a new Java string to return. Again, more info</span></span><br><span class="line">    <span class="comment">// in the `strings` module.</span></span><br><span class="line">    <span class="keyword">let</span> output = env</span><br><span class="line">        .new_string(<span class="built_in">format!</span>(<span class="string">"Hello, &#123;&#125;!"</span>, input))</span><br><span class="line">        .expect(<span class="string">"Couldn't create java string!"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Finally, extract the raw pointer to return.</span></span><br><span class="line">    output.into_raw()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//============== rust code ===============</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">append_string</span></span>(value: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> origin = <span class="built_in">String</span>::from(value);</span><br><span class="line">    origin.push_str(<span class="string">"this is Rust"</span>);</span><br><span class="line">    <span class="keyword">return</span> origin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五，编译Rust代码为so"><a href="#五，编译Rust代码为so" class="headerlink" title="五，编译Rust代码为so"></a>五，编译Rust代码为so</h2><ul><li><p>编译之前确认之前rust环境是可以使用的了，且要看下rustup target 下是否已经有要交叉编译的工具了。</p></li><li><p>rustc –print target-list | grep android 可以查看相关android 交叉编译工具,（我们demo之前在配置target时，使用了32和64位的ARM CPU 架构linker）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">aarch64-linux-android</span><br><span class="line">arm-linux-androideabi</span><br><span class="line">armv7-linux-androideabi</span><br><span class="line">i686-linux-android</span><br><span class="line">thumbv7neon-linux-androideabi</span><br><span class="line">x86_64-linux-android</span><br></pre></td></tr></table></figure></li><li><p>如果没有安装，需要安装下对应的</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rustup target add aarch64-linux-android armv7-linux-androideabi</span><br></pre></td></tr></table></figure><ul><li>rustup show 可以看到当前rust开发语言环境，包括 （installed targets for active toolchain）</li><li>rustup target list可以查看到那些已经安装和rust支持的。</li></ul><h3 id="执行编译"><a href="#执行编译" class="headerlink" title="执行编译"></a>执行编译</h3><ul><li>到rust_lib目录下执行编译</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo build --target aarch64-linux-android --release</span><br></pre></td></tr></table></figure><ul><li>编译成功到target目录下release下去查看对应的so文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── CACHEDIR.TAG</span><br><span class="line">├── aarch64-linux-android</span><br><span class="line">│   ├── CACHEDIR.TAG</span><br><span class="line">│   └── release</span><br><span class="line">├── armv7-linux-androideabi</span><br><span class="line">│   ├── CACHEDIR.TAG</span><br><span class="line">│   └── release</span><br><span class="line">├── debug</span><br><span class="line">│   ├── build</span><br><span class="line">│   ├── deps</span><br><span class="line">│   ├── examples</span><br><span class="line">│   └── incremental</span><br><span class="line">└── release</span><br><span class="line">    ├── build</span><br><span class="line">    ├── deps</span><br><span class="line">    ├── examples</span><br><span class="line">    └── incremental</span><br></pre></td></tr></table></figure><h2 id="使用rust代码运行工程"><a href="#使用rust代码运行工程" class="headerlink" title="使用rust代码运行工程"></a>使用rust代码运行工程</h2><ul><li>copy 对应的so文件到 Android工程下src/main/libs下</li><li>在Android工程下build.gradle下记得引用so为jniLibs</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sourceSets &#123;</span><br><span class="line">    main &#123;</span><br><span class="line">        jniLibs.srcDirs = [&apos;src/main/libs&apos;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>至此，应该可以直接运行看效果了，<strong>如果有需帮助可以邮件我，或者下载源码</strong>  <a href="https://github.com/zhulg/AndroidIntegratingRust" target="_blank" rel="noopener">地址</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Andorid调用Rust&quot;&gt;&lt;a href=&quot;#Andorid调用Rust&quot; class=&quot;headerlink&quot; title=&quot;Andorid调用Rust&quot;&gt;&lt;/a&gt;Andorid调用Rust&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;目前rust在移动端上的应用，一般作为应</summary>
      
    
    
    
    <category term="Rust" scheme="https://zhulg.github.io/categories/Rust/"/>
    
    
    <category term="Rust" scheme="https://zhulg.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust学习精简笔记总结(三)</title>
    <link href="https://zhulg.github.io/posts/15eb29eb.html"/>
    <id>https://zhulg.github.io/posts/15eb29eb.html</id>
    <published>2022-10-16T02:21:29.000Z</published>
    <updated>2024-07-07T04:21:27.925Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Rust精简笔记第3部分"><a href="#Rust精简笔记第3部分" class="headerlink" title="Rust精简笔记第3部分"></a>Rust精简笔记第3部分</h1><ul><li>继续整理rust笔记，过程会发现一些rust盲区理解，可深入源码学习, 从笔记知识点映射背后源码定义。</li><li><em>参考The Rust Programming Language &amp;  Rust in Action</em></li></ul><h2 id="十一，指针-amp-智能指针"><a href="#十一，指针-amp-智能指针" class="headerlink" title="十一，指针&amp;智能指针"></a>十一，指针&amp;智能指针</h2><ul><li>指针是一个包含内存地址的变量的通用概念， 智能指针（smart pointers）是一类数据结构，他们的表现类似指针，但是也拥有额外的元数据和功能</li><li>智能指针通常使用结构体实现，智能指针其实现了 Deref 和 Drop trait(离开作用域时运行的代码)</li></ul><h4 id="1-Box-用于在堆上分配值"><a href="#1-Box-用于在堆上分配值" class="headerlink" title="1. Box 用于在堆上分配值:"></a>1. Box<t> 用于在堆上分配值:</t></h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> b = <span class="built_in">Box</span>::new(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h4 id="2-Rc-引用计数智能指针"><a href="#2-Rc-引用计数智能指针" class="headerlink" title="2. Rc 引用计数智能指针:"></a>2. Rc<t> 引用计数智能指针:</t></h4><ul><li>Rc<t> 只能用于单线程场景</t></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Rc::clone 只会增加引用计数, 这样a,b都是指向1</span></span><br><span class="line"> <span class="keyword">let</span> a = Rc::new(<span class="number">1</span>);</span><br><span class="line"> <span class="keyword">let</span> b = Rc::clone(&amp;a);</span><br></pre></td></tr></table></figure><h4 id="3-RefCell-lt-T-gt-和内部可变性模式"><a href="#3-RefCell-lt-T-gt-和内部可变性模式" class="headerlink" title="3. RefCell&lt;T&gt; 和内部可变性模式:"></a>3. RefCell&lt;T&gt; 和内部可变性模式:</h4><ul><li><strong>RefCell&lt;T&gt; 代表其数据的唯一的所有权</strong>, 他具有如下特点:</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在任意给定时刻，只能拥有一个可变引用或任意数量的不可变引用 之一（而不是两者）。</span></span><br><span class="line"><span class="comment">//引用必须总是有效的。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> r1 = RefCell::new(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// Ref - 只有一个不可变借用</span></span><br><span class="line">    <span class="keyword">let</span> r2 = r1.borrow();</span><br><span class="line">    <span class="comment">// RefMut - mutable  可变借用</span></span><br><span class="line">    <span class="keyword">let</span> r3 = r1.borrow_mut();</span><br><span class="line">    <span class="comment">// RefMut - 可变借用</span></span><br><span class="line">    <span class="keyword">let</span> r4 = r1.borrow_mut();</span><br></pre></td></tr></table></figure><ul><li><strong>内部可变性（Interior mutability):</strong><br>  是Rust 中的一个设计模式，它允许你即使在有不可变引用时也可以改变数据。</li><li>实现是通过不可变的Rc&lt;T&gt;, 此时的T的类型为RefCell&lt;T&gt;， <strong>即结合成Rc&lt;RefCell&lt;T&gt;&gt; 来实现内部可变性</strong>，而外部是无法修改的。     </li><li>let value = Rc::new(RefCell::new(5)) 完整例子如下：</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span></span> &#123;</span><br><span class="line">    Cons(Rc&lt;RefCell&lt;<span class="built_in">i32</span>&gt;&gt;, Rc&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> value = Rc::new(RefCell::new(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> a = Rc::new(Cons(Rc::clone(&amp;value), Rc::new(Nil)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> b = Cons(Rc::new(RefCell::new(<span class="number">3</span>)), Rc::clone(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> c = Cons(Rc::new(RefCell::new(<span class="number">4</span>)), Rc::clone(&amp;a));</span><br><span class="line"></span><br><span class="line">    *value.borrow_mut() += <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"a after = &#123;:?&#125;"</span>, a);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"b after = &#123;:?&#125;"</span>, b);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"c after = &#123;:?&#125;"</span>, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="十二，使用和引用模块代码："><a href="#十二，使用和引用模块代码：" class="headerlink" title="十二，使用和引用模块代码："></a>十二，使用和引用模块代码：</h2><ul><li>模块的创建和引用</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">some_function</span></span>() &#123;&#125;</span><br><span class="line"><span class="keyword">mod</span> outer_module &#123;</span><br><span class="line">    <span class="comment">// private module</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> inner_module &#123;</span><br><span class="line">        <span class="comment">// public module</span></span><br><span class="line">        <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">inner_public_function</span></span>() &#123;</span><br><span class="line">            super::super::some_function();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">inner_private_function</span></span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 绝对路径 从 crate 根开始，以 crate 名或者字面值 crate 开头。</span></span><br><span class="line">    crate::outer_module::inner_module::inner_public_function();</span><br><span class="line">    <span class="comment">//  相对路径（relative path）从当前模块开始，以 self、super 或当前模块的标识符开头。</span></span><br><span class="line">    outer_module::inner_module::inner_public_function();</span><br><span class="line">    <span class="comment">// 使用 use 关键字将路径引入作用域</span></span><br><span class="line">    <span class="keyword">use</span> outer_module::inner_module;</span><br><span class="line">    inner_module::inner_public_function();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Rust精简笔记第3部分&quot;&gt;&lt;a href=&quot;#Rust精简笔记第3部分&quot; class=&quot;headerlink&quot; title=&quot;Rust精简笔记第3部分&quot;&gt;&lt;/a&gt;Rust精简笔记第3部分&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;继续整理rust笔记，过程会发现一些rust盲区</summary>
      
    
    
    
    <category term="Rust" scheme="https://zhulg.github.io/categories/Rust/"/>
    
    
    <category term="Rust" scheme="https://zhulg.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust学习精简笔记总结(二)</title>
    <link href="https://zhulg.github.io/posts/6b1809c0.html"/>
    <id>https://zhulg.github.io/posts/6b1809c0.html</id>
    <published>2022-10-03T14:06:44.000Z</published>
    <updated>2024-07-07T04:21:27.925Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Rust精简笔记第2部分"><a href="#Rust精简笔记第2部分" class="headerlink" title="Rust精简笔记第2部分"></a>Rust精简笔记第2部分</h1><ul><li>继续Rust基础知识点总结，趁假期回顾学习</li><li><em>参考The Rust Programming Language &amp;  Rust in Action</em></li></ul><h2 id="八，泛型、Trait、生命周期"><a href="#八，泛型、Trait、生命周期" class="headerlink" title="八，泛型、Trait、生命周期"></a>八，泛型、Trait、生命周期</h2><h4 id="泛型："><a href="#泛型：" class="headerlink" title="泛型："></a>泛型：</h4><ul><li><strong>函数定义中使用泛型</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; T &#123;</span><br><span class="line">&#125;</span><br><span class="line">//函数 largest 有泛型类型 T。它有个参数 list，其类型是元素为 T 的 slice。largest 函数的返回值类型也是 T</span><br><span class="line">//类型参数声明位于函数名称与参数列表中间的尖括号 &lt;&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>结构体定义中的泛型</strong></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> integer = Point &#123; x: <span class="number">5</span>, y: <span class="number">10</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> float = Point &#123; x: <span class="number">1.0</span>, y: <span class="number">4.0</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>枚举定义中的泛型</strong></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Option</span></span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="literal">Some</span>(T),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Result</span></span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="literal">Ok</span>(T),</span><br><span class="line">    <span class="literal">Err</span>(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>方法定义中的泛型</strong></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Point&lt;T&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">x</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;T &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> p = Point &#123; x: <span class="number">5</span>, y: <span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"p.x = &#123;&#125;"</span>, p.x());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Trait："><a href="#Trait：" class="headerlink" title="Trait："></a>Trait：</h4><ul><li>通过 trait 以一种抽象的方式定义共享的行为,<em>trait</em>  类似于其他语言中的接口，但也不完全一样.</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义 trait Summary ,定义summarize调取-&gt;summarize_author默认方法，达到调用默认行为，区分开实现trait的的定义</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Summary</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">summarize_author</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span>;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">summarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">"(Read more from &#123;&#125;...)"</span>, <span class="keyword">self</span>.summarize_author())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Tweet</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> username: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> reply: <span class="built_in">bool</span>,</span><br><span class="line">    <span class="keyword">pub</span> retweet: <span class="built_in">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现 trait Summary</span></span><br><span class="line"><span class="keyword">impl</span> Summary <span class="keyword">for</span> Tweet &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">summarize_author</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">"@&#123;&#125;"</span>, <span class="keyword">self</span>.username)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> tweet = Tweet &#123;</span><br><span class="line">        username: <span class="built_in">String</span>::from(<span class="string">"horse_ebooks"</span>),</span><br><span class="line">        content: <span class="built_in">String</span>::from(<span class="string">"of course, as you probably already know, people"</span>),</span><br><span class="line">        reply: <span class="literal">false</span>,</span><br><span class="line">        retweet: <span class="literal">false</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"1 new tweet: &#123;&#125;"</span>, tweet.summarize());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>trait 作为参数：</strong></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法接收是实现了 trait Summary的类型</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>(item: &amp;<span class="keyword">impl</span> Summary) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Breaking news! &#123;&#125;"</span>, item.summarize());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>Trait Bound：</strong><br>  impl Trait 适用于短小的例子。trait bound 则适用于更复杂的场景，trait bound 与泛型参数声明在一起，位于尖括号中的冒号后面。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用相同类型的trait可以转换成下边的更简单写法</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>(item1: &amp;<span class="keyword">impl</span> Summary, item2: &amp;<span class="keyword">impl</span> Summary) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// trait Bound的写法</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>&lt;T: Summary&gt;(item1: &amp;T, item2: &amp;T) &#123;&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>通过 <code>+</code> 指定多个 trait bound:</strong></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>&lt;T: Summary + Display&gt;(item: &amp;T) &#123;&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>通过 <code>where</code> 简化 trait bound：</strong></p><p>每个泛型有其自己的 trait bound，所以有多个泛型参数的函数在名称和参数列表之间会有很长的 trait bound 信息，这使得函数签名难以阅读</p></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">some_function</span></span>&lt;T, U&gt;(t: &amp;T, u: &amp;U) -&gt; <span class="built_in">i32</span></span><br><span class="line">    <span class="keyword">where</span> T: Display + <span class="built_in">Clone</span>,</span><br><span class="line">          U: <span class="built_in">Clone</span> + <span class="built_in">Debug</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="声明周期："><a href="#声明周期：" class="headerlink" title="声明周期："></a>声明周期：</h4><ul><li><p>Rust 中的每一个引用都有其 生命周期（lifetime），也就是引用保持有效的作用域，Rust 编译器有一个借用检查器（borrow checker）它比较作用域来确保所有的借用都是有效的</p></li><li><p><strong>函数签名中的生命周期注解：</strong></p></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">longest</span></span>&lt;<span class="symbol">'a</span>&gt;(x: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>, y: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>) -&gt; &amp;<span class="symbol">'a</span> <span class="built_in">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.len() &gt; y.len() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> string1 = <span class="built_in">String</span>::from(<span class="string">"abcd"</span>);</span><br><span class="line">    <span class="keyword">let</span> string2 = <span class="string">"xyz"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> result = longest(string1.as_str(), string2);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"The longest string is &#123;&#125;"</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>参数声明周期使用方法，或者靠编译器提示添加。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;<span class="built_in">i32</span>        <span class="comment">// 引用, 没有生命周期参数的 i32 的引用</span></span><br><span class="line">&amp;<span class="symbol">'a</span> <span class="built_in">i32</span>     <span class="comment">// 带有显式生命周期的引用 ，一个有叫做 'a 的生命周期参数的 i32 的引用</span></span><br><span class="line">&amp;<span class="symbol">'a</span> <span class="keyword">mut</span> <span class="built_in">i32</span> <span class="comment">// 带有显式生命周期的可变引用 一个生命周期也是 'a 的 i32 的可变引用</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>结构体定义中的生命周期注解：</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ImportantExcerpt</span></span>&lt;<span class="symbol">'a</span>&gt; &#123;</span><br><span class="line">    part: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> novel = <span class="built_in">String</span>::from(<span class="string">"Call me Ishmael. Some years ago..."</span>);</span><br><span class="line">    <span class="keyword">let</span> first_sentence = novel.split(<span class="string">'.'</span>).next().expect(<span class="string">"Could not find a '.'"</span>);</span><br><span class="line">    <span class="keyword">let</span> i = ImportantExcerpt &#123;</span><br><span class="line">        part: first_sentence,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>静态生命周期:</strong></p></li><li><p>生命周期能够存活于整个程序期间。所有的字符串字面值都拥有 ‘static 生命周期</p></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s: &amp;<span class="symbol">'static</span> <span class="built_in">str</span> = <span class="string">"I have a static lifetime."</span>;</span><br></pre></td></tr></table></figure><h2 id="九，集合："><a href="#九，集合：" class="headerlink" title="九，集合："></a>九，集合：</h2><h4 id="vector"><a href="#vector" class="headerlink" title="vector:"></a>vector:</h4><ul><li>类型是 Vec<t> 在内存中彼此相邻地排列所有的值, vector 只能储存相同类型的值</t></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vec::new 创建</span></span><br><span class="line"><span class="keyword">let</span> v: <span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt; = <span class="built_in">Vec</span>::new();</span><br><span class="line">v.push(<span class="number">2</span>);</span><br><span class="line">v.push(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">let</span> x = v.pop();</span><br></pre></td></tr></table></figure><ul><li><strong>初始值来创建一个 Vec<t> :</t></strong></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure><ul><li><strong>读取 vector 的元素:</strong><br>   使用 &amp;[index] 返回一个引用, 或者使用 get 方法以索引作为参数来返回一个 Option&lt;&amp;T&gt;。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> third: &amp;<span class="built_in">i32</span> = &amp;v[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"The third element is &#123;&#125;"</span>, third);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> v.get(<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="literal">Some</span>(third) =&gt; <span class="built_in">println!</span>(<span class="string">"The third element is &#123;&#125;"</span>, third),</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">"There is no third element."</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>使用枚举来储存多种类型:</strong><br>  创建一个储存枚举值的 vector，这样最终就能够通过vector存储实际是不同类型的值了</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">SpreadsheetCell</span></span> &#123;</span><br><span class="line">        Int(<span class="built_in">i32</span>),</span><br><span class="line">        Float(<span class="built_in">f64</span>),</span><br><span class="line">        Text(<span class="built_in">String</span>),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> row = <span class="built_in">vec!</span>[</span><br><span class="line">        SpreadsheetCell::Int(<span class="number">3</span>),</span><br><span class="line">        SpreadsheetCell::Text(<span class="built_in">String</span>::from(<span class="string">"blue"</span>)),</span><br><span class="line">        SpreadsheetCell::Float(<span class="number">10.12</span>),</span><br><span class="line">    ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> scores = HashMap::new();</span><br><span class="line">scores.insert(<span class="built_in">String</span>::from(<span class="string">"Blue"</span>), <span class="number">10</span>); <span class="comment">//插入</span></span><br><span class="line"><span class="comment">//只在键没有对应值时插入</span></span><br><span class="line">scores.entry(<span class="built_in">String</span>::from(<span class="string">"Yellow"</span>)).or_insert(<span class="number">50</span>);</span><br><span class="line">scores.entry(<span class="built_in">String</span>::from(<span class="string">"Blue"</span>)).or_insert(<span class="number">50</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, scores);</span><br></pre></td></tr></table></figure><ul><li>more： <a href="https://doc.rust-lang.org/std/collections/index.html" target="_blank" rel="noopener">https://doc.rust-lang.org/std/collections/index.html</a></li></ul><h2 id="十，函数、闭包、迭代器"><a href="#十，函数、闭包、迭代器" class="headerlink" title="十，函数、闭包、迭代器"></a>十，函数、闭包、迭代器</h2><h4 id="函数："><a href="#函数：" class="headerlink" title="函数："></a>函数：</h4><ul><li>函数的定义方式及在结构体实现里关联函数，关联函数与方法的使用区别</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::primitive;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span> &#123;</span><br><span class="line">    x: <span class="built_in">i32</span>,</span><br><span class="line">    y: <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> Point &#123;</span><br><span class="line">    <span class="comment">// 关联函数(没有self相关参数)</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(x: <span class="built_in">i32</span>, y: <span class="built_in">i32</span>) -&gt; Point &#123;</span><br><span class="line">        Point &#123; x: x, y: y &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 方法(参数为&amp;self，是个隐示的，调用时无需传递表明是该类型而已）</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">get_x</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">//关联函数使用:: 方法使用类型.方法，如Point::new, point.get_x</span></span><br><span class="line">    <span class="keyword">let</span> point = Point::new(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"get x=&#123;&#125;"</span>, point.get_x());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="闭包："><a href="#闭包：" class="headerlink" title="闭包："></a>闭包：</h4><ul><li><strong>闭包（closures）</strong>是可以保存在一个变量中或作为参数传递给其他函数的匿名函数。 闭包的定义以一对竖线（|）开始，在竖线中指定闭包的参数</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span>  <span class="title">add_one_v1</span>   </span>(x: <span class="built_in">u32</span>) -&gt; <span class="built_in">u32</span> &#123; x + <span class="number">1</span> &#125;  <span class="comment">//函数的定义</span></span><br><span class="line"><span class="keyword">let</span> add_one_v2 = |x: <span class="built_in">u32</span>| -&gt; <span class="built_in">u32</span> &#123; x + <span class="number">1</span> &#125;; <span class="comment">// 完整标注的闭包定义</span></span><br><span class="line"><span class="keyword">let</span> add_one_v3 = |x|             &#123; x + <span class="number">1</span> &#125;;  <span class="comment">// 闭包定义中省略了类型注解</span></span><br><span class="line"><span class="keyword">let</span> add_one_v4 = |x|               x + <span class="number">1</span>  ;  <span class="comment">// 闭包体只有一行,去掉了大括号</span></span><br></pre></td></tr></table></figure><ul><li><strong>闭包会捕获其环境:</strong> </li><li>可以捕获其环境并访问其被定义的作用域的变量。如下边 x 并不是 equal_to_x 的一个参数，equal_to_x 闭包也被允许使用变量 x，因为它与 equal_to_x 定义于相同的作用域</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">let</span> equal_to_x = |z| z == x;</span><br><span class="line">    <span class="keyword">let</span> y = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert!</span>(equal_to_x(y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong><em>当闭包从环境中捕获一个值，闭包会在闭包体中储存这个值以供使用，这会使用内存并产生额外的开销。</em></strong></p></li><li><p>闭包可以通过三种方式捕获其环境，他们直接对应函数的三种获取参数的方式：获取所有权，可变借用和不可变借用。</p></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">FnOnce</span> 消费从周围作用域捕获的变量，闭包周围的作用域被称为其 环境，environment。为了消费捕获到的变量，闭包必须获取其所有权并在定义闭包时将其移动进闭包。其名称的 Once 部分代表了闭包不能多次获取相同变量的所有权的事实，所以它只能被调用一次</span><br><span class="line"><span class="built_in">FnMut</span> 获取可变的借用值所以可以改变其环境</span><br><span class="line"><span class="built_in">Fn</span> 从其环境获取不可变的借用值</span><br></pre></td></tr></table></figure><p>由于所有闭包都可以被调用至少一次，所以所有闭包都实现了 FnOnce .<strong>大部分需要指定一个 Fn 系列 trait bound 的时候，可以从 Fn 开始，而编译器会根据闭包体中的情况告诉你是否需要 FnMut 或 FnOnce。</strong></p><ul><li><strong>带有泛型和 Fn trait 的闭包:</strong><br>  可以创建一个存放闭包和调用闭包结果的结构体, 目的：结构体只会在需要结果时执行闭包，并会缓存结果值，再次调用闭包可以复用该值.</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cacher</span></span>&lt;T&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: <span class="built_in">Fn</span>(<span class="built_in">u32</span>) -&gt; <span class="built_in">u32</span>,</span><br><span class="line">&#123;</span><br><span class="line">    calculation: T,</span><br><span class="line">    value: <span class="built_in">Option</span>&lt;<span class="built_in">u32</span>&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong><em>创建Cache的结构体，泛型T类型使用where 声明类型为闭包，结构体包含一个闭包，和一个用于存放闭包返回的值的u32类型，因为有可能第一次没有缓存，所有使用Option<u32>的类型。即可能是some(u32) 或者None</u32></em></strong></p><ul><li><strong>官方完整例子：</strong></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cacher</span></span>&lt;T&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: <span class="built_in">Fn</span>(<span class="built_in">u32</span>) -&gt; <span class="built_in">u32</span>,</span><br><span class="line">&#123;</span><br><span class="line">    calculation: T,</span><br><span class="line">    value: <span class="built_in">Option</span>&lt;<span class="built_in">u32</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Cacher&lt;T&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: <span class="built_in">Fn</span>(<span class="built_in">u32</span>) -&gt; <span class="built_in">u32</span>,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(calculation: T) -&gt; Cacher&lt;T&gt; &#123;</span><br><span class="line">        Cacher &#123;</span><br><span class="line">            calculation,</span><br><span class="line">            value: <span class="literal">None</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">value</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, arg: <span class="built_in">u32</span>) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span>.value &#123;</span><br><span class="line">            <span class="literal">Some</span>(v) =&gt; v,</span><br><span class="line">            <span class="literal">None</span> =&gt; &#123;</span><br><span class="line">                <span class="keyword">let</span> v = (<span class="keyword">self</span>.calculation)(arg);</span><br><span class="line">                <span class="keyword">self</span>.value = <span class="literal">Some</span>(v);</span><br><span class="line">                v</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">generate_workout</span></span>(intensity: <span class="built_in">u32</span>, random_number: <span class="built_in">u32</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> expensive_result = Cacher::new(|num| &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"calculating slowly..."</span>);</span><br><span class="line">        thread::sleep(Duration::from_secs(<span class="number">2</span>));</span><br><span class="line">        num</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> intensity &lt; <span class="number">25</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Today, do &#123;&#125; pushups!"</span>, expensive_result.value(intensity));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Next, do &#123;&#125; situps!"</span>, expensive_result.value(intensity));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> random_number == <span class="number">3</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"Take a break today! Remember to stay hydrated!"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(</span><br><span class="line">                <span class="string">"Today, run for &#123;&#125; minutes!"</span>,</span><br><span class="line">                expensive_result.value(intensity)</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> simulated_user_specified_value = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">let</span> simulated_random_number = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    generate_workout(simulated_user_specified_value, simulated_random_number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>a.这样可以起到了使用结构体缓存了闭包执行的结果，会先从结构体里查找缓存的值，没有再计算。<br>b.同理也可以改造value的类型为HashMap, 可以通过key来找值，避免返回之前计算的始终同一个值。</strong></p><h3 id="iterator"><a href="#iterator" class="headerlink" title="iterator:"></a>iterator:</h3><ul><li><strong>迭代器（iterator):</strong>负责遍历序列中的每一项和决定序列何时结束的逻辑。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v1 = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> v1_iter = v1.iter();</span><br><span class="line"><span class="keyword">let</span> total: <span class="built_in">i32</span> = v1_iter.sum();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"value = &#123;&#125;"</span>, &#123; total &#125;)</span><br></pre></td></tr></table></figure><ul><li>next 是 Iterator 实现者被要求定义的唯一方法</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v1 = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> v1_iter = v1.iter();</span><br><span class="line"><span class="built_in">assert_eq!</span>(v1_iter.next(), <span class="literal">Some</span>(&amp;<span class="number">1</span>));</span><br></pre></td></tr></table></figure><ul><li>调用 map 方法创建一个新迭代器，接着调用 collect 方法消费新迭代器并创建一个 vector</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//next 一次返回迭代器中的一个项，封装在 Some 中，当迭代器结束时，它返回 None</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> v1: <span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt; = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> newiter = v1.iter().map(|x| x + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> newVector: <span class="built_in">Vec</span>&lt;_&gt; = newiter.collect();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(newVector, <span class="built_in">vec!</span>[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><em>迭代器 iter()、iter_mut()、into_iter()区别：</em></strong></li></ul><ol><li>iter()返回的是值的不可变引用. 即&amp;T</li><li>iter_mut() 返回的是值的可变引用. 即&amp;mut T</li><li>into_iter() 返回的是T类型的值 </li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> core::num;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// iter() 返回的是值的不可变引用，即&amp;T.(此处map里闭包x本身无法改变)</span></span><br><span class="line">    <span class="keyword">let</span> vec = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">    <span class="keyword">let</span> new_vec: <span class="built_in">Vec</span>&lt;_&gt; = vec.iter().map(|x| x + <span class="number">1</span>).collect();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, vec);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, new_vec);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//iter_mut() 返回的是值的可变引用，即&amp;mut T.(此处map里闭包x本身+1)</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> vec = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">    vec.iter_mut().for_each(|x| *x += <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, vec);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//into_iter() 返回的是T类型的值  (因为所有权 vec是不能再使用)</span></span><br><span class="line">    <span class="keyword">let</span> vec = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">    <span class="keyword">let</span> new_vec: <span class="built_in">Vec</span>&lt;_&gt; = vec.into_iter().filter(|x| *x == <span class="number">2</span>).collect();</span><br><span class="line">    <span class="comment">// println!("&#123;:?&#125;", vec); // 无法编译</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, new_vec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>实现Iterator trait 来创建自定义迭代器:</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">struct Counter &#123;</span><br><span class="line">    count: u32,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Counter &#123;</span><br><span class="line">    fn new() -&gt; Counter &#123;</span><br><span class="line">        Counter &#123; count: 0 &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Counter 类型实现 Iterator trait，通过定义 next 方法来指定使用迭代器时的行为</span><br><span class="line">impl Iterator for Counter &#123;</span><br><span class="line">    type Item = u32; </span><br><span class="line">     //将迭代器的关联类型 Item 设置为 u32，意味着迭代器会返回 u32 值集合</span><br><span class="line">    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; &#123;</span><br><span class="line">        if self.count &lt; 5 &#123;</span><br><span class="line">            self.count += 1;</span><br><span class="line">            Some(self.count)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            None</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Rust里iterator的定义：</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Iterator</span></span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Item</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">next</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;Self::Item&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Rust精简笔记第2部分&quot;&gt;&lt;a href=&quot;#Rust精简笔记第2部分&quot; class=&quot;headerlink&quot; title=&quot;Rust精简笔记第2部分&quot;&gt;&lt;/a&gt;Rust精简笔记第2部分&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;继续Rust基础知识点总结，趁假期回顾学习&lt;/l</summary>
      
    
    
    
    <category term="Rust" scheme="https://zhulg.github.io/categories/Rust/"/>
    
    
    <category term="Rust" scheme="https://zhulg.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust学习精简笔记总结(一)</title>
    <link href="https://zhulg.github.io/posts/658f0ea2.html"/>
    <id>https://zhulg.github.io/posts/658f0ea2.html</id>
    <published>2022-09-24T06:53:01.000Z</published>
    <updated>2024-07-07T04:21:27.925Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Rust精简笔记"><a href="#Rust精简笔记" class="headerlink" title="Rust精简笔记"></a>Rust精简笔记</h1><ul><li>适用对Rust感兴趣，想快速学习上手（多学几轮）、Rust知识点速查、回顾。</li><li>精简总结使用，深入扩展需继续对应官网，真知实践。</li><li><em>参考The Rust Programming Language &amp;  Rust in Action</em></li></ul><h2 id="一-变量："><a href="#一-变量：" class="headerlink" title="一.变量："></a>一.<strong>变量：</strong></h2><ul><li><p><strong>变量声明使用let, 默认为不可变（即只读），声明可变变量 mut （可读写）</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">5</span>;  <span class="comment">//类型可以由编译器自动推断出来</span></span><br><span class="line"><span class="keyword">let</span> y: <span class="built_in">i32</span> = <span class="number">6</span>;  <span class="comment">//或者是在创建变量时，声明类型</span></span><br><span class="line"><span class="keyword">let</span> z = <span class="number">7i32</span>;  <span class="comment">//数字类型，可以在数字字面量中加入类型注解</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="二-基本数据类型："><a href="#二-基本数据类型：" class="headerlink" title="二.基本数据类型："></a>二.<strong>基本数据类型：</strong></h2><h4 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型:"></a>数字类型:</h4><ul><li>分为有符号和无符号整数，浮点数类型、特定平台的整数</li><li><strong>每一个有符号的变体可以储存包含从 -2<sup>n-1</sup> 到2<sup>n-1</sup>-1 在内的数字</strong>，这里 n 是变体使用的位数。如：i8 范围（-128-127）</li><li><strong>无符号的范围为0到 2<sup>n</sup>-1</strong>，如: u8 范围（0-255）(00000000 - 11111111)</li></ul><table><thead><tr><th>类型</th><th>长度</th><th>描述</th></tr></thead><tbody><tr><td>i8, i16, i32, i64, i128</td><td>8,16,32,64,64,128 (bit)</td><td>有符号整数</td></tr><tr><td>u8, u16, u32, u64, u128</td><td>8,16,32,64,64,128 (bit)</td><td>无符号整数</td></tr><tr><td>f32, f64</td><td>32,64(位)</td><td>f32 是单精度浮点数，f64 是双精度浮点数</td></tr><tr><td>isize,  usize</td><td>32或64</td><td>32 位架构上它们是 32 位的，64 位架构上它们是 64 位的</td></tr></tbody></table><h4 id="Rust中的整型字面值"><a href="#Rust中的整型字面值" class="headerlink" title="Rust中的整型字面值:"></a>Rust中的整型字面值:</h4><table><thead><tr><th>数字字面值</th><th>描述</th></tr></thead><tbody><tr><td>Decimal (十进制)</td><td>1_100 （使用 _ 做为分隔符以方便读数）</td></tr><tr><td>Hex (十六进制)</td><td>0xff（0x开头）</td></tr><tr><td>Octal (八进制)</td><td>0o77 （0o开头）</td></tr><tr><td>Binary (二进制)</td><td>0b1111_0000（0b开头）</td></tr><tr><td>Byte (单字节字符)(仅限于u8)</td><td>b’A’（b开头）</td></tr></tbody></table><h4 id="布尔类型-bool："><a href="#布尔类型-bool：" class="headerlink" title="布尔类型 bool："></a>布尔类型 bool：</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> t = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">let</span> f: <span class="built_in">bool</span> = <span class="literal">false</span>; <span class="comment">// with explicit type annotation</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复合类型："><a href="#复合类型：" class="headerlink" title="复合类型："></a>复合类型：</h4><ul><li><p><strong>元组（tuple）和数组（array）</strong></p></li><li><p><strong>Tuple</strong>: 将多个其他类型的值组合进一个复合类型，声明后长度固定，索引下标从0开始.</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let tup: (i32, f64, u8) = (500, 8.4, 2); //声明类型</span><br><span class="line">let score = (&quot;Team A&quot;, 12); //自推断</span><br><span class="line">let five_hundred = tup.0; //取出元组里的500，下标0</span><br></pre></td></tr></table></figure><ul><li><strong>array</strong>: 数组里数据类型必现一致，长度固定</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]; <span class="comment">// 自推断</span></span><br><span class="line"><span class="keyword">let</span> b: [<span class="built_in">i32</span>; <span class="number">5</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]; <span class="comment">// 在方括号中包含每个元素的类型，后跟分号，再后跟数组元素的数量。</span></span><br><span class="line"><span class="keyword">let</span> c = [<span class="number">3</span>; <span class="number">5</span>]; <span class="comment">//变量名为c的数组将包含 5 个元素,数值都为3，等价与let a = [3, 3, 3, 3, 3]</span></span><br></pre></td></tr></table></figure><h2 id="三-流程控制"><a href="#三-流程控制" class="headerlink" title="三. 流程控制"></a>三. 流程控制</h2><h4 id="if-amp-if-let："><a href="#if-amp-if-let：" class="headerlink" title="if &amp;  if let："></a>if &amp;  if let：</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">let</span> number = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">if</span> number &lt; <span class="number">5</span> &#123;</span><br><span class="line">      <span class="built_in">println!</span>(<span class="string">"condition was true"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">println!</span>(<span class="string">"condition was false"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// match pattern and assign variable</span></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(i) = num &#123;</span><br><span class="line">      <span class="built_in">println!</span>(<span class="string">"number is: &#123;&#125;"</span>, i);</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">// if let 语法让我们以一种不那么冗长的方式结合 if 和 let，来处理只匹配一个模式的值而忽略其他模式的情况</span></span><br></pre></td></tr></table></figure><h4 id="loop"><a href="#loop" class="headerlink" title="loop:"></a>loop:</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">loop</span> &#123;</span><br><span class="line">    count += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> count == <span class="number">4</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"break"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Nested loops &amp; labels (循环标签): 如果存在嵌套循环在一个循环上指定一个 循环标签（loop label) 标识为’名字</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">'outer</span>: <span class="keyword">loop</span> &#123;</span><br><span class="line">    <span class="symbol">'inner</span>: <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// This breaks the inner loop</span></span><br><span class="line">        <span class="keyword">break</span> <span class="symbol">'outer</span>; <span class="comment">//   // This breaks the outer loop</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="while-amp-while-let"><a href="#while-amp-while-let" class="headerlink" title="while &amp;  while let:"></a>while &amp;  while let:</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> n &lt; <span class="number">101</span> &#123;</span><br><span class="line">    n += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> optional = <span class="literal">Some</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">let</span> <span class="literal">Some</span>(i) = optional &#123;</span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">"&#123;&#125;"</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="for-遍历集合"><a href="#for-遍历集合" class="headerlink" title="for 遍历集合:"></a>for 遍历集合:</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>];</span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> a &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"the value is: &#123;element&#125;"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用iter()</span></span><br><span class="line"><span class="keyword">let</span> array = [(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">3</span>)];</span><br><span class="line"><span class="keyword">for</span> (x, y) <span class="keyword">in</span> array.iter() &#123;</span><br><span class="line">    <span class="comment">// x, y accessible in loop body only</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"x=&#123;&#125;,y=&#123;&#125;"</span>, x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="match"><a href="#match" class="headerlink" title="match:"></a>match:</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> optional = <span class="literal">Some</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">match</span> optional &#123;</span><br><span class="line">    <span class="literal">Some</span>(i) =&gt; <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, i),</span><br><span class="line">    <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">"No value."</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四-所有权-amp-引用-amp-借用"><a href="#四-所有权-amp-引用-amp-借用" class="headerlink" title="四.所有权&amp;引用&amp;借用"></a>四.所有权&amp;引用&amp;借用</h2><h4 id="所有权规则"><a href="#所有权规则" class="headerlink" title="所有权规则:"></a>所有权规则:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Rust 中的每一个值都有一个 所有者（owner）</span><br><span class="line">值在任一时刻有且只有一个所有者</span><br><span class="line">当所有者（变量）离开作用域，这个值将被丢弃</span><br></pre></td></tr></table></figure><h4 id="借用规则：-引用的行为"><a href="#借用规则：-引用的行为" class="headerlink" title="借用规则：(引用的行为)"></a>借用规则：(引用的行为)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">同一作用域内，一个资源要么有一个可变引用，要么存在多个不可变引用</span><br><span class="line">引用总是有效的</span><br></pre></td></tr></table></figure><h4 id="String引用："><a href="#String引用：" class="headerlink" title="String引用："></a>String引用：</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">"hello world!"</span>);</span><br><span class="line"><span class="keyword">let</span> s1_ref = s1; <span class="comment">// immutable reference</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> s2 = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">let</span> s2_ref = &amp;<span class="keyword">mut</span> s2; <span class="comment">// mutable reference</span></span><br><span class="line">s2_ref.push_str(<span class="string">" world!"</span>);</span><br></pre></td></tr></table></figure><ul><li>函数里使用值，<strong>但不获取所有权, 使用&amp;，获取变量引用 ，仅读权限</strong></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line">    <span class="keyword">let</span> len = calculate_length(&amp;s1);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"The length of '&#123;&#125;' is &#123;&#125;."</span>, s1, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">calculate_length</span></span>(s: &amp;<span class="built_in">String</span>) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">    s.len()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>函数里参数可变引用, <strong>使用&amp;mut ，获取变量可变操作</strong></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line">    change(&amp;<span class="keyword">mut</span> s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  对参数声明&amp;mut ，操作写字符</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">change</span></span>(some_string: &amp;<span class="keyword">mut</span> <span class="built_in">String</span>) &#123;</span><br><span class="line">    some_string.push_str(<span class="string">", world"</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, some_string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="操作符对应的权限："><a href="#操作符对应的权限：" class="headerlink" title="操作符对应的权限："></a>操作符对应的权限：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x   不可变的值（所有权）</span><br><span class="line">&amp;x  x不可变的引用 （只读）</span><br><span class="line">&amp;mut x  x的可变引用（读写）</span><br></pre></td></tr></table></figure><h4 id="字符串-slice"><a href="#字符串-slice" class="headerlink" title="字符串 slice:"></a>字符串 slice:</h4><ul><li>slice 允许你引用集合中一段连续的元素序列，而不用引用整个集合。slice 是一类引用，它没有所有权</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">"hello world"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> hello = &amp;s[<span class="number">0</span>..<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">let</span> world = &amp;s[<span class="number">6</span>..<span class="number">11</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五-struct"><a href="#五-struct" class="headerlink" title="五. struct"></a>五. struct</h2><ul><li><strong>普通结构体： struct+一个名字，在大括号中每一部分可以是不同类型，定义每一部分数据的名字和类型，称之为结构体字段</strong></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span></span> &#123;</span><br><span class="line">    active: <span class="built_in">bool</span>,</span><br><span class="line">    username: <span class="built_in">String</span>,</span><br><span class="line">    email: <span class="built_in">String</span>,</span><br><span class="line">    sign_in_count: <span class="built_in">u64</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>创建一个实例需要以结构体的名字开头，接着在大括号中使用 key: value 键-值对的形式提供字段</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> userinfo = User &#123;</span><br><span class="line">    email: <span class="built_in">String</span>::from(<span class="string">"someone@example.com"</span>),</span><br><span class="line">    username: <span class="built_in">String</span>::from(<span class="string">"someusername123"</span>),</span><br><span class="line">    active: <span class="literal">true</span>,</span><br><span class="line">    sign_in_count: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="元组结构体（tuple-structs"><a href="#元组结构体（tuple-structs" class="headerlink" title="元组结构体（tuple structs):"></a>元组结构体（tuple structs):</h4><ul><li>元组结构体有着结构体名称提供的含义，但没有具体的字段名，只有字段的类型</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Color</span></span>(<span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>(<span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> black = Color(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> origin = Point(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类单元结构体（unit-like-structs）"><a href="#类单元结构体（unit-like-structs）" class="headerlink" title="类单元结构体（unit-like structs）:"></a>类单元结构体（unit-like structs）:</h4><ul><li>没有任何字段的结构体</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AlwaysEqual</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> subject = AlwaysEqual;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="impl为结构体添加方法："><a href="#impl为结构体添加方法：" class="headerlink" title="impl为结构体添加方法："></a>impl为结构体添加方法：</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span> &#123;</span><br><span class="line">    width: <span class="built_in">u32</span>,</span><br><span class="line">    height: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Rectangle &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">area</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>&amp;self 实际上是 self: &amp;Self 的缩写。在一个 impl 块中，Self 类型是 impl 块的类型的别名。方法的第一个参数必须有一个名为 self 的Self 类型的参数</li></ul><h4 id="impl里的关联函数："><a href="#impl里的关联函数：" class="headerlink" title="impl里的关联函数："></a>impl里的关联函数：</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> Rectangle &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">square</span></span>(size: <span class="built_in">u32</span>) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            width: size,</span><br><span class="line">            height: size,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>所有在 impl 块中定义的函数被称为 <strong>关联函数（associated functions</strong>），因为它们与 impl 后面命名的类型相关。我们可以定义不以 self 为第一参数的关联函数（因此不是方法），因为它们并不作用于一个结构体的实例</p></li><li><p><strong>多个 impl 块</strong>： 每个结构体都允许拥有多个 impl 块, 但一个方法只能属于一个impl块。</p></li></ul><h2 id="六-Enum"><a href="#六-Enum" class="headerlink" title="六.Enum"></a>六.Enum</h2><ul><li>结构体给予将字段和数据聚合在一起的方法，像 Rectangle 结构体有 width 和 height 两个字段。而枚举给予你将一个值成为一个集合之一的方法。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">IpAddrKind</span></span> &#123;</span><br><span class="line">    V4,</span><br><span class="line">    V6,</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">IpAddrKind</span></span> &#123;</span><br><span class="line">    V4,</span><br><span class="line">    V6,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> four = IpAddrKind::V4;</span><br><span class="line">    <span class="keyword">let</span> six = IpAddrKind::V6;</span><br><span class="line">    route(IpAddrKind::V4);</span><br><span class="line">    route(IpAddrKind::V6);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">route</span></span>(ip_kind: IpAddrKind) &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="枚举可以包含不同的类型"><a href="#枚举可以包含不同的类型" class="headerlink" title="枚举可以包含不同的类型:"></a><strong>枚举可以包含不同的类型:</strong></h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Message</span></span> &#123;</span><br><span class="line">    Quit, <span class="comment">// 没有关联任何数据</span></span><br><span class="line">    Move &#123; x: <span class="built_in">i32</span>, y: <span class="built_in">i32</span> &#125;, <span class="comment">//类似结构体包含命名字段</span></span><br><span class="line">    Write(<span class="built_in">String</span>), <span class="comment">//包含单独一个 String</span></span><br><span class="line">    ChangeColor(<span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>), <span class="comment">//包含三个 i32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>结构体和枚举还有另一个相似点：<strong>就像可以使用 impl 来为结构体定义方法那样</strong>，也可以在枚举上定义方法。这是一个定义于我们 Message 枚举上的叫做 call 的方法：</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Message</span></span> &#123;</span><br><span class="line">        Quit,</span><br><span class="line">        Move &#123; x: <span class="built_in">i32</span>, y: <span class="built_in">i32</span> &#125;,</span><br><span class="line">        Write(<span class="built_in">String</span>),</span><br><span class="line">        ChangeColor(<span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> Message &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">call</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">            <span class="comment">// 在这里定义方法体</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> m = Message::Write(<span class="built_in">String</span>::from(<span class="string">"hello"</span>));</span><br><span class="line">    m.call();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="标准库中实用的枚举：Option"><a href="#标准库中实用的枚举：Option" class="headerlink" title="标准库中实用的枚举：Option"></a>标准库中实用的枚举：Option</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Option</span></span>&lt;T&gt; &#123;</span><br><span class="line">        <span class="literal">None</span>,</span><br><span class="line">        <span class="literal">Some</span>(T),</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum Result&lt;T, E&gt; &#123;</span><br><span class="line">    OK(T),</span><br><span class="line">    Err(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="七-match控制流结构"><a href="#七-match控制流结构" class="headerlink" title="七.match控制流结构"></a>七.match控制流结构</h2><ul><li><p>前面流程控制简单说明了match使用，<strong>结合enum来看看match的更多使用场景总结</strong></p></li><li><p><strong>基础匹配语法：</strong></p></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> number = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">match</span> number &#123;</span><br><span class="line">    <span class="number">1</span> | <span class="number">2</span> =&gt; <span class="built_in">println!</span>(<span class="string">"1 or 2"</span>), <span class="comment">// 匹配到某一个</span></span><br><span class="line">    <span class="number">3</span>..=<span class="number">5</span> =&gt; <span class="built_in">println!</span>(<span class="string">"3到5"</span>),  <span class="comment">// 通过 ..= 匹配值的范围</span></span><br><span class="line">    _ =&gt; <span class="built_in">println!</span>(<span class="string">"invalid"</span>),    <span class="comment">//未匹配到 _</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="match-解构结构体"><a href="#match-解构结构体" class="headerlink" title="match 解构结构体:"></a>match 解构结构体:</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span> &#123;</span><br><span class="line">    x: <span class="built_in">i32</span>,</span><br><span class="line">    y: <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> p = Point &#123; x: <span class="number">0</span>, y: <span class="number">7</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> Point &#123; x: a, y: b &#125; = p;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">0</span>, a);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">7</span>, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解构枚举："><a href="#解构枚举：" class="headerlink" title="解构枚举："></a>解构枚举：</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Message</span></span> &#123;</span><br><span class="line">    Quit,</span><br><span class="line">    Move &#123; x: <span class="built_in">i32</span>, y: <span class="built_in">i32</span> &#125;,</span><br><span class="line">    Write(<span class="built_in">String</span>),</span><br><span class="line">    ChangeColor(<span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> msg = Message::ChangeColor(<span class="number">0</span>, <span class="number">160</span>, <span class="number">255</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> msg &#123;</span><br><span class="line">        Message::Quit =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"The Quit variant has no data to destructure."</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        Message::Move &#123; x, y &#125; =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(</span><br><span class="line">                <span class="string">"Move in the x direction &#123;&#125; and in the y direction &#123;&#125;"</span>,</span><br><span class="line">                x, y</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        Message::Write(text) =&gt; <span class="built_in">println!</span>(<span class="string">"Text message: &#123;&#125;"</span>, text),</span><br><span class="line">        Message::ChangeColor(r, g, b) =&gt; <span class="built_in">println!</span>(</span><br><span class="line">            <span class="string">"Change the color to red &#123;&#125;, green &#123;&#125;, and blue &#123;&#125;"</span>,</span><br><span class="line">            r, g, b</span><br><span class="line">        ),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印结果到change the color....</span></span><br></pre></td></tr></table></figure><h4 id="解构嵌套的结构体和枚举"><a href="#解构嵌套的结构体和枚举" class="headerlink" title="解构嵌套的结构体和枚举:"></a>解构嵌套的结构体和枚举:</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span></span> &#123;</span><br><span class="line">    Rgb(<span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>),</span><br><span class="line">    Hsv(<span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Message</span></span> &#123;</span><br><span class="line">    Quit,</span><br><span class="line">    Move &#123; x: <span class="built_in">i32</span>, y: <span class="built_in">i32</span> &#125;,</span><br><span class="line">    Write(<span class="built_in">String</span>),</span><br><span class="line">    ChangeColor(Color),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> msg = Message::ChangeColor(Color::Hsv(<span class="number">0</span>, <span class="number">160</span>, <span class="number">255</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> msg &#123;</span><br><span class="line">        Message::ChangeColor(Color::Rgb(r, g, b)) =&gt; <span class="built_in">println!</span>(</span><br><span class="line">            <span class="string">"Change the color to red &#123;&#125;, green &#123;&#125;, and blue &#123;&#125;"</span>,</span><br><span class="line">            r, g, b</span><br><span class="line">        ),</span><br><span class="line">        Message::ChangeColor(Color::Hsv(h, s, v)) =&gt; <span class="built_in">println!</span>(</span><br><span class="line">            <span class="string">"Change the color to hue &#123;&#125;, saturation &#123;&#125;, and value &#123;&#125;"</span>,</span><br><span class="line">            h, s, v</span><br><span class="line">        ),</span><br><span class="line">        _ =&gt; (),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="用-忽略剩余值"><a href="#用-忽略剩余值" class="headerlink" title="用 .. 忽略剩余值:"></a>用 .. 忽略剩余值:</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过使用 .. 来忽略 Point 中除 x 以外的字段</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span> &#123;</span><br><span class="line">        x: <span class="built_in">i32</span>,</span><br><span class="line">        y: <span class="built_in">i32</span>,</span><br><span class="line">        z: <span class="built_in">i32</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> origin = Point &#123; x: <span class="number">0</span>, y: <span class="number">0</span>, z: <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> origin &#123;</span><br><span class="line">        Point &#123; x, .. &#125; =&gt; <span class="built_in">println!</span>(<span class="string">"x is &#123;&#125;"</span>, x),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Match-guards"><a href="#Match-guards" class="headerlink" title="Match guards:"></a><strong>Match guards:</strong></h4><ul><li>匹配守卫（match guard）是一个指定于 match 分支模式之后的额外 if 条件，它也必须被满足才能选择此分支</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> num = <span class="literal">Some</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">match</span> num &#123;</span><br><span class="line">        <span class="literal">Some</span>(x) <span class="keyword">if</span> x &lt; <span class="number">5</span> =&gt; <span class="built_in">println!</span>(<span class="string">"less than five: &#123;&#125;"</span>, x),</span><br><span class="line">        <span class="literal">Some</span>(x) =&gt; <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, x),</span><br><span class="line">        <span class="literal">None</span> =&gt; (),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="绑定"><a href="#绑定" class="headerlink" title="@绑定:"></a><strong>@绑定:</strong></h4><ul><li>运算符@，允许我们在创建一个存放值的变量的同时，测试其值是否匹配模式。即@ 可以在一个模式中同时测试和保存变量值。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Message</span></span> &#123;</span><br><span class="line">        Hello &#123; id: <span class="built_in">i32</span> &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> msg = Message::Hello &#123; id: <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="keyword">match</span> msg &#123;</span><br><span class="line">        Message::Hello &#123;</span><br><span class="line">            id: id_variable @ <span class="number">3</span>..=<span class="number">7</span>, <span class="comment">//使用id_variable变量配合@，以便此分支相关联的代码可以使用它</span></span><br><span class="line">        &#125; =&gt; <span class="built_in">println!</span>(<span class="string">"Found an id in range: &#123;&#125;"</span>, id_variable),</span><br><span class="line">        Message::Hello &#123; id: <span class="number">10</span>..=<span class="number">12</span> &#125; =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"Found an id in another range"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        Message::Hello &#123; id &#125; =&gt; <span class="built_in">println!</span>(<span class="string">"Found some other id: &#123;&#125;"</span>, id),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Rust精简笔记&quot;&gt;&lt;a href=&quot;#Rust精简笔记&quot; class=&quot;headerlink&quot; title=&quot;Rust精简笔记&quot;&gt;&lt;/a&gt;Rust精简笔记&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;适用对Rust感兴趣，想快速学习上手（多学几轮）、Rust知识点速查、回顾。&lt;/</summary>
      
    
    
    
    <category term="Rust" scheme="https://zhulg.github.io/categories/Rust/"/>
    
    
    <category term="Rust" scheme="https://zhulg.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Flutter Widget生命周期总结</title>
    <link href="https://zhulg.github.io/posts/f4ca6a79.html"/>
    <id>https://zhulg.github.io/posts/f4ca6a79.html</id>
    <published>2022-05-27T06:26:29.000Z</published>
    <updated>2024-07-07T04:21:27.923Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Flutter Widget生命周期分为2种，一种有状态的组件StatefulWidget的生命周期，和无状态的StatelessWidget 组件的生命周期。</li></ul><h2 id="一-StatefulWidget的生命周期"><a href="#一-StatefulWidget的生命周期" class="headerlink" title="一.StatefulWidget的生命周期"></a>一.StatefulWidget的生命周期</h2><ul><li>先看一张statefulwidget生命周期图 <strong>（若文中图片无法显示，请科学上网查看：<a href="https://order.yizhihongxing.network/aff.php?aff=12299" target="_blank" rel="noopener">推荐工具</a>）</strong></li><li>继承StatefulWidget的组件会先进行构造方法，在进行对应的Widget的CreateState, 在State里</li></ul><p><img src="https://raw.githubusercontent.com/zhulg/allpic/master/flutter_widgetlifecycle.png" alt></p><h3 id="1-createState："><a href="#1-createState：" class="headerlink" title="1.createState："></a><em>1.createState：</em></h3><ul><li>创建新的StatefulWidget的时候，就会立即执行createState方法，<strong>返回一个state的实例与当前widget建立关系。</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class MyHomePage extends StatefulWidget &#123;</span><br><span class="line">  const MyHomePage(&#123;Key? key, required this.title&#125;) : super(key: key);</span><br><span class="line">  final String title;</span><br><span class="line">  @override</span><br><span class="line">  State&lt;MyHomePage&gt; createState() =&gt; _MyHomePageState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-initState："><a href="#2-initState：" class="headerlink" title="2. initState："></a><em>2. initState：</em></h3><ul><li>initState 是 StatefulWidget 创建完后，在State里调用的第一个方法, 只执行一次（iOS 的 viewDidLoad()、Android 的 onCreate）, StatefulWidget 已经被加载到渲染树里了但还没开始渲染，这里常做一些初始化变量工作。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@override</span><br><span class="line">void initState()&#123;</span><br><span class="line">  super.initState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-didChangeDependencies"><a href="#3-didChangeDependencies" class="headerlink" title="3. didChangeDependencies:"></a><em>3. didChangeDependencies:</em></h3><ul><li>在initState回调函数执行之后立即调用，之后当 StatefulWidget 刷新的时候，就不会调用了, <strong>当State对象的依赖发生变化时会被再次调用（层级变化&amp;共享依赖变化）</strong>。官网文档举例，如果之前build构建里依赖的 InheritedWidget 发生变化之后，那么他的 didChangeDependencies 会被再次调用。（InheritedWidget是 Flutter 中非常重要的一个功能型组件，它提供了一种在 widget 树中从上到下共享数据的方式，应用的根 widget 中通过InheritedWidget共享了一个数据，可以在任意子widget 中来获取该共享的数据）（场景：主题颜色、地区语言或者其他通用变量等）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@override</span><br><span class="line">void didChangeDependencies() &#123; &#125;</span><br></pre></td></tr></table></figure><h3 id="4-build："><a href="#4-build：" class="headerlink" title="4. build："></a><em>4. build：</em></h3><ul><li>build方法在didChangeDependencies之后会立即调用，之后每次当setState方法被调用后，都会进行重新build，并返回要渲染的widiget </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@override</span><br><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  return Scaffold()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-didUpdateWidget："><a href="#5-didUpdateWidget：" class="headerlink" title="5. didUpdateWidget："></a><em>5. didUpdateWidget：</em></h3><ul><li>比较严谨官方描述:  If the parent widget changes its properties or configurations, and the parent wants to rebuild the child widget, with the same Runtime Type, then didUpdateWidget is triggered. This unsubscribes to the old widget and subscribes to the configuration changes of the new widget! </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@override</span><br><span class="line">  void didUpdateWidget(covariant CurrentClass oldWidget) &#123;</span><br><span class="line">    // TODO: implement didUpdateWidget</span><br><span class="line">    super.didUpdateWidget(oldWidget);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="6-deactivate："><a href="#6-deactivate：" class="headerlink" title="6.  deactivate："></a><em>6.  deactivate：</em></h3><ul><li>当要将 State 对象从渲染树中移除的时候，就会调用 deactivate 生命周期，这标志着 StatefulWidget 将要销毁，但是有时候 State 不会被销毁，而是重新插入到渲染树种(例如；当使用Navigator.push 移动到下一个屏幕)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@override</span><br><span class="line">  void deactivate() &#123;</span><br><span class="line">    super.deactivate();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="7-dispose"><a href="#7-dispose" class="headerlink" title="7. dispose"></a><em>7. dispose</em></h3><ul><li>当 View 不需要再显示，从渲染树中移除的时候，State 就会永久的从渲染树中移除，就会调用 dispose 生命周期，(在 dispose 里做一些取消监听、动画的操作，和 initState 是相反)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@override</span><br><span class="line">  void dispose() &#123;</span><br><span class="line">    super.dispose();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="二-StatelessWidget的生命周期"><a href="#二-StatelessWidget的生命周期" class="headerlink" title="二. StatelessWidget的生命周期"></a>二. StatelessWidget的生命周期</h2><ul><li>StatelessWidget的生命周期比较简单，通过构造方法，build方法来进行渲染需要的widget，由于是无状态的也就执行一次。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;Flutter Widget生命周期分为2种，一种有状态的组件StatefulWidget的生命周期，和无状态的StatelessWidget 组件的生命周期。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;一-StatefulWidget的生命周期&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="flutter" scheme="https://zhulg.github.io/categories/flutter/"/>
    
    
    <category term="flutter" scheme="https://zhulg.github.io/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter架构构成和渲染原理</title>
    <link href="https://zhulg.github.io/posts/c8a78489.html"/>
    <id>https://zhulg.github.io/posts/c8a78489.html</id>
    <published>2022-05-13T09:04:58.000Z</published>
    <updated>2024-07-07T04:21:27.924Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-Flutter架构构成"><a href="#一-Flutter架构构成" class="headerlink" title="一.Flutter架构构成"></a>一.Flutter架构构成</h2><ul><li><p>Flutter的架构是一个可扩展的分层系统设计，上层组件各自依赖下层组件，层级不可越级访问，各个层级模块可替换</p></li><li><p><strong>Flutter从分层构成看主要分为3个层级：</strong></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Dart Framework</span><br><span class="line">C++ Engine</span><br><span class="line">Platform Embedder</span><br></pre></td></tr></table></figure><ul><li>从官网的架构图片层级分析：（科学上网可见图片）</li></ul><div align="center" width="100%">  <img width="80%" src="https://raw.githubusercontent.com/zhulg/allpic/master/flutter_arch.png"></div><h3 id="1-Platform-Embedder：-平台嵌入层"><a href="#1-Platform-Embedder：-平台嵌入层" class="headerlink" title="1. Platform Embedder：(平台嵌入层)"></a><em>1. Platform Embedder：(平台嵌入层)</em></h3><ul><li><strong>平台层潜入层作用:</strong>是把 Flutter 代码打包嵌入到具体的实现平台, 来呈现所有 Flutter 内容的原生系统应用, 它充当着宿主操作系统（android/ios/macOS/..）和 Flutter 之间的粘合剂的角色。</li><li>提供flutter的运行入口，初始化 Flutter 引擎，管理flutter应用生命周期</li><li>并对上层提供最基础的能力(渲染画布、插件系统、交互管理、消息循环等)</li></ul><h3 id="2-C-C-Engine"><a href="#2-C-C-Engine" class="headerlink" title="2. C/C++ Engine:"></a><strong><em>2. C/C++ Engine:</em></strong></h3><ul><li>它的主要职责是光栅化合成上屏幕用于显示绘制内容（当需要绘制新一帧的内容时，将负责对需要合成的场景进行栅格化）</li><li>提供了 Flutter 核心 API 的底层实现，包括图形（通过 Skia）、文本布局、文件及网络 IO、辅助功能支持、插件架构和 Dart 运行环境及编译环境的工具链。</li><li>引擎将底层 C++ 代码包装成 Dart 代码，通过 dart:ui 暴露给 Flutter 框架层，而dart:ui 包是 Flutter App 的构建基础</li></ul><h3 id="3-Dart-Framework"><a href="#3-Dart-Framework" class="headerlink" title="3. Dart Framework:"></a><strong><em>3. Dart Framework:</em></strong></h3><ul><li>提供了以 Dart 语言编写的现代响应式框架，对渲染逻辑做了统一封装，屏蔽了底层实现，对底层 C++ Engine 提供双向通信能力</li><li><strong>开发者只需要通过该层使用widget控件构建 App 视图即可</strong></li><li>Dart Framework 包括丰富的平台，布局和基础库。从上层到下层，依次有：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Material 和 Cupertino 分别实现了 android Material 和 iOS 设计规范。</span><br><span class="line">widget 层是一种组合的抽象,widgets 层让可以自由组合你需要复用的各种控件类</span><br><span class="line">渲染层 用于提供操作布局的抽象，负责控件布局摆放及更新</span><br><span class="line">基础的 foundational 类及一些基层之上的构建块服务， animation、 painting 和 gestures，它们可以提供上层常用的抽象。</span><br></pre></td></tr></table></figure><h2 id="Flutter核心组件"><a href="#Flutter核心组件" class="headerlink" title="Flutter核心组件"></a>Flutter核心组件</h2><h3 id="1-Widget-应用开发者直接使用"><a href="#1-Widget-应用开发者直接使用" class="headerlink" title="1.Widget (应用开发者直接使用)"></a>1.Widget (应用开发者直接使用)</h3><ul><li>Widget是Flutter的核心部分, Flutter的口号 Everything’s a widget,是构建应用的基础块</li><li>Widgets 通过布局组合形成一种层次结构关系。每个 Widget 都嵌套在其父级的内部，并可以通过父级接收上下文</li><li>Widget 不只表示UI 控件，还表示一些功能性的组件Navigator、GestureDetector 组件</li></ul><h3 id="2-Element-（实例化的-Widget-对象）"><a href="#2-Element-（实例化的-Widget-对象）" class="headerlink" title="2. Element （实例化的 Widget 对象）"></a>2. Element （实例化的 Widget 对象）</h3><ul><li>在构建的阶段，Flutter 会将代码中描述的 widgets 转换成对应的 Element 树，每一个 Widget 都有一个对应的 Element。<strong>每一个 Element 代表了树状层级结构中特定位置的 widget 实例。</strong></li><li>目前有两种 Element 的基本类型：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ComponentElement : Element 的宿主 </span><br><span class="line">RenderObjectElement :参与布局或绘制阶段的 Element。</span><br></pre></td></tr></table></figure><ul><li><strong>在代码阶段的widget层级在生成绘制后会多一些层级（源码和官网演示看查看到）</strong>，这里面多一些的层级往往就是参与布局和绘制RenderObjectElement</li></ul><div align="center" width="100%">  <img width="80%" src="https://raw.githubusercontent.com/zhulg/allpic/master/element-tree.png"></div><ul><li>注：ColoredBox 、RawImage、RichText 为绘制时产生的新增widget层级（科学上网可见图片）</li></ul><h3 id="3-RenderObject（树形）"><a href="#3-RenderObject（树形）" class="headerlink" title="3.RenderObject（树形）"></a>3.RenderObject（树形）</h3><ul><li>用于应用界面的布局和绘制，保存了元素的大小，布局等信息</li><li><strong>在构建阶段，Flutter 会为 Element 树中的每个 RenderObjectElement 创建或更新其对应的一个从 RenderObject 继承的对象</strong>。</li><li><strong>当应用运行时 Flutter 使用 RenderObject 的数据绘制应用界面，最终形成一个 Render Tree</strong>。(图片需要科学上网)</li></ul><div align="center" width="100%">  <img width="80%" src="https://raw.githubusercontent.com/zhulg/allpic/master/flutter-renderTree.png"></div><ul><li>大部分的 Flutter widget 是由一个继承了 RenderBox 的子类的对象渲染的，真正负责干活（layout、paint）</li><li>所有 RenderObject 的根节点是 RenderView，代表了渲染树的总体输出。当平台需要渲染新的一帧内容时（例如一个 vsync 信号或者一个纹理的更新完成），会调用一次 compositeFrame() 方法，它是 RenderView 的一部分。该方法会创建一个 SceneBuilder 来触发当前画面的更新。当画面更新完毕，RenderView 会将合成的画面传递给 dart:ui 中的 Window.render() 方法，控制 GPU 进行渲染。</li></ul><h3 id="三者直接关系："><a href="#三者直接关系：" class="headerlink" title="三者直接关系："></a>三者直接关系：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Widget 是应用界面的声明的控件，为开发者直接使用的控件</span><br><span class="line">Element 链接 Widget 和 RenderObject，管理界面的更新和修改。</span><br><span class="line">RenderObject 保存具体的布局信息，负责绘制 UI, 为实际渲染</span><br></pre></td></tr></table></figure><ul><li><strong>Widget重新创建，Element 树和 RenderObject 树并不会完全重新创建</strong>，如果 newWidget 与oldWidget 的 runtimeType 和 key 相等时，更新已经存在的 Element 对象，不然就选择重新创建新的 Element。</li></ul><h2 id="二-Flutter渲染原理"><a href="#二-Flutter渲染原理" class="headerlink" title="二.Flutter渲染原理"></a>二.Flutter渲染原理</h2><ul><li>从Flutter的核心控件大概已经初步了解到了渲染的相关流程，核心控件到绘制的情况。</li><li><strong>一般计算机绘图原理：</strong>屏幕显示器一般以60Hz的固定频率刷新，每一帧图像绘制完成后，会继续绘制下一帧，这时显示器就会发出一个Vsync信号，按60Hz计算，屏幕每秒会发出60次这样的信号。CPU计算好显示内容提交给GPU，GPU渲染好传递给显示器显示。flutter 渲染原理相同。渲染过程会使用上边介绍的核心流程控件。</li></ul><div align="center" width="100%">  <img width="80%" src="https://raw.githubusercontent.com/zhulg/allpic/master/flutter-render.png"></div><ul><li>Flutter 的渲染流水线也包括两个线程，<strong>UI 线程和 GPU 线程，UI 线程主要负责的是根据 UI 界面的描述生成 UI 界面的绘制指令，建立过程中生成 Render，往下布局、绘制大小等工作，完成以后会生成一个 Layer Tree，到了 GPU 线程之后会调用 Skia 做渲染</strong></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一-Flutter架构构成&quot;&gt;&lt;a href=&quot;#一-Flutter架构构成&quot; class=&quot;headerlink&quot; title=&quot;一.Flutter架构构成&quot;&gt;&lt;/a&gt;一.Flutter架构构成&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Flutter的架构是一个可扩展的</summary>
      
    
    
    
    <category term="flutter" scheme="https://zhulg.github.io/categories/flutter/"/>
    
    
    <category term="flutter" scheme="https://zhulg.github.io/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>NFT是什么有哪些应用场景</title>
    <link href="https://zhulg.github.io/posts/64ceaf0c.html"/>
    <id>https://zhulg.github.io/posts/64ceaf0c.html</id>
    <published>2022-05-06T05:59:54.000Z</published>
    <updated>2024-07-07T04:21:27.925Z</updated>
    
    <content type="html"><![CDATA[<h2 id="NFT是什么"><a href="#NFT是什么" class="headerlink" title="NFT是什么"></a>NFT是什么</h2><ul><li>NFT的全称为 Non-fungible Tokens（非同质化代币 ) ，<strong>用以代表独特物品所有权的代币</strong></li><li><strong>非同质化</strong>是一个经济术语，用它来描述家具、歌曲、字画、电脑等物品，<strong>这些东西不能与其他物品互换，因为它们具有独特属性。</strong></li><li><strong>NFT的主要功能是作为可验证的所有权证明，并显示资产所有权随时间推移的转移记录</strong></li><li>NFT起源于2017年的加密猫游戏，用于表示每只猫拥有的不同花色、基因、代际等信息。</li><li>目前最热的在数字艺术品、收藏品只是使用 NFT 的一种方式，NFT可以代表任何独特资产的所有权。<div align="center" width="100%"><img width="80%" src="https://raw.githubusercontent.com/zhulg/allpic/master/NFT_PIC.jpeg"></div></li><li><strong>（若文中图片无法显示，请科学上网查看：<a href="https://order.yizhihongxing.network/aff.php?aff=12299" target="_blank" rel="noopener">推荐工具</a>）</strong></li></ul><h2 id="NFT的工作原理"><a href="#NFT的工作原理" class="headerlink" title="NFT的工作原理"></a>NFT的工作原理</h2><ul><li>NFT通过工作量证明（PoW）区块链运作，PoW是一个过程，其中一方向其他方证明已经为一个目标付出了一定量的努力</li><li>NFT 一次只能有一个所有者。 通过唯一的 ID 和其他代币无法复制的元数据管理所有权。</li><li>NFT 通过智能合约铸造，智能合约分配 NFT 的所有权并管理它们的可转让性。</li><li>有人创建或铸造 NFT 时，他们会执行存储在符合不同标准的智能合约中的代码(如 ERC-721。 此信息会添加到正在管理 NFT 的区块链中)</li><li>铸造过程具有以下步骤：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">新建区块</span><br><span class="line">验证信息</span><br><span class="line">将信息录入区块链</span><br></pre></td></tr></table></figure><h2 id="NFT与去中心化"><a href="#NFT与去中心化" class="headerlink" title="NFT与去中心化"></a>NFT与去中心化</h2><ul><li>NFT的核心是内容和所有权验证，由于区块链不适合存储大量数据，因此一般将NFT的元数据（metadata）存储在去中心化存储网络上（一般是IPFS），将NFT的发行、流通记录存储在区块链上</li></ul><h2 id="NFT-有什么用"><a href="#NFT-有什么用" class="headerlink" title="NFT 有什么用"></a>NFT 有什么用</h2><ul><li>加速数字化，数字化后更便于流通、存证、防伪、溯源，复制实体物品的属性，稀缺性、独特性和所有权证明形成NFT</li><li>解决了当前互联网上存在的一些问题。</li></ul><table><thead><tr><th>NFT互联网</th><th>目前互联网</th></tr></thead><tbody><tr><td>NFT 在数字世界里是独一无二的，没有两个相同的 NFT</td><td>文件副本（如.mp3 或 .jpg）与原始文件并无二致</td></tr><tr><td>每个 NFT 必须有一个所有者，而且是一条公开记录，任何人都可以轻松核实。</td><td>数字物品的所有权记录存储在由机构控制的服务器上 - 您必须相信他们的话</td></tr><tr><td>NFT 与使用以太坊构建的任何内容都兼容交换</td><td>拥有数字产品的公司必须构建自己的基础设施。 例如，一个售卖活动数字门票的应用程序必须建立自己的门票交易所。</td></tr><tr><td>内容创建人可以在任何地方出售他们的作品，并可以进入全球市场。</td><td>创建人依靠所用平台的基础设施和分布。 这些通常受到使用条款和地理限制的制约。</td></tr><tr><td>创建人可以保留对自己作品的所有权，并直接要求收取转售版税。</td><td>音乐媒体服务等平台扣留了大部分销售利润</td></tr></tbody></table><h2 id="如何创建NFT"><a href="#如何创建NFT" class="headerlink" title="如何创建NFT"></a>如何创建NFT</h2><ul><li>NFT交易平台均可创建，如：OpenSea、Rarible、SuperRare、MakersPlace、KnowOrigin、Mintbase、Foundation、AsyncArt等。</li><li>其本质为数字资产token化，数字资产分两类：原生数字资产（如：纯数字载体艺术品）、数字化后的物理资产（如：实体油画的扫描电子版、嵌入NFC芯片的实体雕塑等）</li></ul><h2 id="NFT的应用场景和未来"><a href="#NFT的应用场景和未来" class="headerlink" title="NFT的应用场景和未来"></a>NFT的应用场景和未来</h2><ul><li>NFT有可能带来盗版保护、知识产权安全、数字身份验证系统、内容创作者收入系统、游戏、许可、证书、美术的全新世界，甚至允许拥有巨大价值的房地产的部分所有权。</li><li>数字艺术品：艺术家可以将其数字艺术品变现、游戏中创建可验证的游戏物品、游戏中创建可验证的游戏物品</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GIF</span><br><span class="line">收藏品</span><br><span class="line">音乐</span><br><span class="line">视频</span><br><span class="line">车内饰品</span><br><span class="line">真实世界活动的门票</span><br><span class="line">代币化发票</span><br><span class="line">法律文档</span><br><span class="line">签名</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;NFT是什么&quot;&gt;&lt;a href=&quot;#NFT是什么&quot; class=&quot;headerlink&quot; title=&quot;NFT是什么&quot;&gt;&lt;/a&gt;NFT是什么&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;NFT的全称为 Non-fungible Tokens（非同质化代币 ) ，&lt;strong&gt;用以</summary>
      
    
    
    
    <category term="元宇宙" scheme="https://zhulg.github.io/categories/元宇宙/"/>
    
    
    <category term="区块链" scheme="https://zhulg.github.io/tags/区块链/"/>
    
    <category term="元宇宙" scheme="https://zhulg.github.io/tags/元宇宙/"/>
    
  </entry>
  
</feed>
